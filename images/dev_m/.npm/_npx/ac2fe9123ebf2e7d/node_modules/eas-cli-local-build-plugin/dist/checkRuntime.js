"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkRuntimeAsync = void 0;
const eas_build_job_1 = require("@expo/eas-build-job");
const chalk_1 = __importDefault(require("chalk"));
const spawn_async_1 = __importDefault(require("@expo/spawn-async"));
const fs_extra_1 = __importDefault(require("fs-extra"));
function warn(msg) {
    console.log(chalk_1.default.yellow(msg));
}
function error(msg) {
    console.error(chalk_1.default.red(msg));
}
const validators = [
    {
        async checkAsync(job) {
            if (job.platform === eas_build_job_1.Platform.IOS && process.platform !== 'darwin') {
                throw new Error('iOS builds can only be run on macOS.');
            }
            else if (job.platform === eas_build_job_1.Platform.ANDROID &&
                !['linux', 'darwin'].includes(process.platform)) {
                throw new Error('Android builds are supported only on Linux and macOS');
            }
        },
    },
    {
        async checkAsync(job) {
            var _a;
            try {
                const version = (await (0, spawn_async_1.default)('node', ['--version'], { stdio: 'pipe' })).stdout.trim();
                const sanitizedVersion = version.startsWith('v') ? version.slice(1) : version;
                const versionFromJob = (_a = job.builderEnvironment) === null || _a === void 0 ? void 0 : _a.node;
                if (versionFromJob) {
                    const sanitizedVersionFromJob = versionFromJob.startsWith('v')
                        ? versionFromJob.slice(1)
                        : versionFromJob;
                    if (sanitizedVersion !== sanitizedVersionFromJob) {
                        warn('Node.js version in your eas.json does not match the Node.js currently installed in your system');
                    }
                }
            }
            catch (err) {
                error("Node.js is not available, make sure it's installed and in your PATH");
                throw err;
            }
        },
    },
    {
        async checkAsync(job) {
            var _a;
            const versionFromJob = (_a = job.builderEnvironment) === null || _a === void 0 ? void 0 : _a.yarn;
            if (!versionFromJob) {
                return;
            }
            try {
                const version = (await (0, spawn_async_1.default)('yarn', ['--version'], { stdio: 'pipe' })).stdout.trim();
                if (versionFromJob !== version) {
                    warn('Yarn version in your eas.json does not match the yarn currently installed in your system');
                }
            }
            catch (err) {
                warn("Yarn is not available, make sure it's installed and in your PATH");
            }
        },
    },
    {
        platform: eas_build_job_1.Platform.ANDROID,
        async checkAsync(_) {
            if (!process.env.ANDROID_NDK_HOME) {
                warn('ANDROID_NDK_HOME environment variable was not specified, continuing build without NDK');
                return;
            }
            if (!(await fs_extra_1.default.pathExists(process.env.ANDROID_NDK_HOME))) {
                throw new Error(`NDK was not found under ${process.env.ANDROID_NDK_HOME}`);
            }
        },
    },
    {
        platform: eas_build_job_1.Platform.IOS,
        async checkAsync() {
            try {
                await (0, spawn_async_1.default)('fastlane', ['--version'], {
                    stdio: 'pipe',
                    env: Object.assign(Object.assign({}, process.env), { FASTLANE_DISABLE_COLORS: '1', FASTLANE_SKIP_UPDATE_CHECK: '1', SKIP_SLOW_FASTLANE_WARNING: 'true', FASTLANE_HIDE_TIMESTAMP: 'true' }),
                });
            }
            catch (err) {
                error("Fastlane is not available, make sure it's installed and in your PATH");
                throw err;
            }
        },
    },
    {
        platform: eas_build_job_1.Platform.IOS,
        async checkAsync(job) {
            var _a;
            try {
                const version = (await (0, spawn_async_1.default)('pod', ['--version'], { stdio: 'pipe' })).stdout.trim();
                const versionFromJob = job.platform === eas_build_job_1.Platform.IOS && ((_a = job.builderEnvironment) === null || _a === void 0 ? void 0 : _a.cocoapods);
                if (versionFromJob && versionFromJob !== version) {
                    warn('Cocoapods version in your eas.json does not match the version currently installed in your system');
                }
            }
            catch (err) {
                error("Cocoapods is not available, make sure it's installed and in your PATH");
                throw err;
            }
        },
    },
];
async function checkRuntimeAsync(job) {
    for (const validator of validators) {
        if (validator.platform === job.platform || !validator.platform) {
            await validator.checkAsync(job);
        }
    }
}
exports.checkRuntimeAsync = checkRuntimeAsync;
//# sourceMappingURL=checkRuntime.js.map