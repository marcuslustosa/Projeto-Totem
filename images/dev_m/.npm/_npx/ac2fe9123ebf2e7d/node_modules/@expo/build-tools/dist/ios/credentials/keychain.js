"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const turtle_spawn_1 = __importDefault(require("@expo/turtle-spawn"));
const uuid_1 = require("uuid");
const fastlane_1 = require("../fastlane");
class Keychain {
    constructor(ctx) {
        this.ctx = ctx;
        this.created = false;
        this.destroyed = false;
        this.keychainPath = path_1.default.join(os_1.default.tmpdir(), `turtle-v2-${(0, uuid_1.v4)()}.keychain`);
        this.keychainPassword = (0, uuid_1.v4)();
    }
    get data() {
        return {
            path: this.keychainPath,
            password: this.keychainPassword,
        };
    }
    async create() {
        this.ctx.logger.debug(`Creating keychain - ${this.keychainPath}`);
        await (0, fastlane_1.runFastlane)([
            'run',
            'create_keychain',
            `path:${this.keychainPath}`,
            `password:${this.keychainPassword}`,
            'unlock:true',
            'timeout:360000',
        ]);
        this.created = true;
    }
    async importCertificate(certPath, certPassword) {
        if (!this.created) {
            throw new Error('You must create a keychain first.');
        }
        this.ctx.logger.debug(`Importing certificate ${certPath} into keychain ${this.keychainPath}`);
        await (0, fastlane_1.runFastlane)([
            'run',
            'import_certificate',
            `certificate_path:${certPath}`,
            `certificate_password:${certPassword}`,
            `keychain_path:${this.keychainPath}`,
            `keychain_password:${this.keychainPassword}`,
        ]);
    }
    async ensureCertificateImported(teamId, fingerprint) {
        const identities = await this.findIdentitiesByTeamId(teamId);
        if (!identities.includes(fingerprint)) {
            throw new Error(`Distribution certificate with fingerprint ${fingerprint} hasn't been imported successfully`);
        }
    }
    async destroy(keychainPath) {
        if (!keychainPath && !this.created) {
            this.ctx.logger.warn("There is nothing to destroy, a keychain hasn't been created yet.");
            return;
        }
        if (this.destroyed) {
            this.ctx.logger.warn('The keychain has been already destroyed');
            return;
        }
        const keychainToDeletePath = keychainPath !== null && keychainPath !== void 0 ? keychainPath : this.keychainPath;
        this.ctx.logger.info(`Destroying keychain - ${keychainToDeletePath}`);
        try {
            await (0, fastlane_1.runFastlane)(['run', 'delete_keychain', `keychain_path:${keychainToDeletePath}`]);
            this.destroyed = true;
        }
        catch (err) {
            this.ctx.logger.error({ err }, 'Failed to delete the keychain\n');
            throw err;
        }
    }
    async cleanUpKeychains() {
        var _a;
        const { stdout } = await (0, turtle_spawn_1.default)('security', ['list-keychains'], { stdio: 'pipe' });
        const keychainList = ((_a = /"(.*)"/g.exec(stdout)) !== null && _a !== void 0 ? _a : []).map((i) => i.slice(1, i.length - 1));
        const turtleKeychainList = keychainList.filter((keychain) => /turtle-v2-[\w-]+\.keychain$/.exec(keychain));
        for (const turtleKeychainPath of turtleKeychainList) {
            await this.destroy(turtleKeychainPath);
        }
    }
    async findIdentitiesByTeamId(teamId) {
        const { output } = await (0, turtle_spawn_1.default)('security', ['find-identity', '-v', '-s', `(${teamId})`, this.keychainPath], {
            stdio: 'pipe',
        });
        return output.join('');
    }
}
exports.default = Keychain;
//# sourceMappingURL=keychain.js.map