"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.androidGetNativelyDefinedRuntimeVersionAsync = exports.androidGetNativelyDefinedClassicReleaseChannelAsync = exports.androidSetClassicReleaseChannelNativelyAsync = exports.androidGetNativelyDefinedChannelAsync = exports.androidSetChannelNativelyAsync = exports.androidSetRuntimeVersionNativelyAsync = exports.AndroidMetadataName = void 0;
const assert_1 = __importDefault(require("assert"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const config_plugins_1 = require("@expo/config-plugins");
var AndroidMetadataName;
(function (AndroidMetadataName) {
    AndroidMetadataName["UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY"] = "expo.modules.updates.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY";
    AndroidMetadataName["RELEASE_CHANNEL"] = "expo.modules.updates.EXPO_RELEASE_CHANNEL";
    AndroidMetadataName["RUNTIME_VERSION"] = "expo.modules.updates.EXPO_RUNTIME_VERSION";
})(AndroidMetadataName = exports.AndroidMetadataName || (exports.AndroidMetadataName = {}));
async function androidSetRuntimeVersionNativelyAsync(ctx, runtimeVersion) {
    const manifestPath = await config_plugins_1.AndroidConfig.Paths.getAndroidManifestAsync(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(manifestPath))) {
        throw new Error(`Couldn't find Android manifest at ${manifestPath}`);
    }
    const androidManifest = await config_plugins_1.AndroidConfig.Manifest.readAndroidManifestAsync(manifestPath);
    const mainApp = config_plugins_1.AndroidConfig.Manifest.getMainApplicationOrThrow(androidManifest);
    config_plugins_1.AndroidConfig.Manifest.addMetaDataItemToMainApplication(mainApp, AndroidMetadataName.RUNTIME_VERSION, runtimeVersion, 'value');
    await config_plugins_1.AndroidConfig.Manifest.writeAndroidManifestAsync(manifestPath, androidManifest);
}
exports.androidSetRuntimeVersionNativelyAsync = androidSetRuntimeVersionNativelyAsync;
async function androidSetChannelNativelyAsync(ctx) {
    var _a;
    (0, assert_1.default)((_a = ctx.job.updates) === null || _a === void 0 ? void 0 : _a.channel, 'updates.channel must be defined');
    const manifestPath = await config_plugins_1.AndroidConfig.Paths.getAndroidManifestAsync(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(manifestPath))) {
        throw new Error(`Couldn't find Android manifest at ${manifestPath}`);
    }
    const androidManifest = await config_plugins_1.AndroidConfig.Manifest.readAndroidManifestAsync(manifestPath);
    const mainApp = config_plugins_1.AndroidConfig.Manifest.getMainApplicationOrThrow(androidManifest);
    const stringifiedUpdatesRequestHeaders = config_plugins_1.AndroidConfig.Manifest.getMainApplicationMetaDataValue(androidManifest, AndroidMetadataName.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY);
    config_plugins_1.AndroidConfig.Manifest.addMetaDataItemToMainApplication(mainApp, AndroidMetadataName.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY, JSON.stringify(Object.assign(Object.assign({}, JSON.parse(stringifiedUpdatesRequestHeaders !== null && stringifiedUpdatesRequestHeaders !== void 0 ? stringifiedUpdatesRequestHeaders : '{}')), { 'expo-channel-name': ctx.job.updates.channel })), 'value');
    await config_plugins_1.AndroidConfig.Manifest.writeAndroidManifestAsync(manifestPath, androidManifest);
}
exports.androidSetChannelNativelyAsync = androidSetChannelNativelyAsync;
async function androidGetNativelyDefinedChannelAsync(ctx) {
    var _a;
    const manifestPath = await config_plugins_1.AndroidConfig.Paths.getAndroidManifestAsync(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(manifestPath))) {
        return null;
    }
    const androidManifest = await config_plugins_1.AndroidConfig.Manifest.readAndroidManifestAsync(manifestPath);
    const stringifiedUpdatesRequestHeaders = config_plugins_1.AndroidConfig.Manifest.getMainApplicationMetaDataValue(androidManifest, AndroidMetadataName.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY);
    try {
        const updatesRequestHeaders = JSON.parse(stringifiedUpdatesRequestHeaders !== null && stringifiedUpdatesRequestHeaders !== void 0 ? stringifiedUpdatesRequestHeaders : '{}');
        return (_a = updatesRequestHeaders['expo-channel-name']) !== null && _a !== void 0 ? _a : null;
    }
    catch (err) {
        throw new Error(`Failed to parse ${AndroidMetadataName.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY} from AndroidManifest.xml: ${err.message}`);
    }
}
exports.androidGetNativelyDefinedChannelAsync = androidGetNativelyDefinedChannelAsync;
async function androidSetClassicReleaseChannelNativelyAsync(ctx) {
    const { releaseChannel } = ctx.job;
    (0, assert_1.default)(releaseChannel, 'releaseChannel must be defined');
    const escapedReleaseChannel = config_plugins_1.XML.escapeAndroidString(releaseChannel);
    const manifestPath = await config_plugins_1.AndroidConfig.Paths.getAndroidManifestAsync(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(manifestPath))) {
        throw new Error(`Couldn't find Android manifest at ${manifestPath}`);
    }
    // Store the release channel in a string resource to ensure it is interpreted as a string
    const stringResourcePath = await config_plugins_1.AndroidConfig.Strings.getProjectStringsXMLPathAsync(ctx.reactNativeProjectDirectory);
    const stringResourceObject = await config_plugins_1.AndroidConfig.Resources.readResourcesXMLAsync({
        path: stringResourcePath,
    });
    const resourceName = 'release_channel';
    const releaseChannelResourceItem = config_plugins_1.AndroidConfig.Resources.buildResourceItem({
        name: resourceName,
        value: escapedReleaseChannel,
    });
    const newStringResourceObject = config_plugins_1.AndroidConfig.Strings.setStringItem([releaseChannelResourceItem], stringResourceObject);
    await config_plugins_1.XML.writeXMLAsync({ path: stringResourcePath, xml: newStringResourceObject });
    const androidManifest = await config_plugins_1.AndroidConfig.Manifest.readAndroidManifestAsync(manifestPath);
    const mainApp = config_plugins_1.AndroidConfig.Manifest.getMainApplicationOrThrow(androidManifest);
    config_plugins_1.AndroidConfig.Manifest.addMetaDataItemToMainApplication(mainApp, AndroidMetadataName.RELEASE_CHANNEL, `@string/${resourceName}`, 'value');
    await config_plugins_1.AndroidConfig.Manifest.writeAndroidManifestAsync(manifestPath, androidManifest);
}
exports.androidSetClassicReleaseChannelNativelyAsync = androidSetClassicReleaseChannelNativelyAsync;
async function androidGetNativelyDefinedClassicReleaseChannelAsync(ctx) {
    const manifestPath = await config_plugins_1.AndroidConfig.Paths.getAndroidManifestAsync(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(manifestPath))) {
        return null;
    }
    const androidManifest = await config_plugins_1.AndroidConfig.Manifest.readAndroidManifestAsync(manifestPath);
    return config_plugins_1.AndroidConfig.Manifest.getMainApplicationMetaDataValue(androidManifest, AndroidMetadataName.RELEASE_CHANNEL);
}
exports.androidGetNativelyDefinedClassicReleaseChannelAsync = androidGetNativelyDefinedClassicReleaseChannelAsync;
async function androidGetNativelyDefinedRuntimeVersionAsync(ctx) {
    const manifestPath = await config_plugins_1.AndroidConfig.Paths.getAndroidManifestAsync(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(manifestPath))) {
        return null;
    }
    const androidManifest = await config_plugins_1.AndroidConfig.Manifest.readAndroidManifestAsync(manifestPath);
    return config_plugins_1.AndroidConfig.Manifest.getMainApplicationMetaDataValue(androidManifest, AndroidMetadataName.RUNTIME_VERSION);
}
exports.androidGetNativelyDefinedRuntimeVersionAsync = androidGetNativelyDefinedRuntimeVersionAsync;
//# sourceMappingURL=expoUpdates.js.map