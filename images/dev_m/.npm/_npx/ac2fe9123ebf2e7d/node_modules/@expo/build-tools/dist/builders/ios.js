"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const plist_1 = __importDefault(require("@expo/plist"));
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const fs_extra_1 = __importDefault(require("fs-extra"));
const nullthrows_1 = __importDefault(require("nullthrows"));
const context_1 = require("../context");
const expoUpdates_1 = require("../utils/expoUpdates");
const artifacts_1 = require("../utils/artifacts");
const hooks_1 = require("../utils/hooks");
const configure_1 = require("../ios/configure");
const manager_1 = __importDefault(require("../ios/credentials/manager"));
const fastlane_1 = require("../ios/fastlane");
const pod_1 = require("../ios/pod");
const resign_1 = require("../ios/resign");
const resolve_1 = require("../ios/resolve");
const setup_1 = require("../common/setup");
const prebuild_1 = require("../common/prebuild");
const common_1 = require("./common");
async function iosBuilder(ctx) {
    if (ctx.job.mode === eas_build_job_1.BuildMode.BUILD) {
        return await (0, common_1.runBuilderWithHooksAsync)(ctx, buildAsync);
    }
    else {
        return await resignAsync(ctx);
    }
}
exports.default = iosBuilder;
async function buildAsync(ctx) {
    await (0, setup_1.setupAsync)(ctx);
    const hasNativeCode = ctx.job.type === eas_build_job_1.Workflow.GENERIC;
    const credentialsManager = new manager_1.default(ctx);
    try {
        const credentials = await ctx.runBuildPhase(eas_build_job_1.BuildPhase.PREPARE_CREDENTIALS, async () => {
            return await credentialsManager.prepare();
        });
        await ctx.runBuildPhase(eas_build_job_1.BuildPhase.PREBUILD, async () => {
            if (hasNativeCode) {
                ctx.markBuildPhaseSkipped();
                ctx.logger.info('Skipped running "expo prebuild" because the "ios" directory already exists. Learn more about the build process: https://docs.expo.dev/build-reference/ios-builds/');
                return;
            }
            const extraEnvs = (credentials === null || credentials === void 0 ? void 0 : credentials.teamId)
                ? { APPLE_TEAM_ID: credentials.teamId }
                : {};
            await (0, prebuild_1.prebuildAsync)(ctx, { extraEnvs });
        });
        await ctx.runBuildPhase(eas_build_job_1.BuildPhase.RESTORE_CACHE, async () => {
            var _a;
            await ((_a = ctx.cacheManager) === null || _a === void 0 ? void 0 : _a.restoreCache(ctx));
        });
        await ctx.runBuildPhase(eas_build_job_1.BuildPhase.INSTALL_PODS, async () => {
            await (0, pod_1.installPods)(ctx);
        });
        await ctx.runBuildPhase(eas_build_job_1.BuildPhase.POST_INSTALL_HOOK, async () => {
            await (0, hooks_1.runHookIfPresent)(ctx, hooks_1.Hook.POST_INSTALL);
        });
        const buildConfiguration = (0, resolve_1.resolveBuildConfiguration)(ctx);
        if (credentials) {
            await ctx.runBuildPhase(eas_build_job_1.BuildPhase.CONFIGURE_XCODE_PROJECT, async () => {
                await (0, configure_1.configureXcodeProject)(ctx, { credentials, buildConfiguration });
            });
        }
        await ctx.runBuildPhase(eas_build_job_1.BuildPhase.CONFIGURE_EXPO_UPDATES, async () => {
            await (0, expoUpdates_1.configureExpoUpdatesIfInstalledAsync)(ctx);
        });
        await ctx.runBuildPhase(eas_build_job_1.BuildPhase.RUN_FASTLANE, async () => {
            const scheme = (0, resolve_1.resolveScheme)(ctx);
            const entitlements = await readEntitlementsAsync(ctx, { scheme, buildConfiguration });
            await (0, fastlane_1.runFastlaneGym)(ctx, {
                credentials,
                scheme,
                buildConfiguration,
                entitlements,
            });
        });
    }
    finally {
        await ctx.runBuildPhase(eas_build_job_1.BuildPhase.CLEAN_UP_CREDENTIALS, async () => {
            await credentialsManager.cleanUp();
        });
    }
    await ctx.runBuildPhase(eas_build_job_1.BuildPhase.PRE_UPLOAD_ARTIFACTS_HOOK, async () => {
        await (0, hooks_1.runHookIfPresent)(ctx, hooks_1.Hook.PRE_UPLOAD_ARTIFACTS);
    });
    await ctx.runBuildPhase(eas_build_job_1.BuildPhase.SAVE_CACHE, async () => {
        var _a;
        await ((_a = ctx.cacheManager) === null || _a === void 0 ? void 0 : _a.saveCache(ctx));
    });
    await ctx.runBuildPhase(eas_build_job_1.BuildPhase.UPLOAD_APPLICATION_ARCHIVE, async () => {
        const applicationArchives = await (0, artifacts_1.findArtifacts)(ctx.reactNativeProjectDirectory, (0, resolve_1.resolveArtifactPath)(ctx), ctx.logger);
        ctx.logger.info(`Application archives: ${applicationArchives.join(', ')}`);
        await ctx.uploadArtifacts(context_1.ArtifactType.APPLICATION_ARCHIVE, applicationArchives, ctx.logger);
    });
}
async function readEntitlementsAsync(ctx, { scheme, buildConfiguration }) {
    try {
        const applicationTargetName = await config_plugins_1.IOSConfig.BuildScheme.getApplicationTargetNameForSchemeAsync(ctx.reactNativeProjectDirectory, scheme);
        const entitlementsPath = config_plugins_1.IOSConfig.Entitlements.getEntitlementsPath(ctx.reactNativeProjectDirectory, {
            buildConfiguration,
            targetName: applicationTargetName,
        });
        if (!entitlementsPath) {
            return null;
        }
        const entitlementsRaw = await fs_extra_1.default.readFile(entitlementsPath, 'utf8');
        return plist_1.default.parse(entitlementsRaw);
    }
    catch (err) {
        ctx.logger.warn({ err }, 'Failed to read entitlements');
        ctx.markBuildPhaseHasWarnings();
        return null;
    }
}
async function resignAsync(ctx) {
    const applicationArchivePath = await ctx.runBuildPhase(eas_build_job_1.BuildPhase.DOWNLOAD_APPLICATION_ARCHIVE, async () => {
        return await (0, resign_1.downloadApplicationArchiveAsync)(ctx);
    });
    const credentialsManager = new manager_1.default(ctx);
    try {
        const credentials = await ctx.runBuildPhase(eas_build_job_1.BuildPhase.PREPARE_CREDENTIALS, async () => {
            return await credentialsManager.prepare();
        });
        await ctx.runBuildPhase(eas_build_job_1.BuildPhase.RUN_FASTLANE, async () => {
            await (0, fastlane_1.runFastlaneResign)(ctx, {
                credentials: (0, nullthrows_1.default)(credentials),
                ipaPath: applicationArchivePath,
            });
        });
    }
    finally {
        await ctx.runBuildPhase(eas_build_job_1.BuildPhase.CLEAN_UP_CREDENTIALS, async () => {
            await credentialsManager.cleanUp();
        });
    }
    await ctx.runBuildPhase(eas_build_job_1.BuildPhase.UPLOAD_APPLICATION_ARCHIVE, async () => {
        ctx.logger.info(`Application archive: ${applicationArchivePath}`);
        await ctx.uploadArtifacts(context_1.ArtifactType.APPLICATION_ARCHIVE, [applicationArchivePath], ctx.logger);
    });
    if (!ctx.artifacts.APPLICATION_ARCHIVE) {
        throw new Error('Builder must upload application archive');
    }
    return ctx.artifacts;
}
//# sourceMappingURL=ios.js.map