"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadApplicationArchiveAsync = void 0;
const assert_1 = __importDefault(require("assert"));
const path_1 = __importDefault(require("path"));
const downloader_1 = __importDefault(require("@expo/downloader"));
const eas_build_job_1 = require("@expo/eas-build-job");
async function downloadApplicationArchiveAsync(ctx) {
    var _a;
    (0, assert_1.default)(ctx.job.resign);
    const applicationArchivePath = path_1.default.join(ctx.workingdir, 'application.ipa');
    const { applicationArchiveSource } = ctx.job.resign;
    if (applicationArchiveSource.type === eas_build_job_1.ArchiveSourceType.URL) {
        try {
            await (0, downloader_1.default)(applicationArchiveSource.url, applicationArchivePath, { retry: 3 });
        }
        catch (err) {
            (_a = ctx.reportError) === null || _a === void 0 ? void 0 : _a.call(ctx, 'Failed to download the application archive', err, {
                extras: { buildId: ctx.env.EAS_BUILD_ID },
            });
            throw err;
        }
    }
    else {
        throw new Error('Only application archive URLs are supported');
    }
    return applicationArchivePath;
}
exports.downloadApplicationArchiveAsync = downloadApplicationArchiveAsync;
//# sourceMappingURL=resign.js.map