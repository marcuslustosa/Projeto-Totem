"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildContext = exports.SkipNativeBuildError = exports.ArtifactType = void 0;
const path_1 = __importDefault(require("path"));
const eas_build_job_1 = require("@expo/eas-build-job");
const common_1 = require("@expo/eas-build-job/dist/common");
const packageManager_1 = require("./utils/packageManager");
const detectError_1 = require("./buildErrors/detectError");
const appConfig_1 = require("./utils/appConfig");
const environmentSecrets_1 = require("./utils/environmentSecrets");
var ArtifactType;
(function (ArtifactType) {
    ArtifactType["APPLICATION_ARCHIVE"] = "APPLICATION_ARCHIVE";
    ArtifactType["BUILD_ARTIFACTS"] = "BUILD_ARTIFACTS";
    /**
     * @deprecated
     */
    ArtifactType["XCODE_BUILD_LOGS"] = "XCODE_BUILD_LOGS";
})(ArtifactType = exports.ArtifactType || (exports.ArtifactType = {}));
class SkipNativeBuildError extends Error {
}
exports.SkipNativeBuildError = SkipNativeBuildError;
class BuildContext {
    constructor(job, options) {
        var _a;
        this.artifacts = {};
        this.buildPhaseSkipped = false;
        this.buildPhaseHasWarnings = false;
        this.workingdir = options.workingdir;
        this.defaultLogger = options.logger;
        this.logger = this.defaultLogger;
        this.logBuffer = options.logBuffer;
        this.cacheManager = options.cacheManager;
        this.runGlobalExpoCliCommand = options.runGlobalExpoCliCommand;
        this._uploadArtifacts = options.uploadArtifacts;
        this.reportError = options.reportError;
        this._job = job;
        this._metadata = options.metadata;
        this.skipNativeBuild = options.skipNativeBuild;
        this.reportBuildPhaseStats = options.reportBuildPhaseStats;
        const environmentSecrets = this.getEnvironmentSecrets(job);
        this._env = Object.assign(Object.assign(Object.assign({}, options.env), (_a = job === null || job === void 0 ? void 0 : job.builderEnvironment) === null || _a === void 0 ? void 0 : _a.env), environmentSecrets);
    }
    get job() {
        return this._job;
    }
    get metadata() {
        return this._metadata;
    }
    get env() {
        return this._env;
    }
    get buildDirectory() {
        return path_1.default.join(this.workingdir, 'build');
    }
    get buildLogsDirectory() {
        return path_1.default.join(this.workingdir, 'logs');
    }
    get environmentSecrectsDirectory() {
        return path_1.default.join(this.workingdir, 'environment-secrets');
    }
    get reactNativeProjectDirectory() {
        var _a;
        return path_1.default.join(this.buildDirectory, (_a = this.job.projectRootDirectory) !== null && _a !== void 0 ? _a : '.');
    }
    get packageManager() {
        return (0, packageManager_1.resolvePackageManager)(this.reactNativeProjectDirectory);
    }
    get appConfig() {
        if (!this._appConfig) {
            this._appConfig = (0, appConfig_1.readAppConfig)(this.reactNativeProjectDirectory, this.env, this.logger).exp;
        }
        return this._appConfig;
    }
    async runBuildPhase(buildPhase, phase, { doNotMarkStart = false, doNotMarkEnd = false, } = {}) {
        let startTimestamp = Date.now();
        try {
            this.setBuildPhase(buildPhase, { doNotMarkStart });
            startTimestamp = Date.now();
            const result = await phase();
            const durationMs = Date.now() - startTimestamp;
            const buildPhaseResult = this.buildPhaseSkipped
                ? eas_build_job_1.BuildPhaseResult.SKIPPED
                : this.buildPhaseHasWarnings
                    ? eas_build_job_1.BuildPhaseResult.WARNING
                    : eas_build_job_1.BuildPhaseResult.SUCCESS;
            this.endCurrentBuildPhase({ result: buildPhaseResult, doNotMarkEnd, durationMs });
            return result;
        }
        catch (err) {
            const durationMs = Date.now() - startTimestamp;
            const resolvedError = await this.handleBuildPhaseErrorAsync(err, buildPhase);
            this.endCurrentBuildPhase({ result: eas_build_job_1.BuildPhaseResult.FAIL, durationMs });
            throw resolvedError;
        }
    }
    markBuildPhaseSkipped() {
        this.buildPhaseSkipped = true;
    }
    markBuildPhaseHasWarnings() {
        this.buildPhaseHasWarnings = true;
    }
    async uploadArtifacts(type, paths, logger) {
        const url = await this._uploadArtifacts(type, paths, logger);
        if (url) {
            this.artifacts[type] = url;
        }
    }
    updateEnv(env) {
        if (this._job.triggeredBy !== common_1.BuildTrigger.GIT_BASED_INTEGRATION) {
            throw new Error('Updating environment variables is only allowed when build was triggered by a git-based integration.');
        }
        this._env = Object.assign(Object.assign({}, env), this._env);
    }
    updateJobInformation(job, metadata) {
        if (this._job.triggeredBy !== common_1.BuildTrigger.GIT_BASED_INTEGRATION) {
            throw new Error('Updating job information is only allowed when build was triggered by a git-based integration.');
        }
        this._job = Object.assign(Object.assign({}, job), { triggeredBy: this._job.triggeredBy });
        this._metadata = metadata;
    }
    async handleBuildPhaseErrorAsync(err, buildPhase) {
        const buildError = await (0, detectError_1.resolveBuildPhaseErrorAsync)(err, this.logBuffer.getPhaseLogs(buildPhase), {
            job: this.job,
            phase: buildPhase,
            env: this.env,
        }, this.buildLogsDirectory);
        if (buildError.errorCode === eas_build_job_1.errors.ErrorCode.UNKNOWN_ERROR) {
            // leaving message empty, website will display err.stack which already includes err.message
            this.logger.error({ err }, '');
        }
        else {
            this.logger.error(`Error: ${buildError.userFacingMessage}`);
        }
        return buildError;
    }
    setBuildPhase(buildPhase, { doNotMarkStart = false } = {}) {
        if (this.buildPhase) {
            if (this.buildPhase === buildPhase) {
                return;
            }
            else {
                this.logger.info({ marker: eas_build_job_1.LogMarker.END_PHASE, result: eas_build_job_1.BuildPhaseResult.UNKNOWN }, `End phase: ${this.buildPhase}`);
                this.logger = this.defaultLogger;
            }
        }
        this.buildPhase = buildPhase;
        this.logger = this.defaultLogger.child({ phase: buildPhase });
        if (!doNotMarkStart) {
            this.logger.info({ marker: eas_build_job_1.LogMarker.START_PHASE }, `Start phase: ${this.buildPhase}`);
        }
    }
    endCurrentBuildPhase({ result, doNotMarkEnd = false, durationMs, }) {
        var _a;
        if (!this.buildPhase) {
            return;
        }
        (_a = this.reportBuildPhaseStats) === null || _a === void 0 ? void 0 : _a.call(this, { buildPhase: this.buildPhase, result, durationMs });
        if (!doNotMarkEnd) {
            this.logger.info({ marker: eas_build_job_1.LogMarker.END_PHASE, result, durationMs }, `End phase: ${this.buildPhase}`);
        }
        this.logger = this.defaultLogger;
        this.buildPhase = undefined;
        this.buildPhaseSkipped = false;
        this.buildPhaseHasWarnings = false;
    }
    getEnvironmentSecrets(job) {
        var _a;
        if (!((_a = job === null || job === void 0 ? void 0 : job.secrets) === null || _a === void 0 ? void 0 : _a.environmentSecrets)) {
            return {};
        }
        const environmentSecrets = {};
        for (const { name, type, value } of job.secrets.environmentSecrets) {
            if (type === eas_build_job_1.EnvironmentSecretType.STRING) {
                environmentSecrets[name] = value;
            }
            else {
                environmentSecrets[name] = (0, environmentSecrets_1.createTemporaryEnvironmentSecretFile)(this.environmentSecrectsDirectory, value);
            }
        }
        return environmentSecrets;
    }
}
exports.BuildContext = BuildContext;
//# sourceMappingURL=context.js.map