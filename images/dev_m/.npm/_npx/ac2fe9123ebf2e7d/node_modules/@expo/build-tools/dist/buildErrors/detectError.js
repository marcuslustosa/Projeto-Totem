"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveBuildPhaseErrorAsync = void 0;
const eas_build_job_1 = require("@expo/eas-build-job");
const fs_extra_1 = __importDefault(require("fs-extra"));
const xcodeBuildLogs_1 = require("../ios/xcodeBuildLogs");
const errors_types_1 = require("./errors.types");
const userErrorHandlers_1 = require("./userErrorHandlers");
const buildErrorHandlers_1 = require("./buildErrorHandlers");
async function maybeReadXcodeBuildLogs(phase, buildLogsDirectory) {
    if (phase !== eas_build_job_1.BuildPhase.RUN_FASTLANE) {
        return;
    }
    try {
        const xcodeBuildLogsPath = await (0, xcodeBuildLogs_1.findXcodeBuildLogsPathAsync)(buildLogsDirectory);
        if (!xcodeBuildLogsPath) {
            return;
        }
        return await fs_extra_1.default.readFile(xcodeBuildLogsPath, 'utf-8');
    }
    catch (err) {
        return undefined;
    }
}
function resolveError(errorHandlers, logLines, errorContext, xcodeBuildLogs) {
    const { job, phase } = errorContext;
    const { platform } = job;
    const logs = logLines.join('\n');
    const handlers = errorHandlers
        .filter((handler) => handler.platform === platform || !handler.platform)
        .filter((handler) => (handler.phase === errors_types_1.XCODE_BUILD_PHASE && phase === eas_build_job_1.BuildPhase.RUN_FASTLANE) ||
        handler.phase === phase ||
        !handler.phase);
    for (const handler of handlers) {
        const regexp = typeof handler.regexp === 'function' ? handler.regexp(errorContext) : handler.regexp;
        if (!regexp) {
            continue;
        }
        const match = handler.phase === errors_types_1.XCODE_BUILD_PHASE ? xcodeBuildLogs === null || xcodeBuildLogs === void 0 ? void 0 : xcodeBuildLogs.match(regexp) : logs.match(regexp);
        if (match) {
            return handler.createError(match, errorContext);
        }
    }
    return undefined;
}
async function resolveBuildPhaseErrorAsync(error, logLines, errorContext, buildLogsDirectory) {
    var _a, _b, _c;
    const { phase } = errorContext;
    if (error instanceof eas_build_job_1.errors.BuildError) {
        return error;
    }
    const xcodeBuildLogs = await maybeReadXcodeBuildLogs(phase, buildLogsDirectory);
    const userFacingError = error instanceof eas_build_job_1.errors.UserFacingError
        ? error
        : (_a = resolveError(userErrorHandlers_1.userErrorHandlers, logLines, errorContext, xcodeBuildLogs)) !== null && _a !== void 0 ? _a : new eas_build_job_1.errors.UnknownError();
    const buildError = resolveError(buildErrorHandlers_1.buildErrorHandlers, logLines, errorContext, xcodeBuildLogs);
    const isUnknownUserError = !userFacingError ||
        [
            eas_build_job_1.errors.ErrorCode.UNKNOWN_ERROR,
            eas_build_job_1.errors.ErrorCode.UNKNOWN_GRADLE_ERROR,
            eas_build_job_1.errors.ErrorCode.UNKNOWN_FASTLANE_ERROR,
        ].includes(userFacingError.errorCode);
    const message = (_b = (isUnknownUserError ? buildError === null || buildError === void 0 ? void 0 : buildError.message : userFacingError.message)) !== null && _b !== void 0 ? _b : userFacingError.message;
    const errorCode = (_c = (isUnknownUserError ? buildError === null || buildError === void 0 ? void 0 : buildError.errorCode : userFacingError.errorCode)) !== null && _c !== void 0 ? _c : userFacingError.errorCode;
    return new eas_build_job_1.errors.BuildError(message, {
        errorCode,
        userFacingErrorCode: userFacingError.errorCode,
        userFacingMessage: userFacingError.message,
        docsUrl: userFacingError.docsUrl,
        innerError: error,
        buildPhase: phase,
    });
}
exports.resolveBuildPhaseErrorAsync = resolveBuildPhaseErrorAsync;
//# sourceMappingURL=detectError.js.map