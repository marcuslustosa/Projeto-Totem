{"version":3,"file":"projectSources.js","sourceRoot":"","sources":["../../src/common/projectSources.ts"],"names":[],"mappings":"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","sourcesContent":["import path from 'path';\n\nimport spawn from '@expo/turtle-spawn';\nimport fs from 'fs-extra';\nimport { ArchiveSourceType, Job } from '@expo/eas-build-job';\nimport { bunyan } from '@expo/logger';\nimport downloadFile from '@expo/downloader';\n\nimport { BuildContext } from '../context';\n\nexport async function prepareProjectSourcesAsync<TJob extends Job>(\n  ctx: BuildContext<TJob>\n): Promise<void> {\n  if ([ArchiveSourceType.S3, ArchiveSourceType.GCS].includes(ctx.job.projectArchive.type)) {\n    throw new Error('GCS and S3 project sources should be resolved earlier to url');\n  } else if (ctx.job.projectArchive.type === ArchiveSourceType.PATH) {\n    await prepareProjectSourcesLocallyAsync(ctx, ctx.job.projectArchive.path); // used in eas build --local\n  } else if (ctx.job.projectArchive.type === ArchiveSourceType.URL) {\n    await downloadAndUnpackProjectFromTarGzAsync(ctx, ctx.job.projectArchive.url);\n  } else if (ctx.job.projectArchive.type === ArchiveSourceType.GIT) {\n    await shallowCloneRepositoryAsync(\n      ctx,\n      ctx.job.projectArchive.repositoryUrl,\n      ctx.job.projectArchive.gitRef\n    );\n  }\n}\n\nasync function shallowCloneRepositoryAsync<TJob extends Job>(\n  ctx: BuildContext<TJob>,\n  projectRepoUrl: string,\n  gitRef: string\n): Promise<void> {\n  try {\n    await spawn('git', ['init'], { cwd: ctx.buildDirectory });\n    await spawn('git', ['remote', 'add', 'origin', projectRepoUrl], { cwd: ctx.buildDirectory });\n    await spawn('git', ['fetch', 'origin', '--depth', '1', gitRef], { cwd: ctx.buildDirectory });\n    await spawn('git', ['checkout', gitRef], { cwd: ctx.buildDirectory });\n  } catch (err: any) {\n    const sanitizedUrl = getSanitizedGitUrl(projectRepoUrl);\n    if (sanitizedUrl) {\n      ctx.logger.error(`Failed to clone git repository: ${sanitizedUrl}.`);\n    } else {\n      ctx.logger.error('Failed to clone git repository.');\n    }\n    ctx.logger.error(err.stderr);\n    throw err;\n  }\n}\n\nfunction getSanitizedGitUrl(maybeGitUrl: string): string | null {\n  try {\n    const url = new URL(maybeGitUrl);\n    if (url.password) {\n      url.password = '*******';\n    }\n    return url.toString();\n  } catch {\n    return null;\n  }\n}\n\nexport async function downloadAndUnpackProjectFromTarGzAsync<TJob extends Job>(\n  ctx: BuildContext<TJob>,\n  projectArchiveUrl: string\n): Promise<void> {\n  const projectTarball = path.join(ctx.workingdir, 'project.tar.gz');\n  try {\n    await downloadFile(projectArchiveUrl, projectTarball, { retry: 3 });\n  } catch (err: any) {\n    ctx.reportError?.('Failed to download project archive', err, {\n      extras: { buildId: ctx.env.EAS_BUILD_ID },\n    });\n    throw err;\n  }\n\n  await unpackTarGzAsync({\n    destination: ctx.buildDirectory,\n    source: projectTarball,\n    logger: ctx.logger,\n  });\n}\n\nasync function prepareProjectSourcesLocallyAsync<TJob extends Job>(\n  ctx: BuildContext<TJob>,\n  projectArchivePath: string\n): Promise<void> {\n  const projectTarball = path.join(ctx.workingdir, 'project.tar.gz');\n  await fs.copy(projectArchivePath, projectTarball);\n\n  await unpackTarGzAsync({\n    destination: ctx.buildDirectory,\n    source: projectTarball,\n    logger: ctx.logger,\n  });\n}\n\nasync function unpackTarGzAsync({\n  logger,\n  source,\n  destination,\n}: {\n  logger: bunyan;\n  source: string;\n  destination: string;\n}): Promise<void> {\n  await spawn('tar', ['-C', destination, '--strip-components', '1', '-zxf', source], {\n    logger,\n  });\n}\n"]}