"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.configureXcodeProject = exports.evaluateTemplateString = void 0;
const path_1 = __importDefault(require("path"));
const config_plugins_1 = require("@expo/config-plugins");
const uniq_1 = __importDefault(require("lodash/uniq"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const plist_1 = __importDefault(require("@expo/plist"));
async function configureXcodeProject(ctx, { credentials, buildConfiguration, }) {
    ctx.logger.info('Configuring Xcode project');
    await configureCredentialsAsync(ctx, {
        credentials,
        buildConfiguration,
    });
    const { version } = ctx.job;
    if ((version === null || version === void 0 ? void 0 : version.appVersion) || (version === null || version === void 0 ? void 0 : version.buildNumber)) {
        await updateVersionsAsync(ctx, {
            targetNames: Object.keys(credentials.targetProvisioningProfiles),
            buildConfiguration,
        });
    }
}
exports.configureXcodeProject = configureXcodeProject;
async function configureCredentialsAsync(ctx, { credentials, buildConfiguration, }) {
    const targetNames = Object.keys(credentials.targetProvisioningProfiles);
    for (const targetName of targetNames) {
        const profile = credentials.targetProvisioningProfiles[targetName];
        ctx.logger.info(`Assigning provisioning profile '${profile.name}' (Apple Team ID: ${profile.teamId}) to target '${targetName}'`);
        config_plugins_1.IOSConfig.ProvisioningProfile.setProvisioningProfileForPbxproj(ctx.reactNativeProjectDirectory, {
            targetName,
            profileName: profile.name,
            appleTeamId: profile.teamId,
            buildConfiguration,
        });
    }
}
async function updateVersionsAsync(ctx, { targetNames, buildConfiguration, }) {
    var _a, _b, _c, _d;
    const project = config_plugins_1.IOSConfig.XcodeUtils.getPbxproj(ctx.reactNativeProjectDirectory);
    const iosDir = path_1.default.join(ctx.reactNativeProjectDirectory, 'ios');
    const infoPlistPaths = [];
    for (const targetName of targetNames) {
        const xcBuildConfiguration = config_plugins_1.IOSConfig.Target.getXCBuildConfigurationFromPbxproj(project, {
            targetName,
            buildConfiguration,
        });
        const infoPlist = xcBuildConfiguration.buildSettings.INFOPLIST_FILE;
        if (infoPlist) {
            const evaluatedInfoPlistPath = trimQuotes(evaluateTemplateString(infoPlist, {
                SRCROOT: iosDir,
            }));
            const absolutePath = path_1.default.isAbsolute(evaluatedInfoPlistPath)
                ? evaluatedInfoPlistPath
                : path_1.default.join(iosDir, evaluatedInfoPlistPath);
            infoPlistPaths.push(path_1.default.normalize(absolutePath));
        }
    }
    const uniqueInfoPlistPaths = (0, uniq_1.default)(infoPlistPaths);
    for (const infoPlistPath of uniqueInfoPlistPaths) {
        ctx.logger.info(`Updating versions in ${infoPlistPath}`);
        const infoPlistRaw = await fs_extra_1.default.readFile(infoPlistPath, 'utf-8');
        const infoPlist = plist_1.default.parse(infoPlistRaw);
        if ((_a = ctx.job.version) === null || _a === void 0 ? void 0 : _a.buildNumber) {
            infoPlist.CFBundleVersion = (_b = ctx.job.version) === null || _b === void 0 ? void 0 : _b.buildNumber;
        }
        if ((_c = ctx.job.version) === null || _c === void 0 ? void 0 : _c.appVersion) {
            infoPlist.CFBundleShortVersionString = (_d = ctx.job.version) === null || _d === void 0 ? void 0 : _d.appVersion;
        }
        await fs_extra_1.default.writeFile(infoPlistPath, plist_1.default.build(infoPlist));
    }
}
function trimQuotes(s) {
    return (s === null || s === void 0 ? void 0 : s.startsWith('"')) && s.endsWith('"') ? s.slice(1, -1) : s;
}
function evaluateTemplateString(s, buildSettings) {
    // necessary because buildSettings might be XCBuildConfiguration['buildSettings'] which is not a plain object
    const vars = Object.assign({}, buildSettings);
    return s.replace(/\$\((\w+)\)/g, (match, key) => {
        if (vars.hasOwnProperty(key)) {
            const value = String(vars[key]);
            return trimQuotes(value);
        }
        else {
            return match;
        }
    });
}
exports.evaluateTemplateString = evaluateTemplateString;
//# sourceMappingURL=configure.js.map