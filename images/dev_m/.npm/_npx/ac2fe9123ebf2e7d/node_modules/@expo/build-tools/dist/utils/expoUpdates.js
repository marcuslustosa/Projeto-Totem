"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEASUpdateConfigured = exports.getRuntimeVersionAsync = exports.getChannelAsync = exports.configureExpoUpdatesIfInstalledAsync = exports.configureEASExpoUpdatesAsync = exports.configureClassicExpoUpdatesAsync = exports.getNativelyDefinedClassicReleaseChannelAsync = exports.setClassicReleaseChannelNativelyAsync = exports.setChannelNativelyAsync = exports.setRuntimeVersionNativelyAsync = void 0;
const assert_1 = __importDefault(require("assert"));
const eas_build_job_1 = require("@expo/eas-build-job");
const Updates_1 = require("@expo/config-plugins/build/utils/Updates");
const expoUpdates_1 = require("../android/expoUpdates");
const expoUpdates_2 = require("../ios/expoUpdates");
const isExpoUpdatesInstalled_1 = __importDefault(require("./isExpoUpdatesInstalled"));
async function setRuntimeVersionNativelyAsync(ctx, runtimeVersion) {
    switch (ctx.job.platform) {
        case eas_build_job_1.Platform.ANDROID: {
            await (0, expoUpdates_1.androidSetRuntimeVersionNativelyAsync)(ctx, runtimeVersion);
            return;
        }
        case eas_build_job_1.Platform.IOS: {
            await (0, expoUpdates_2.iosSetRuntimeVersionNativelyAsync)(ctx, runtimeVersion);
            return;
        }
        default:
            throw new Error(`Platform is not supported.`);
    }
}
exports.setRuntimeVersionNativelyAsync = setRuntimeVersionNativelyAsync;
/**
 * Used for when Expo Updates is pointed at an EAS server.
 */
async function setChannelNativelyAsync(ctx) {
    var _a;
    (0, assert_1.default)((_a = ctx.job.updates) === null || _a === void 0 ? void 0 : _a.channel, 'updates.channel must be defined');
    const newUpdateRequestHeaders = {
        'expo-channel-name': ctx.job.updates.channel,
    };
    const configFile = ctx.job.platform === eas_build_job_1.Platform.ANDROID ? 'AndroidManifest.xml' : 'Expo.plist';
    ctx.logger.info(`Setting the update request headers in '${configFile}' to '${JSON.stringify(newUpdateRequestHeaders)}'`);
    switch (ctx.job.platform) {
        case eas_build_job_1.Platform.ANDROID: {
            await (0, expoUpdates_1.androidSetChannelNativelyAsync)(ctx);
            return;
        }
        case eas_build_job_1.Platform.IOS: {
            await (0, expoUpdates_2.iosSetChannelNativelyAsync)(ctx);
            return;
        }
        default:
            throw new Error(`Platform is not supported.`);
    }
}
exports.setChannelNativelyAsync = setChannelNativelyAsync;
/**
 * Used for classic Expo Updates
 */
async function setClassicReleaseChannelNativelyAsync(ctx) {
    (0, assert_1.default)(ctx.job.releaseChannel, 'releaseChannel must be defined');
    const configFile = ctx.job.platform === eas_build_job_1.Platform.ANDROID ? 'AndroidManifest.xml' : 'Expo.plist';
    ctx.logger.info(`Setting the release channel in '${configFile}' to '${ctx.job.releaseChannel}'`);
    switch (ctx.job.platform) {
        case eas_build_job_1.Platform.ANDROID: {
            await (0, expoUpdates_1.androidSetClassicReleaseChannelNativelyAsync)(ctx);
            return;
        }
        case eas_build_job_1.Platform.IOS: {
            await (0, expoUpdates_2.iosSetClassicReleaseChannelNativelyAsync)(ctx);
            return;
        }
        default:
            throw new Error(`Platform is not supported.`);
    }
}
exports.setClassicReleaseChannelNativelyAsync = setClassicReleaseChannelNativelyAsync;
/**
 * Used for classic Expo Updates
 */
async function getNativelyDefinedClassicReleaseChannelAsync(ctx) {
    switch (ctx.job.platform) {
        case eas_build_job_1.Platform.ANDROID: {
            return (0, expoUpdates_1.androidGetNativelyDefinedClassicReleaseChannelAsync)(ctx);
        }
        case eas_build_job_1.Platform.IOS: {
            return (0, expoUpdates_2.iosGetNativelyDefinedClassicReleaseChannelAsync)(ctx);
        }
        default:
            throw new Error(`Platform is not supported.`);
    }
}
exports.getNativelyDefinedClassicReleaseChannelAsync = getNativelyDefinedClassicReleaseChannelAsync;
async function configureClassicExpoUpdatesAsync(ctx) {
    if (ctx.job.releaseChannel) {
        await setClassicReleaseChannelNativelyAsync(ctx);
    }
    else {
        /**
         * If releaseChannel is not defined:
         *  1. Try to infer it from the native value.
         *  2. If it is not set, fallback to 'default'.
         */
        const releaseChannel = await getNativelyDefinedClassicReleaseChannelAsync(ctx);
        if (releaseChannel) {
            ctx.logger.info(`Using the release channel pre-configured in native project (${releaseChannel})`);
            ctx.logger.warn('Please add the "releaseChannel" field to your build profile (eas.json)');
        }
        else {
            ctx.logger.info(`Using default release channel for 'expo-updates' (default)`);
        }
    }
}
exports.configureClassicExpoUpdatesAsync = configureClassicExpoUpdatesAsync;
async function configureEASExpoUpdatesAsync(ctx) {
    await setChannelNativelyAsync(ctx);
}
exports.configureEASExpoUpdatesAsync = configureEASExpoUpdatesAsync;
async function configureExpoUpdatesIfInstalledAsync(ctx) {
    var _a, _b, _c, _d, _e, _f;
    if (!(await (0, isExpoUpdatesInstalled_1.default)(ctx.reactNativeProjectDirectory))) {
        return;
    }
    const appConfigRuntimeVersion = (_b = (_a = ctx.job.version) === null || _a === void 0 ? void 0 : _a.runtimeVersion) !== null && _b !== void 0 ? _b : (0, Updates_1.getRuntimeVersionNullable)(ctx.appConfig, ctx.job.platform);
    if (((_c = ctx.metadata) === null || _c === void 0 ? void 0 : _c.runtimeVersion) && ((_d = ctx.metadata) === null || _d === void 0 ? void 0 : _d.runtimeVersion) !== appConfigRuntimeVersion) {
        ctx.markBuildPhaseHasWarnings();
        ctx.logger.warn(`Runtime version from the app config evaluated on your local machine (${ctx.metadata.runtimeVersion}) does not match the one resolved here (${appConfigRuntimeVersion}).`);
        ctx.logger.warn("If you're using conditional app configs, e.g. depending on an environment variable, make sure to set the variable in eas.json or configure it with EAS Secret.");
    }
    if (isEASUpdateConfigured(ctx)) {
        if (((_e = ctx.job.updates) === null || _e === void 0 ? void 0 : _e.channel) !== undefined) {
            await configureEASExpoUpdatesAsync(ctx);
        }
        else {
            const channel = await getChannelAsync(ctx);
            if (channel !== null) {
                const configFile = ctx.job.platform === eas_build_job_1.Platform.ANDROID ? 'AndroidManifest.xml' : 'Expo.plist';
                ctx.logger.info(`The channel name for EAS Update in ${configFile} is set to "${channel}"`);
            }
            else {
                if (ctx.job.releaseChannel !== undefined) {
                    ctx.logger.warn(`This build is configured with EAS Update however has a Classic Updates releaseChannel set instead of having an EAS Update channel.`);
                }
                else {
                    ctx.logger.warn(`This build is configured to query EAS Update for updates, however no channel is set in eas.json.`);
                }
                ctx.markBuildPhaseHasWarnings();
            }
        }
    }
    else {
        await configureClassicExpoUpdatesAsync(ctx);
    }
    if ((_f = ctx.job.version) === null || _f === void 0 ? void 0 : _f.runtimeVersion) {
        ctx.logger.info('Updating runtimeVersion in Expo.plist');
        await setRuntimeVersionNativelyAsync(ctx, ctx.job.version.runtimeVersion);
    }
}
exports.configureExpoUpdatesIfInstalledAsync = configureExpoUpdatesIfInstalledAsync;
async function getChannelAsync(ctx) {
    switch (ctx.job.platform) {
        case eas_build_job_1.Platform.ANDROID: {
            return await (0, expoUpdates_1.androidGetNativelyDefinedChannelAsync)(ctx);
        }
        case eas_build_job_1.Platform.IOS: {
            return await (0, expoUpdates_2.iosGetNativelyDefinedChannelAsync)(ctx);
        }
        default:
            throw new Error(`Platform is not supported.`);
    }
}
exports.getChannelAsync = getChannelAsync;
async function getRuntimeVersionAsync(ctx) {
    switch (ctx.job.platform) {
        case eas_build_job_1.Platform.ANDROID: {
            return await (0, expoUpdates_1.androidGetNativelyDefinedRuntimeVersionAsync)(ctx);
        }
        case eas_build_job_1.Platform.IOS: {
            return await (0, expoUpdates_2.iosGetNativelyDefinedRuntimeVersionAsync)(ctx);
        }
        default:
            throw new Error(`Platform is not supported.`);
    }
}
exports.getRuntimeVersionAsync = getRuntimeVersionAsync;
function isEASUpdateConfigured(ctx) {
    var _a;
    const rawUrl = (_a = ctx.appConfig.updates) === null || _a === void 0 ? void 0 : _a.url;
    if (!rawUrl) {
        return false;
    }
    try {
        const url = new URL(rawUrl);
        return ['u.expo.dev', 'staging-u.expo.dev'].includes(url.hostname);
    }
    catch (err) {
        ctx.logger.error({ err }, `Cannot parse expo.updates.url = ${rawUrl} as URL`);
        ctx.logger.error(`Assuming EAS Update is not configured`);
        return false;
    }
}
exports.isEASUpdateConfigured = isEASUpdateConfigured;
//# sourceMappingURL=expoUpdates.js.map