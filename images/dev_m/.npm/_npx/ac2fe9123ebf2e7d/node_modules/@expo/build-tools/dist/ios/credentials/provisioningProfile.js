"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DistributionType = void 0;
const crypto_1 = __importDefault(require("crypto"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const eas_build_job_1 = require("@expo/eas-build-job");
const turtle_spawn_1 = __importDefault(require("@expo/turtle-spawn"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const plist_1 = __importDefault(require("plist"));
const uuid_1 = require("uuid");
var DistributionType;
(function (DistributionType) {
    DistributionType["AD_HOC"] = "ad-hoc";
    DistributionType["APP_STORE"] = "app-store";
    DistributionType["ENTERPRISE"] = "enterprise";
})(DistributionType = exports.DistributionType || (exports.DistributionType = {}));
const PROVISIONING_PROFILES_DIRECTORY = path_1.default.join(os_1.default.homedir(), 'Library/MobileDevice/Provisioning Profiles');
class ProvisioningProfile {
    constructor(ctx, profile, keychainPath, target, certificateCommonName) {
        this.ctx = ctx;
        this.profile = profile;
        this.keychainPath = keychainPath;
        this.target = target;
        this.certificateCommonName = certificateCommonName;
        this.profilePath = path_1.default.join(PROVISIONING_PROFILES_DIRECTORY, `${(0, uuid_1.v4)()}.mobileprovision`);
    }
    get data() {
        if (!this.profileData) {
            throw new Error('You must init the profile first!');
        }
        else {
            return this.profileData;
        }
    }
    async init() {
        this.ctx.logger.debug(`Making sure ${PROVISIONING_PROFILES_DIRECTORY} exits`);
        await fs_extra_1.default.ensureDir(PROVISIONING_PROFILES_DIRECTORY);
        this.ctx.logger.debug(`Writing provisioning profile to ${this.profilePath}`);
        await fs_extra_1.default.writeFile(this.profilePath, this.profile);
        this.ctx.logger.debug('Loading provisioning profile');
        await this.load();
    }
    async destroy() {
        if (!this.profilePath) {
            this.ctx.logger.warn("There is nothing to destroy, a provisioning profile hasn't been created yet.");
            return;
        }
        this.ctx.logger.info('Removing provisioning profile');
        await fs_extra_1.default.remove(this.profilePath);
    }
    verifyCertificate(fingerprint) {
        const devCertFingerprint = this.genDerCertFingerprint();
        if (devCertFingerprint !== fingerprint) {
            throw new eas_build_job_1.errors.CredentialsDistCertMismatchError(`Provisioning profile and distribution certificate don't match.
Profile's certificate fingerprint = ${devCertFingerprint}, distribution certificate fingerprint = ${fingerprint}`);
        }
    }
    async load() {
        let result;
        try {
            result = await (0, turtle_spawn_1.default)('security', ['cms', '-D', '-k', this.keychainPath, '-i', this.profilePath], {
                stdio: 'pipe',
            });
        }
        catch (err) {
            throw new Error(err.stderr.trim());
        }
        const { output } = result;
        const plistRaw = output.join('');
        let plistData;
        try {
            plistData = plist_1.default.parse(plistRaw);
        }
        catch (error) {
            throw new Error(`Error when parsing plist: ${error.message}`);
        }
        const applicationIdentifier = plistData.Entitlements['application-identifier'];
        const bundleIdentifier = applicationIdentifier.replace(/^.+?\./, '');
        this.profileData = {
            path: this.profilePath,
            target: this.target,
            bundleIdentifier,
            teamId: plistData.TeamIdentifier[0],
            uuid: plistData.UUID,
            name: plistData.Name,
            developerCertificate: Buffer.from(plistData.DeveloperCertificates[0], 'base64'),
            certificateCommonName: this.certificateCommonName,
            distributionType: this.resolveDistributionType(plistData),
        };
    }
    resolveDistributionType(plistData) {
        if (plistData.ProvisionsAllDevices) {
            return DistributionType.ENTERPRISE;
        }
        else if (plistData.ProvisionedDevices) {
            return DistributionType.AD_HOC;
        }
        else {
            return DistributionType.APP_STORE;
        }
    }
    genDerCertFingerprint() {
        return crypto_1.default
            .createHash('sha1')
            .update(this.data.developerCertificate)
            .digest('hex')
            .toUpperCase();
    }
}
exports.default = ProvisioningProfile;
//# sourceMappingURL=provisioningProfile.js.map