"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.iosGetNativelyDefinedRuntimeVersionAsync = exports.iosGetNativelyDefinedClassicReleaseChannelAsync = exports.iosSetClassicReleaseChannelNativelyAsync = exports.iosGetNativelyDefinedChannelAsync = exports.iosSetChannelNativelyAsync = exports.iosSetRuntimeVersionNativelyAsync = exports.IosMetadataName = void 0;
const assert_1 = __importDefault(require("assert"));
const config_plugins_1 = require("@expo/config-plugins");
const fs_extra_1 = __importDefault(require("fs-extra"));
const plist_1 = __importDefault(require("@expo/plist"));
var IosMetadataName;
(function (IosMetadataName) {
    IosMetadataName["UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY"] = "EXUpdatesRequestHeaders";
    IosMetadataName["RELEASE_CHANNEL"] = "EXUpdatesReleaseChannel";
    IosMetadataName["RUNTIME_VERSION"] = "EXUpdatesRuntimeVersion";
})(IosMetadataName = exports.IosMetadataName || (exports.IosMetadataName = {}));
async function iosSetRuntimeVersionNativelyAsync(ctx, runtimeVersion) {
    const expoPlistPath = config_plugins_1.IOSConfig.Paths.getExpoPlistPath(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(expoPlistPath))) {
        throw new Error(`${expoPlistPath} does not exist`);
    }
    const expoPlistContents = await fs_extra_1.default.readFile(expoPlistPath, 'utf8');
    const items = plist_1.default.parse(expoPlistContents);
    items[IosMetadataName.RUNTIME_VERSION] = runtimeVersion;
    const updatedExpoPlistContents = plist_1.default.build(items);
    await fs_extra_1.default.writeFile(expoPlistPath, updatedExpoPlistContents);
}
exports.iosSetRuntimeVersionNativelyAsync = iosSetRuntimeVersionNativelyAsync;
async function iosSetChannelNativelyAsync(ctx) {
    var _a, _b;
    (0, assert_1.default)((_a = ctx.job.updates) === null || _a === void 0 ? void 0 : _a.channel, 'updates.channel must be defined');
    const expoPlistPath = config_plugins_1.IOSConfig.Paths.getExpoPlistPath(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(expoPlistPath))) {
        throw new Error(`${expoPlistPath} does not exist`);
    }
    const expoPlistContents = await fs_extra_1.default.readFile(expoPlistPath, 'utf8');
    const items = plist_1.default.parse(expoPlistContents);
    items[IosMetadataName.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY] = Object.assign(Object.assign({}, ((_b = items[IosMetadataName.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY]) !== null && _b !== void 0 ? _b : {})), { 'expo-channel-name': ctx.job.updates.channel });
    const updatedExpoPlistContents = plist_1.default.build(items);
    await fs_extra_1.default.writeFile(expoPlistPath, updatedExpoPlistContents);
}
exports.iosSetChannelNativelyAsync = iosSetChannelNativelyAsync;
async function iosGetNativelyDefinedChannelAsync(ctx) {
    var _a, _b;
    const expoPlistPath = config_plugins_1.IOSConfig.Paths.getExpoPlistPath(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(expoPlistPath))) {
        return null;
    }
    const expoPlistContents = await fs_extra_1.default.readFile(expoPlistPath, 'utf8');
    try {
        const items = plist_1.default.parse(expoPlistContents);
        const updatesRequestHeaders = ((_a = items[IosMetadataName.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY]) !== null && _a !== void 0 ? _a : {});
        return (_b = updatesRequestHeaders['expo-channel-name']) !== null && _b !== void 0 ? _b : null;
    }
    catch (err) {
        throw new Error(`Failed to parse ${IosMetadataName.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY} from Expo.plist: ${err.message}`);
    }
}
exports.iosGetNativelyDefinedChannelAsync = iosGetNativelyDefinedChannelAsync;
async function iosSetClassicReleaseChannelNativelyAsync(ctx) {
    (0, assert_1.default)(ctx.job.releaseChannel, 'releaseChannel must be defined');
    const expoPlistPath = config_plugins_1.IOSConfig.Paths.getExpoPlistPath(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(expoPlistPath))) {
        throw new Error(`${expoPlistPath} does not exist`);
    }
    const expoPlistContents = await fs_extra_1.default.readFile(expoPlistPath, 'utf8');
    const items = plist_1.default.parse(expoPlistContents);
    items[IosMetadataName.RELEASE_CHANNEL] = ctx.job.releaseChannel;
    const updatedExpoPlistContents = plist_1.default.build(items);
    await fs_extra_1.default.writeFile(expoPlistPath, updatedExpoPlistContents);
}
exports.iosSetClassicReleaseChannelNativelyAsync = iosSetClassicReleaseChannelNativelyAsync;
async function iosGetNativelyDefinedClassicReleaseChannelAsync(ctx) {
    var _a;
    const expoPlistPath = config_plugins_1.IOSConfig.Paths.getExpoPlistPath(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(expoPlistPath))) {
        return null;
    }
    const expoPlistContents = await fs_extra_1.default.readFile(expoPlistPath, 'utf8');
    const parsedPlist = plist_1.default.parse(expoPlistContents);
    if (!parsedPlist) {
        return null;
    }
    return (_a = parsedPlist[IosMetadataName.RELEASE_CHANNEL]) !== null && _a !== void 0 ? _a : null;
}
exports.iosGetNativelyDefinedClassicReleaseChannelAsync = iosGetNativelyDefinedClassicReleaseChannelAsync;
async function iosGetNativelyDefinedRuntimeVersionAsync(ctx) {
    var _a;
    const expoPlistPath = config_plugins_1.IOSConfig.Paths.getExpoPlistPath(ctx.reactNativeProjectDirectory);
    if (!(await fs_extra_1.default.pathExists(expoPlistPath))) {
        return null;
    }
    const expoPlistContents = await fs_extra_1.default.readFile(expoPlistPath, 'utf8');
    const parsedPlist = plist_1.default.parse(expoPlistContents);
    if (!parsedPlist) {
        return null;
    }
    return (_a = parsedPlist[IosMetadataName.RUNTIME_VERSION]) !== null && _a !== void 0 ? _a : null;
}
exports.iosGetNativelyDefinedRuntimeVersionAsync = iosGetNativelyDefinedRuntimeVersionAsync;
//# sourceMappingURL=expoUpdates.js.map