"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupAsync = void 0;
const eas_build_job_1 = require("@expo/eas-build-job");
const common_1 = require("@expo/eas-build-job/dist/common");
const xcodeEnv_1 = require("../ios/xcodeEnv");
const hooks_1 = require("../utils/hooks");
const npmrc_1 = require("../utils/npmrc");
const project_1 = require("../utils/project");
const projectSources_1 = require("./projectSources");
const installDependencies_1 = require("./installDependencies");
const easBuildInternal_1 = require("./easBuildInternal");
const MAX_EXPO_DOCTOR_TIMEOUT_MS = 20 * 1000;
async function setupAsync(ctx) {
    var _a;
    const packageJson = await ctx.runBuildPhase(eas_build_job_1.BuildPhase.PREPARE_PROJECT, async () => {
        await (0, projectSources_1.prepareProjectSourcesAsync)(ctx);
        if (ctx.env.NPM_TOKEN) {
            await (0, npmrc_1.createNpmrcIfNotExistsAsync)(ctx);
        }
        else {
            await (0, npmrc_1.logIfNpmrcExistsAsync)(ctx);
        }
        if (ctx.job.platform === eas_build_job_1.Platform.IOS && ctx.env.EAS_BUILD_RUNNER === 'eas-build') {
            await (0, xcodeEnv_1.deleteXcodeEnvLocalIfExistsAsync)(ctx);
        }
        if (ctx.job.triggeredBy === common_1.BuildTrigger.GIT_BASED_INTEGRATION) {
            // We need to setup envs from eas.json before
            // eas-build-pre-install hook is called.
            await (0, easBuildInternal_1.configureEnvFromBuildProfileAsync)(ctx);
        }
        // try to read package.json to see if it exists and is valid
        return (0, project_1.readPackageJson)(ctx.reactNativeProjectDirectory);
    });
    await ctx.runBuildPhase(eas_build_job_1.BuildPhase.PRE_INSTALL_HOOK, async () => {
        await (0, hooks_1.runHookIfPresent)(ctx, hooks_1.Hook.PRE_INSTALL);
    });
    await ctx.runBuildPhase(eas_build_job_1.BuildPhase.READ_PACKAGE_JSON, async () => {
        ctx.logger.info('Using package.json:');
        ctx.logger.info(JSON.stringify(packageJson, null, 2));
    });
    await ctx.runBuildPhase(eas_build_job_1.BuildPhase.INSTALL_DEPENDENCIES, async () => {
        await (0, installDependencies_1.installDependenciesAsync)(ctx);
    });
    if (ctx.job.triggeredBy === common_1.BuildTrigger.GIT_BASED_INTEGRATION) {
        await ctx.runBuildPhase(eas_build_job_1.BuildPhase.EAS_BUILD_INTERNAL, async () => {
            await (0, easBuildInternal_1.runEasBuildInternalAsync)(ctx);
        });
    }
    await ctx.runBuildPhase(eas_build_job_1.BuildPhase.READ_APP_CONFIG, async () => {
        ctx.logger.info('Using app configuration:');
        ctx.logger.info(JSON.stringify(ctx.appConfig, null, 2));
    });
    const hasExpoPackage = !!((_a = packageJson.dependencies) === null || _a === void 0 ? void 0 : _a.expo);
    if (hasExpoPackage) {
        await ctx.runBuildPhase(eas_build_job_1.BuildPhase.RUN_EXPO_DOCTOR, async () => {
            try {
                const { stdout } = await runExpoDoctor(ctx);
                if (!stdout.match(/Didn't find any issues with the project/)) {
                    ctx.markBuildPhaseHasWarnings();
                }
            }
            catch (err) {
                ctx.logger.error({ err }, 'Command "expo doctor" failed.');
                ctx.markBuildPhaseHasWarnings();
            }
        });
    }
}
exports.setupAsync = setupAsync;
async function runExpoDoctor(ctx) {
    ctx.logger.info('Running "expo doctor"');
    let timeout;
    try {
        const promise = (0, project_1.runExpoCliCommand)(ctx, ['doctor'], {
            cwd: ctx.reactNativeProjectDirectory,
            logger: ctx.logger,
            env: ctx.env,
        }, 
        // local Expo CLI does not have "doctor" for now
        { forceUseGlobalExpoCli: true });
        timeout = setTimeout(() => {
            var _a;
            promise.child.kill();
            (_a = ctx.reportError) === null || _a === void 0 ? void 0 : _a.call(ctx, `"expo doctor" timed out`, undefined, {
                extras: { buildId: ctx.env.EAS_BUILD_ID },
            });
        }, MAX_EXPO_DOCTOR_TIMEOUT_MS);
        return await promise;
    }
    finally {
        if (timeout) {
            clearTimeout(timeout);
        }
    }
}
//# sourceMappingURL=setup.js.map