"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runGradleCommand = exports.ensureLFLineEndingsInGradlewScript = void 0;
const path_1 = __importDefault(require("path"));
const assert_1 = __importDefault(require("assert"));
const turtle_spawn_1 = __importDefault(require("@expo/turtle-spawn"));
const fs_extra_1 = __importDefault(require("fs-extra"));
async function ensureLFLineEndingsInGradlewScript(ctx) {
    const gradlewPath = path_1.default.join(ctx.reactNativeProjectDirectory, 'android', 'gradlew');
    const gradlewContent = await fs_extra_1.default.readFile(gradlewPath, 'utf8');
    if (gradlewContent.includes('\r')) {
        ctx.logger.info('Replacing CRLF line endings with LF in gradlew script');
        await fs_extra_1.default.writeFile(gradlewPath, gradlewContent.replace(/\r\n/g, '\n'), 'utf8');
    }
}
exports.ensureLFLineEndingsInGradlewScript = ensureLFLineEndingsInGradlewScript;
async function runGradleCommand(ctx, gradleCommand) {
    const androidDir = path_1.default.join(ctx.reactNativeProjectDirectory, 'android');
    ctx.logger.info(`Running 'gradlew ${gradleCommand}' in ${androidDir}`);
    const spawnPromise = (0, turtle_spawn_1.default)('bash', ['-c', `sh gradlew ${gradleCommand}`], {
        cwd: androidDir,
        logger: ctx.logger,
        lineTransformer: (line) => {
            if (!line || /^\.+$/.exec(line)) {
                return null;
            }
            else {
                return line;
            }
        },
        env: ctx.env,
    });
    if (ctx.env.EAS_BUILD_RUNNER === 'eas-build' && process.platform === 'linux') {
        adjustOOMScore(spawnPromise, ctx.logger);
    }
    await spawnPromise;
}
exports.runGradleCommand = runGradleCommand;
/**
 * OOM Killer sometimes kills worker server while build is exceeding memory limits.
 * `oom_score_adj` is a value between -1000 and 1000 and it defaults to 0.
 * It defines which process is more likely to get killed (higher value more likely).
 *
 * This function sets oom_score_adj for Gradle process and all its child processes.
 */
function adjustOOMScore(spawnPromise, logger) {
    setTimeout(async () => {
        try {
            (0, assert_1.default)(spawnPromise.child.pid);
            const children = [spawnPromise.child.pid];
            let shouldRetry = true;
            while (shouldRetry) {
                const result = await (0, turtle_spawn_1.default)('pgrep', ['-P', children.join(',')], {
                    stdio: 'pipe',
                });
                const pids = result.stdout
                    .toString()
                    .split('\n')
                    .map((i) => Number(i.trim()))
                    .filter((i) => i);
                shouldRetry = false;
                for (const pid of pids) {
                    if (!children.includes(pid)) {
                        shouldRetry = true;
                        children.push(pid);
                    }
                }
            }
            await Promise.all(children.map(async (pid) => {
                // Value 800 is just a guess here. It's probably higher than most other
                // process. I didn't want to set it any higher, because I'm not sure if OOM Killer
                // can start killing processes when there is still enough memory left.
                const oomScoreOverride = 800;
                await fs_extra_1.default.writeFile(`/proc/${pid}/oom_score_adj`, `${oomScoreOverride}\n`);
            }));
        }
        catch (err) {
            logger.debug({ err, stderr: err === null || err === void 0 ? void 0 : err.stderr }, 'Failed to override oom_score_adj');
        }
    }, 
    // Wait 20 seconds to make sure all child processes are started
    20000);
}
//# sourceMappingURL=gradle.js.map