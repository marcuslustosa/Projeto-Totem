"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XcodeBuildLogger = void 0;
const assert_1 = __importDefault(require("assert"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const xcpretty_1 = require("@expo/xcpretty");
const spawn_async_1 = __importDefault(require("@expo/spawn-async"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const CHECK_FILE_INTERVAL_MS = 1000;
class XcodeBuildLogger {
    constructor(logger, projectRoot) {
        this.logger = logger;
        this.projectRoot = projectRoot;
        this.flushing = false;
    }
    async watchLogFiles(logsDirectory) {
        while (!this.flushing) {
            const logsFilename = await this.getBuildLogFilename(logsDirectory);
            if (logsFilename) {
                this.logsPath = path_1.default.join(logsDirectory, logsFilename);
                void this.startBuildLogger(this.logsPath);
                return;
            }
            await new Promise((res) => setTimeout(res, CHECK_FILE_INTERVAL_MS));
        }
    }
    async flush() {
        this.flushing = true;
        if (this.loggerError) {
            throw this.loggerError;
        }
        if (this.logReaderPromise) {
            this.logReaderPromise.child.kill('SIGINT');
            try {
                await this.logReaderPromise;
            }
            catch (_a) { }
        }
        if (this.logsPath) {
            await this.findBundlerErrors(this.logsPath);
        }
    }
    async getBuildLogFilename(logsDirectory) {
        const paths = await (0, fast_glob_1.default)('*.log', { cwd: logsDirectory });
        return paths.length >= 1 ? paths[0] : undefined;
    }
    async startBuildLogger(logsPath) {
        try {
            const formatter = xcpretty_1.ExpoRunFormatter.create(this.projectRoot, {
                isDebug: false,
                // TODO: Can provide xcode project name for better parsing
            });
            this.logReaderPromise = (0, spawn_async_1.default)('tail', ['-n', '+0', '-f', logsPath], { stdio: 'pipe' });
            (0, assert_1.default)(this.logReaderPromise.child.stdout, 'stdout is not available');
            this.logReaderPromise.child.stdout.on('data', (data) => {
                const lines = formatter.pipe(data.toString());
                for (const line of lines) {
                    this.logger.info(line);
                }
            });
            await this.logReaderPromise;
            this.logger.info(formatter.getBuildSummary());
        }
        catch (err) {
            if (!this.flushing) {
                this.loggerError = err;
            }
        }
    }
    async findBundlerErrors(logsPath) {
        try {
            const logFile = await fs_extra_1.default.readFile(logsPath, 'utf-8');
            const match = logFile.match(/Welcome to Metro!\s* Fast - Scalable - Integrated\s*([\s\S]*)Run CLI with --verbose flag for more details.\nCommand PhaseScriptExecution failed with a nonzero exit code/);
            if (match) {
                this.logger.info(match[1]);
            }
        }
        catch (err) {
            this.logger.error({ err }, 'Failed to read Xcode logs');
        }
    }
}
exports.XcodeBuildLogger = XcodeBuildLogger;
//# sourceMappingURL=xcpretty.js.map