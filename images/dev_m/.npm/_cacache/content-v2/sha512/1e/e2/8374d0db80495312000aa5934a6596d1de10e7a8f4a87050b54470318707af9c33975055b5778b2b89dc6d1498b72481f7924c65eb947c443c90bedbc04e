{"_id":"expo-notifications","_rev":"126-614cec600a2a86fdb9fe97687fe4132a","name":"expo-notifications","dist-tags":{"latest":"0.17.0"},"versions":{"0.1.0-alpha.0":{"name":"expo-notifications","version":"0.1.0-alpha.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"*","expo-constants":"*","unimodules-permissions-interface":"*"},"gitHead":"ec7878b9ce54f2537721218ae0fe4017e4004806","dependencies":{"badgin":"^1.1.5","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7"},"_id":"expo-notifications@0.1.0-alpha.0","dist":{"shasum":"3dfc1715c75efca16cefc5b9660aee32317e2677","integrity":"sha512-iVofBoeBDjZTCY4O/XUuXDQOxzTqMYy9o3erkcV21hxuiwV7LzoagQ7PuhVe8yVeK29NH5hzRg/1i69terRUiw==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.0-alpha.0.tgz","fileCount":201,"unpackedSize":357145,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJegg3nCRA9TVsSAnZWagAA2wkP/RPnl/8lKsNdrW3W5jiA\nSKyvooLy//luBRLz1WxuhI3Gfghlp5AyN4QAByPgIARIhXJ0+FX5I4eturIW\n3UrUFe8QjMgoc+AmyCUyV33klRPIvM9RYP2GY4hANTc48efO5rEltwNxOsLo\nA1Yx9YjXsnpZyvYCJkMcT2/ihtfX7yohhjupttJIr+So6Nzstr//BN5G3FZz\nAn7CIIwZm3FoM9LW22hr3yMAEkyUVilzz5dnbTHPRaBs3P6xYcy3wNjRIVJJ\nWSz2SCvunN5lzwDuzTP/RXEF/5m5rVxHyzcmoP3p+sSpNmcpgebVkO667XxV\n0x6LPlDvZd8FevmH+n7zoR0ddREKVApJfJ6VJ0baLcPtxvNYw+V7ylOFG6BV\nbTY/xHxIwvwYwmJX6ekPng4QfD4L7Wux3SAgLxIqXVj1+2BRXHLeLcEERt8q\nX0nEQAeDJNnUU7w3C2egBXEMK20f/XalhRexmTaDdp0mmCAkjH5ZnqdNHBpu\nUOYYQgyWFx4eZRN/KK73/CtqAiqmdd8hdG7EfNLWGdp5EVlBC6f5jAJh6QJA\ni3p8KM6APZYBnbiWxtR//ldmzp0XSxfPlR5VVpfcU7QnaA2SNzugnP0SrqyM\nygIxhKmLVAW27Rge+F8oLD318aw3CSaxWoSKaF97QrnXRnaQBrwqhP06Ec6r\nGXyP\r\n=jMxD\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAc+xrZMm7kvQ4CWV8KAXNBMkYwcS9jl7J6yeW7f+45LAiEAotKV6wTRW381o7TcXCF3Bs7qVg90MERWhoWy09HKZD8="}]},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.0-alpha.0_1585581542847_0.12240620621664977"},"_hasShrinkwrap":false},"0.1.0-alpha.1":{"name":"expo-notifications","version":"0.1.0-alpha.1","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"*","expo-constants":"*","unimodules-permissions-interface":"*"},"gitHead":"71839983dec66421bc6e7cd2f145884d7552b733","dependencies":{"badgin":"^1.1.5","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7"},"readmeFilename":"README.md","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels.\n\n# API documentation\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasync) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistener) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscription) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistener) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistener) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistener) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscription) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeAllNotificationListeners) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandler) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasync) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasync) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasync) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasync) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasync) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`dismissNotificationAsync`](#dismissnotificationasync) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasync) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasync) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasync) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasync) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasync) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasync) -- deletes a notification channel group\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `pod install` in the `ios` directory after installing the npm package.\n\n### Configure for Android\n\nEnsure that your project is configured for Firebase (to verify if it is, check if `android/app` folder contains a `google-services.json` file).\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/versions/latest/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **deviceId (_string_)** -- The ID of the application installation. `expo-notifications` is capable of generating one for you and it defaults to it. Most probably you won't need to customize that.\n- **type (_string_)** -- Type of token sent to the server. Inferred from `devicePushToken`. Most probably you won't need to customize that.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that.\n- **baseUrl (_string_)** -- Base URL upon which the function will build a URL to which it will send the device push token. If `url` is defined, this option won't have any effect. Defaults to a production Expo backend URL. Most probably you won't need to change that.\n- **url (_string_)** -- Endpoint URL to which the function will send the device push token. Most probably you won't need to customize that. Setting `url` overrides `baseUrl`.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(notificationRequest: NotificationRequest): Promise<void>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** Please note that this does not mean that the notification will be presented. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationRequest`](#notificationrequest).\n\n#### Returns\n\nIt returns a `Promise` resolving once the notification is successfully scheduled.\n\n#### Examples\n\n##### Presenting the notification to the user\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  message: \"I'm so proud of myself!\",\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequest, trigger: NotificationTrigger): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\n1. A [`NotificationRequest`](#notificationrequest) describing the notification to be triggered.\n2. A [`NotificationTrigger`](#notificationtrigger) describing when should the notification trigger.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: \"Time's up!\",\n    message: 'Change sides!',\n  },\n  {\n    seconds: 60,\n  }\n);\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  title: 'Remember to drink water!,\n}, {\n  seconds: 60 * 20,\n  repeats: true\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst triggerDate = new Date(Date.now() + 60 * 60 * 1000);\ntriggerDate.setMinutes(0);\ntriggerDate.setSeconds(0);\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: 'Happy new hour!',\n  },\n  triggerDate\n);\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync(\n    {\n      title: 'Hey!',\n    },\n    { seconds: 5, repeats: true }\n  );\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      sound: 'default' | 'defaultCritical' | 'custom' | null;\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      sound?: 'default' | string | null;\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` and `scheduleNotificationAsync`\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> Note: If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility { UNKNOWN, PUBLIC, PRIVATE, SECRET }\n\nexport enum AndroidAudioContentType { UNKNOWN, SPEECH, MUSIC, MOVIE, SONIFICATION }\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  soundUri: string | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  soundUri?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","_id":"expo-notifications@0.1.0-alpha.1","dist":{"shasum":"adfbd0b096458197029818169234fe562f9fbdbb","integrity":"sha512-zn7nTMnWpezn9vS+iToCzIiwjRfl/emNdYS9diesgPLaYnLf3LO74hg7UlTyrkgX8FEXivRjNGnYQtUYzzoziQ==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.0-alpha.1.tgz","fileCount":201,"unpackedSize":357145,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeghTwCRA9TVsSAnZWagAA/dgQAIP0Op6f/TWhdcr4fANG\nZgo5ULMZWD5/0/JTqfKP1IRqVkOXBNN82uS15RriOsztN4EOKkRQKctm8R4W\n+lFKogdKz+s2YqbEzkXrQaA43iXqUoqhmGi8Ny5yFuVcTh0NLb5sLT983Fos\nVoMaFI5C6mCbOsdNYiWMiBkULSJYM1PmC6yoE7Ae872UG3DmjQNb6wj/igRS\neki2yzAUS1mhamLJ4MouOjYaVg5aVG22IB3VnAvlYsV9a6OpIzmaOnQ4vM1W\npqPZYupkY8v3Xannlsn0q4staWUiAFQfrm5HxNjnQQ/osvI2ACQspMtyRQuC\n8i32LAbqKk1ybfYLTvtog/4Xfzy5qROd8wvfxHGnOVxpZBAd8aLvAXxFNFyN\nhibvIyvtFGgt4YuzKbFZ0oXTj9etN4JfsjRiZIJbdROKHHBQ3kEjyj2FnzF2\nftC30DIuKeAJIytqIIECYUy0fmSBY1qz7sB+aWFekHs98MShUGDUi/vG4rAz\nW+G+4oGrJawKzen0F0vVopk+Q6xQzkYCCpDavErk4LAO9I4vToNwfZ08wnaB\nC0CGRK2TmaK5LDSXQCnRa/cpwJoJW0VkczZjkz1e97YQegdO0g9wn2GncAul\ncVTl2UahFI9Uts2OJdYjSpNln7/afjVLYg6Z6bG4E17dWCHpWJoXpUC23RiQ\nc7YA\r\n=SqIi\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIDq/PYXactqtVE/uHpFagrXtDlivhrWFdFlDf0IYiIUdAiBFDocQAjBUOAmp0w2QESYVMMfqjtA37YaZ/b0MSFXQqg=="}]},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.0-alpha.1_1585583343655_0.7248372314502634"},"_hasShrinkwrap":false},"0.1.0-alpha.2":{"name":"expo-notifications","version":"0.1.0-alpha.2","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"*","expo-constants":"*","unimodules-permissions-interface":"*"},"gitHead":"71839983dec66421bc6e7cd2f145884d7552b733","dependencies":{"badgin":"^1.1.5","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7"},"readmeFilename":"README.md","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels.\n\n# API documentation\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasync) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistener) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscription) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistener) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistener) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistener) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscription) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeAllNotificationListeners) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandler) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasync) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasync) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasync) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasync) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasync) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`dismissNotificationAsync`](#dismissnotificationasync) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasync) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasync) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasync) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasync) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasync) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasync) -- deletes a notification channel group\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `pod install` in the `ios` directory after installing the npm package.\n\n### Configure for Android\n\nEnsure that your project is configured for Firebase (to verify if it is, check if `android/app` folder contains a `google-services.json` file).\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/versions/latest/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **deviceId (_string_)** -- The ID of the application installation. `expo-notifications` is capable of generating one for you and it defaults to it. Most probably you won't need to customize that.\n- **type (_string_)** -- Type of token sent to the server. Inferred from `devicePushToken`. Most probably you won't need to customize that.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that.\n- **baseUrl (_string_)** -- Base URL upon which the function will build a URL to which it will send the device push token. If `url` is defined, this option won't have any effect. Defaults to a production Expo backend URL. Most probably you won't need to change that.\n- **url (_string_)** -- Endpoint URL to which the function will send the device push token. Most probably you won't need to customize that. Setting `url` overrides `baseUrl`.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(notificationRequest: NotificationRequest): Promise<void>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** Please note that this does not mean that the notification will be presented. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationRequest`](#notificationrequest).\n\n#### Returns\n\nIt returns a `Promise` resolving once the notification is successfully scheduled.\n\n#### Examples\n\n##### Presenting the notification to the user\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  message: \"I'm so proud of myself!\",\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequest, trigger: NotificationTrigger): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\n1. A [`NotificationRequest`](#notificationrequest) describing the notification to be triggered.\n2. A [`NotificationTrigger`](#notificationtrigger) describing when should the notification trigger.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: \"Time's up!\",\n    message: 'Change sides!',\n  },\n  {\n    seconds: 60,\n  }\n);\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  title: 'Remember to drink water!,\n}, {\n  seconds: 60 * 20,\n  repeats: true\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst triggerDate = new Date(Date.now() + 60 * 60 * 1000);\ntriggerDate.setMinutes(0);\ntriggerDate.setSeconds(0);\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: 'Happy new hour!',\n  },\n  triggerDate\n);\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync(\n    {\n      title: 'Hey!',\n    },\n    { seconds: 5, repeats: true }\n  );\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      sound: 'default' | 'defaultCritical' | 'custom' | null;\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      sound?: 'default' | string | null;\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` and `scheduleNotificationAsync`\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> Note: If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility { UNKNOWN, PUBLIC, PRIVATE, SECRET }\n\nexport enum AndroidAudioContentType { UNKNOWN, SPEECH, MUSIC, MOVIE, SONIFICATION }\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  soundUri: string | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  soundUri?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","_id":"expo-notifications@0.1.0-alpha.2","dist":{"shasum":"5e2002b2343de2ce1faa8078a2a8f76dab216c35","integrity":"sha512-5w5ugXPSUPgtXYY1aLGheVMB71XRZjbISsDnONMKBjn2S+23lGlJzc9RthHiTA/VVIjRiZLWAgt3OtgZJrOajg==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.0-alpha.2.tgz","fileCount":809,"unpackedSize":2285716,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeghdWCRA9TVsSAnZWagAAm6cQAJJS9fvxe4tza47dgy7S\n1niOBQEtG6AkSVHEvSJs8TUKbUnko4FNwiRciPFk0C/2UEwKx2+aRbp7d2Dz\ncSVuI7fvqydUx9CE4A6q6q51RxChPwGXVXQ9vM/qexBGuQYDNfMdGMNC+Qk8\nKa1BWMV5OOHXQN2ZnbIZziLOMkEI/Gi0ZZb3uddIlMksCzW2S3jv0fXj2Jsd\nkPJE9h9Lc5Bif1JAMuqxg5fIVYK+IPrSvsen6ZmiNh+WolGUvN0Xc2A2OzrC\n6eJ3REDIPargGOXvl/CA7z43an9CrhvQSEGxmQFktVUUSGLn8nu3lAud/j2t\nz5mzAwhm8L/ffBngDk6cBKv6lwTbI6KU3layxUzeXbbn6YH4+vMk8h9eMPHm\nFNATCyW1P31yWrd335XyY/I6IWN0V54QPxlWxpEhLb2PuhJC/f+1id0PdHme\nYIDGcfu/5bWdddk4pHXOoVQrnjCpHqiMu58WHgLOWJDLMeONvw6m06ghC+Bu\nKGMKnLylXBuDTDWtMUAhDsaVaao/QFVFXQOO+RaXVjR52dOzvF1eh2DMYmLt\nTs14zUZmyYSgqEO7uuyfbO6JCr/43CT28BvZ5YWXR/pyRGRm7LHRp350bjep\n8vrLQpaM8bOJxxJj0yRWKHyOTlbFMLOmp6lFP2/gZsPgtjU31QNrewdi7Z2z\nGU5j\r\n=OSeC\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIElVefaZR7r1r+HX/SUcbuQ5toMVpdmKz8RzA1FO5Up3AiAojohFtXznXIurSBEGLjRRgCs5RxejjQTu7HhHq11qtA=="}]},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.0-alpha.2_1585583957898_0.05888470260129619"},"_hasShrinkwrap":false},"0.1.0-alpha.3":{"name":"expo-notifications","version":"0.1.0-alpha.3","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"*","expo-constants":"*","unimodules-permissions-interface":"*"},"gitHead":"71839983dec66421bc6e7cd2f145884d7552b733","dependencies":{"badgin":"^1.1.5","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7"},"readmeFilename":"README.md","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels.\n\n# API documentation\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasync) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistener) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscription) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistener) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistener) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistener) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscription) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeAllNotificationListeners) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandler) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasync) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasync) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasync) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasync) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasync) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`dismissNotificationAsync`](#dismissnotificationasync) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasync) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasync) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasync) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasync) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasync) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasync) -- deletes a notification channel group\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `pod install` in the `ios` directory after installing the npm package.\n\n### Configure for Android\n\nEnsure that your project is configured for Firebase (to verify if it is, check if `android/app` folder contains a `google-services.json` file).\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/versions/latest/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **deviceId (_string_)** -- The ID of the application installation. `expo-notifications` is capable of generating one for you and it defaults to it. Most probably you won't need to customize that.\n- **type (_string_)** -- Type of token sent to the server. Inferred from `devicePushToken`. Most probably you won't need to customize that.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that.\n- **baseUrl (_string_)** -- Base URL upon which the function will build a URL to which it will send the device push token. If `url` is defined, this option won't have any effect. Defaults to a production Expo backend URL. Most probably you won't need to change that.\n- **url (_string_)** -- Endpoint URL to which the function will send the device push token. Most probably you won't need to customize that. Setting `url` overrides `baseUrl`.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(notificationRequest: NotificationRequest): Promise<void>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** Please note that this does not mean that the notification will be presented. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationRequest`](#notificationrequest).\n\n#### Returns\n\nIt returns a `Promise` resolving once the notification is successfully scheduled.\n\n#### Examples\n\n##### Presenting the notification to the user\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  message: \"I'm so proud of myself!\",\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequest, trigger: NotificationTrigger): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\n1. A [`NotificationRequest`](#notificationrequest) describing the notification to be triggered.\n2. A [`NotificationTrigger`](#notificationtrigger) describing when should the notification trigger.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: \"Time's up!\",\n    message: 'Change sides!',\n  },\n  {\n    seconds: 60,\n  }\n);\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  title: 'Remember to drink water!,\n}, {\n  seconds: 60 * 20,\n  repeats: true\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst triggerDate = new Date(Date.now() + 60 * 60 * 1000);\ntriggerDate.setMinutes(0);\ntriggerDate.setSeconds(0);\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: 'Happy new hour!',\n  },\n  triggerDate\n);\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync(\n    {\n      title: 'Hey!',\n    },\n    { seconds: 5, repeats: true }\n  );\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      sound: 'default' | 'defaultCritical' | 'custom' | null;\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      sound?: 'default' | string | null;\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` and `scheduleNotificationAsync`\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> Note: If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility { UNKNOWN, PUBLIC, PRIVATE, SECRET }\n\nexport enum AndroidAudioContentType { UNKNOWN, SPEECH, MUSIC, MOVIE, SONIFICATION }\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  soundUri: string | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  soundUri?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","_id":"expo-notifications@0.1.0-alpha.3","dist":{"shasum":"abefb30e9c90205de98dc1055bc5efe10f0c47b2","integrity":"sha512-qgGItXWaL7KkAnHJcEgKTNiZelIYWgfMYQgXXyPhdyL39lh8ETxSyQUCB23Z5vCdarxZGv1PGdA22O+kpgGecw==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.0-alpha.3.tgz","fileCount":809,"unpackedSize":2286094,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJegh1tCRA9TVsSAnZWagAAvIYP/0z3okgd4z+z7+aZwJQc\nr/xM3elZsOWvq+HBfhw9fxAdEL3z7cbsSmS2gsv1yC/14Pvmw+/hFP4+x9jY\n0uuJlwhHIv5rZhNbZQYOHzx/l9TlJZpLng2etmeY2RVYXe4921tJI25y69Lq\nn6rklSng0yggdoQMoqCeAt9YzM7kUnkNHfOEhkf4JnPjeUmmvhXVe1DVnFTh\nstqWw5vZ/R/MwVUwebKzO/tCBYSNs3uQnehhRh9raeDfNnt+wC7w93e/bUK6\nRu7O4PzH04YNWxzlzSyftgOO8X6ER7jHgvlh5r/zHzXaa+k0/GpGNrThUw2E\n9e90qjPGjvUc2NxtWGe+UuFocHFiuXiAsDqmUIyGuK6XNj+s8QJW/0Oi6NvE\n5Bdo09IW6fKC55DBx+Rk90s+FdM/7UK7r7rtgqN5KnhFSig36k3m6iJhj4/p\nsG+TM+eeE6Fe67g0eduIp1zaKcez9kIVairP5lfDjIj8Mk6b6DL9Mbw4t8xp\nfGIWFP9w/H3EIfVLQsXTIOGX3U9M5n9jNlwwCFDvGnp5R6e39elERtSW3C7G\nEKkrviReDrOyNgKia3hCRJVu0C/VFmd5xtWz12Hf409QRwpOqvstheLloalJ\nGyHErVzPjIyfgKhAotvi0wqhzLya9i4neUb7inH+FUJw5TpVkgyiPokMuuUW\nowal\r\n=kSak\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCEKCIC87YMwB9bwhqLhuudeGIjv41crpuTMP/Lgfqc5AIgL0MoOWEvON4B34KLcPN1qc5utmUUTTWlMUbW/X86F60="}]},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.0-alpha.3_1585585517407_0.3058709259793482"},"_hasShrinkwrap":false},"0.1.0-alpha.4":{"name":"expo-notifications","version":"0.1.0-alpha.4","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"*","expo-constants":"*","unimodules-permissions-interface":"*"},"optionalDependencies":{"expo-application":"*"},"gitHead":"71839983dec66421bc6e7cd2f145884d7552b733","dependencies":{"badgin":"^1.1.5","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7"},"readmeFilename":"README.md","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels.\n\n# API documentation\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasync) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistener) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscription) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistener) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistener) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistener) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscription) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeAllNotificationListeners) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandler) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasync) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasync) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasync) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasync) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasync) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`dismissNotificationAsync`](#dismissnotificationasync) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasync) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasync) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasync) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasync) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasync) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasync) -- deletes a notification channel group\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `pod install` in the `ios` directory after installing the npm package.\n\n### Configure for Android\n\nEnsure that your project is configured for Firebase (to verify if it is, check if `android/app` folder contains a `google-services.json` file).\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/versions/latest/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **deviceId (_string_)** -- The ID of the application installation. `expo-notifications` is capable of generating one for you and it defaults to it. Most probably you won't need to customize that.\n- **type (_string_)** -- Type of token sent to the server. Inferred from `devicePushToken`. Most probably you won't need to customize that.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that.\n- **baseUrl (_string_)** -- Base URL upon which the function will build a URL to which it will send the device push token. If `url` is defined, this option won't have any effect. Defaults to a production Expo backend URL. Most probably you won't need to change that.\n- **url (_string_)** -- Endpoint URL to which the function will send the device push token. Most probably you won't need to customize that. Setting `url` overrides `baseUrl`.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(notificationRequest: NotificationRequest): Promise<void>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** Please note that this does not mean that the notification will be presented. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationRequest`](#notificationrequest).\n\n#### Returns\n\nIt returns a `Promise` resolving once the notification is successfully scheduled.\n\n#### Examples\n\n##### Presenting the notification to the user\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  message: \"I'm so proud of myself!\",\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequest, trigger: NotificationTrigger): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\n1. A [`NotificationRequest`](#notificationrequest) describing the notification to be triggered.\n2. A [`NotificationTrigger`](#notificationtrigger) describing when should the notification trigger.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: \"Time's up!\",\n    message: 'Change sides!',\n  },\n  {\n    seconds: 60,\n  }\n);\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  title: 'Remember to drink water!,\n}, {\n  seconds: 60 * 20,\n  repeats: true\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst triggerDate = new Date(Date.now() + 60 * 60 * 1000);\ntriggerDate.setMinutes(0);\ntriggerDate.setSeconds(0);\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: 'Happy new hour!',\n  },\n  triggerDate\n);\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync(\n    {\n      title: 'Hey!',\n    },\n    { seconds: 5, repeats: true }\n  );\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      sound: 'default' | 'defaultCritical' | 'custom' | null;\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      sound?: 'default' | string | null;\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` and `scheduleNotificationAsync`\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> Note: If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility { UNKNOWN, PUBLIC, PRIVATE, SECRET }\n\nexport enum AndroidAudioContentType { UNKNOWN, SPEECH, MUSIC, MOVIE, SONIFICATION }\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  soundUri: string | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  soundUri?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","_id":"expo-notifications@0.1.0-alpha.4","dist":{"shasum":"f76c652342dc7bd28f3bf6570342f84a6c3dc77a","integrity":"sha512-h+Zxw/YOpl5i9CJpdfpu9ZjzU5z9jlLx5uNzNRqWaXkun9ymPiR6YY6ItMqqm1XBuI556JF13b38jhRrnrClEQ==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.0-alpha.4.tgz","fileCount":809,"unpackedSize":2286155,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJegihfCRA9TVsSAnZWagAANacP/iLcACxT+zNHCduCisd9\nnJAUJkhbkHDl6JOUkG81xdCbTnm7UfsDPbcktTCd+hVPGEkpRqZ0YZuJmJkW\ngcws5uhRazZQDqc/MUbPApSdJDzXd9j3FN+etcRPsGzdBRck6FJtO3ru4QZl\nkWcLRxX9agHXP7D4kDHnc0rh1l3cuvNS6znkiTO4feZru2T5w51cvoYnY+1g\nTwiUh9zgDEO4pMw6UPegculwDCBkmgavyD6yGbwxcTk2AcsUe9UQZi2aWded\nrqVUVhHvel4x4ixqLHfbi4YCoEmN2jasvA3/UTWtJBeGJ4w292SfI6/hUAz1\nzqwjSK+jkRw2fnJXNuNVg5eZPSdSsJqwh7ZQEcw3GAYFQbbF8Yp0JGYo6JeT\nf87K4ErsmWDhRq8SXk2Mlr8s7csExPKQOsZ1oDkOaZUlgxC3WRgc1izEpexR\nVavRYFyq/zhqcStyFm8JnpAc7kgW0Hunac9HjGQQGMMq0i26k8l9i/DM/LBB\nbdjx9i8ZKlDOtRrjEIysB2BqZhB3zVmDuMASPl6tOxv849Pw5JmMz3ZNFGsE\nKMNNNRUNyWu4bB2kCjrBTUNUgfth0BxIbGJj6JGHgvok693PtlqCA3MVp7X8\nrQ+yRHOvFFq1XRa8/5Jud8qh0moey63DQ5NerYvQVfR5VGO17wfC50FK5gcW\npQqA\r\n=N+pH\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDsQyNSdP3ixbxsO6LPJSFXnmnPQdqf0hDvAStTW8FDIgIgWvQBeAMxHMpgMXXZ1DT5UJ+7oKcY1TbEKU+ltARR534="}]},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.0-alpha.4_1585588319341_0.40914338574356846"},"_hasShrinkwrap":false},"0.1.0-alpha.5":{"name":"expo-notifications","version":"0.1.0-alpha.5","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"*","expo-constants":"*","unimodules-permissions-interface":"*"},"peerDependencies":{"@unimodules/core":"*","expo-application":"*","expo-constants":"*","unimodules-permissions-interface":"*"},"gitHead":"71839983dec66421bc6e7cd2f145884d7552b733","dependencies":{"badgin":"^1.1.5","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7"},"readmeFilename":"README.md","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels.\n\n# API documentation\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasync) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistener) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscription) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistener) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistener) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistener) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscription) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeAllNotificationListeners) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandler) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasync) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasync) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasync) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasync) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasync) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`dismissNotificationAsync`](#dismissnotificationasync) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasync) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasync) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasync) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasync) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasync) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasync) -- deletes a notification channel group\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `pod install` in the `ios` directory after installing the npm package.\n\n### Configure for Android\n\nEnsure that your project is configured for Firebase (to verify if it is, check if `android/app` folder contains a `google-services.json` file).\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/versions/latest/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **deviceId (_string_)** -- The ID of the application installation. `expo-notifications` is capable of generating one for you and it defaults to it. Most probably you won't need to customize that.\n- **type (_string_)** -- Type of token sent to the server. Inferred from `devicePushToken`. Most probably you won't need to customize that.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that.\n- **baseUrl (_string_)** -- Base URL upon which the function will build a URL to which it will send the device push token. If `url` is defined, this option won't have any effect. Defaults to a production Expo backend URL. Most probably you won't need to change that.\n- **url (_string_)** -- Endpoint URL to which the function will send the device push token. Most probably you won't need to customize that. Setting `url` overrides `baseUrl`.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(notificationRequest: NotificationRequest): Promise<void>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** Please note that this does not mean that the notification will be presented. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationRequest`](#notificationrequest).\n\n#### Returns\n\nIt returns a `Promise` resolving once the notification is successfully scheduled.\n\n#### Examples\n\n##### Presenting the notification to the user\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  message: \"I'm so proud of myself!\",\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequest, trigger: NotificationTrigger): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\n1. A [`NotificationRequest`](#notificationrequest) describing the notification to be triggered.\n2. A [`NotificationTrigger`](#notificationtrigger) describing when should the notification trigger.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: \"Time's up!\",\n    message: 'Change sides!',\n  },\n  {\n    seconds: 60,\n  }\n);\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  title: 'Remember to drink water!,\n}, {\n  seconds: 60 * 20,\n  repeats: true\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst triggerDate = new Date(Date.now() + 60 * 60 * 1000);\ntriggerDate.setMinutes(0);\ntriggerDate.setSeconds(0);\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: 'Happy new hour!',\n  },\n  triggerDate\n);\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync(\n    {\n      title: 'Hey!',\n    },\n    { seconds: 5, repeats: true }\n  );\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      sound: 'default' | 'defaultCritical' | 'custom' | null;\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      sound?: 'default' | string | null;\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` and `scheduleNotificationAsync`\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> Note: If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility { UNKNOWN, PUBLIC, PRIVATE, SECRET }\n\nexport enum AndroidAudioContentType { UNKNOWN, SPEECH, MUSIC, MOVIE, SONIFICATION }\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  soundUri: string | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  soundUri?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","_id":"expo-notifications@0.1.0-alpha.5","dist":{"shasum":"7c040bc6fafd5cda22aeb3ed78cd3603a7782361","integrity":"sha512-0Cwo8FjYT2rchFTPzGDDBszP98duuGjaNuKGIUUh3vwDCGRy8GSxntG4W2hq5kkCtCwB8HnrIjnFw82nmJ8p6w==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.0-alpha.5.tgz","fileCount":809,"unpackedSize":2286347,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJegiuLCRA9TVsSAnZWagAAud8P/i1dlhx3mwR50HDLGDhw\ncMEMRCn4ZELo61gapdDUsn8uou1lxqI6Qocr2d88PZ5toU1u10q8kIHkoNYX\npNlPVgmeB37qgVfzYiS6VQln77HdM3Bh88DwGCRYZzpzh7I4gq5WK8uckJDo\n0qDBR/4GzEGSHMtdSKi84uyfy1cYH5EbIhZXY0QddoYdihYoqbpIDyqJQ1VH\nLNvS0Wb47UbekqPEbPLLOtZnj/01ty5qQmF0oPn0K5bciNtbjH2vieSfswE9\naMu365v8OWM19K8TC2tkvi/c586PuFIMwTmqA4W8aNcLHS24nUi1TD2O5O9y\n4i2W2Yy+GiOpMVNT2/wZMDtwTL5oXIl/3dNip4s7U1V8pmwP29fEm3bAbTz9\n+nP5Sm4iActeSVU83M+Nmg5ACrorVbIm6vPKKsgHwxWckQz3U/iM+1W+yTWJ\n1d6ewFfmKRnu6V//XmiYqxkc99CNMIU6g49xaN0aY+/JOeqq4VHKfF9cGEe8\nLokFDOvBI+sy/AR/o77PGGHklSufsh/TNZTHHBWSYxeIF5k4phN0a44FeUv3\nkZS6tloU9MSnD0s4zV9ZckUuxejdyCdlfO1JBcipGrMCExbppAoiZ3puz1+H\nRCRgxaHtAcHpP4VFGn0RBi54418X74nKub1xOc4im3wlD1b5vbPuKxcfq8l1\nxh05\r\n=wZAr\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIF80BaqwFkyZ2KA+GR/wUcPEV8/3bqjkk0/D77f6JGzqAiAHMnCfhso+1VNp7KBSnvjrfFDkgx/7JFNT0r9IsgXYkw=="}]},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.0-alpha.5_1585589130844_0.621751093646546"},"_hasShrinkwrap":false},"0.1.0-alpha.6":{"name":"expo-notifications","version":"0.1.0-alpha.6","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"*","expo-constants":"*","unimodules-permissions-interface":"*"},"peerDependencies":{"expo-application":"*","expo-constants":"*"},"gitHead":"71839983dec66421bc6e7cd2f145884d7552b733","dependencies":{"badgin":"^1.1.5","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7"},"readmeFilename":"README.md","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels.\n\n# API documentation\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasync) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistener) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscription) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistener) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistener) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistener) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscription) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeAllNotificationListeners) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandler) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasync) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasync) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasync) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasync) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasync) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`dismissNotificationAsync`](#dismissnotificationasync) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasync) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasync) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasync) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasync) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasync) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasync) -- deletes a notification channel group\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `pod install` in the `ios` directory after installing the npm package.\n\n### Configure for Android\n\nEnsure that your project is configured for Firebase (to verify if it is, check if `android/app` folder contains a `google-services.json` file).\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/versions/latest/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **deviceId (_string_)** -- The ID of the application installation. `expo-notifications` is capable of generating one for you and it defaults to it. Most probably you won't need to customize that.\n- **type (_string_)** -- Type of token sent to the server. Inferred from `devicePushToken`. Most probably you won't need to customize that.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that.\n- **baseUrl (_string_)** -- Base URL upon which the function will build a URL to which it will send the device push token. If `url` is defined, this option won't have any effect. Defaults to a production Expo backend URL. Most probably you won't need to change that.\n- **url (_string_)** -- Endpoint URL to which the function will send the device push token. Most probably you won't need to customize that. Setting `url` overrides `baseUrl`.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(notificationRequest: NotificationRequest): Promise<void>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** Please note that this does not mean that the notification will be presented. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationRequest`](#notificationrequest).\n\n#### Returns\n\nIt returns a `Promise` resolving once the notification is successfully scheduled.\n\n#### Examples\n\n##### Presenting the notification to the user\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  message: \"I'm so proud of myself!\",\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequest, trigger: NotificationTrigger): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\n1. A [`NotificationRequest`](#notificationrequest) describing the notification to be triggered.\n2. A [`NotificationTrigger`](#notificationtrigger) describing when should the notification trigger.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: \"Time's up!\",\n    message: 'Change sides!',\n  },\n  {\n    seconds: 60,\n  }\n);\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  title: 'Remember to drink water!,\n}, {\n  seconds: 60 * 20,\n  repeats: true\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst triggerDate = new Date(Date.now() + 60 * 60 * 1000);\ntriggerDate.setMinutes(0);\ntriggerDate.setSeconds(0);\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: 'Happy new hour!',\n  },\n  triggerDate\n);\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync(\n    {\n      title: 'Hey!',\n    },\n    { seconds: 5, repeats: true }\n  );\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      sound: 'default' | 'defaultCritical' | 'custom' | null;\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      sound?: 'default' | string | null;\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` and `scheduleNotificationAsync`\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> Note: If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility { UNKNOWN, PUBLIC, PRIVATE, SECRET }\n\nexport enum AndroidAudioContentType { UNKNOWN, SPEECH, MUSIC, MOVIE, SONIFICATION }\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  soundUri: string | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  soundUri?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","_id":"expo-notifications@0.1.0-alpha.6","dist":{"shasum":"6627b054f1b87f9e021aa3957fe51b0e846804cc","integrity":"sha512-agOqHK56t/vd0u4XS4H44GwCh7y18UtNlkckH4CfqHf/mJWzHQcwpt2lwVpSkl/uwSLwbsJAzLwHrvheiBpk/w==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.0-alpha.6.tgz","fileCount":809,"unpackedSize":2286644,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJegi6/CRA9TVsSAnZWagAAq8MP/j0XhlEUgXChKsLVDwSX\nhLkTU0UHXTwotBwU9a8Av2u9HoNqfEEWpS/wucRESensbGqGmQV/OfqGS8h5\nV1J3jmNCwuJX7c03+S/UbcIytp9MLeCe118zBwMQzoRAzt3FbO67RiPDwGJD\na/k7vKtrAAYZHUkGEopa+8zzdOliYRCKQfVLy3BD1W7PcVNE3VAxnjApeqkK\ntTR4lfirNntdazOjiMihbxA+fkRek3nc8czDPY/uXZxAjZTJQYGF/pQ7e6/l\nzJp7IR+IuM1/plhlfMmj5SHmdcwZL8ofv3+Cvalv5X+PKTDs0yPjOgtXjNa4\nSs+uzQbItwmh0rbgKKyHF303kuaauuDdfjLwVCisQ6YRbniLXa6sIWMYw3x5\n+wFr96ae2jgesa9yzensdR6vtjVo9TiB67yFMk8hxUTPnc/W5/LadvVaWfJ4\npoFHdlGQjWNMc6aeD/ICobtT0fJgR0PiuR+TT0cDiK8RpLrAzxaVCSUvTIzT\noDqbmIMfZwS38kbw1zUttx7p8jD3eT9Z7DOS4f0aFEvhPDY0xlFP0w/qUu32\n8xTJ/MCviyMVeGoI2G/c/htMAJ9GBbX4ucqsrwqhB0FPZGk4PL6YAFQG0FeI\neMceAj1BlfsgodOoGlsg5v9RBpBjwe5Yg2s/0/q35YCJ1K2OCfW9fHyKO+5T\nbG/L\r\n=hP2I\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIBZqjT59pBaKpqawsqzhWdKCCDg9f8jhMksLqtjXjlYmAiEA9AVCHkGw0HOpfTn+66Usx/AzTfKYSz1Rm6y0raUL0Fw="}]},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.0-alpha.6_1585589951052_0.49118753990221387"},"_hasShrinkwrap":false},"0.1.0-alpha.7":{"name":"expo-notifications","version":"0.1.0-alpha.7","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"*","expo-constants":"*","unimodules-permissions-interface":"*"},"peerDependencies":{"expo-application":"*","expo-constants":"*"},"gitHead":"71839983dec66421bc6e7cd2f145884d7552b733","dependencies":{"badgin":"^1.1.5","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7"},"readmeFilename":"README.md","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels.\n\n# API documentation\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasync) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistener) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscription) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistener) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistener) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistener) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscription) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeAllNotificationListeners) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandler) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasync) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasync) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasync) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasync) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasync) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`dismissNotificationAsync`](#dismissnotificationasync) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasync) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasync) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasync) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasync) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasync) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasync) -- deletes a notification channel group\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `pod install` in the `ios` directory after installing the npm package.\n\n### Configure for Android\n\nEnsure that your project is configured for Firebase (to verify if it is, check if `android/app` folder contains a `google-services.json` file).\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/versions/latest/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **deviceId (_string_)** -- The ID of the application installation. `expo-notifications` is capable of generating one for you and it defaults to it. Most probably you won't need to customize that.\n- **type (_string_)** -- Type of token sent to the server. Inferred from `devicePushToken`. Most probably you won't need to customize that.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that.\n- **baseUrl (_string_)** -- Base URL upon which the function will build a URL to which it will send the device push token. If `url` is defined, this option won't have any effect. Defaults to a production Expo backend URL. Most probably you won't need to change that.\n- **url (_string_)** -- Endpoint URL to which the function will send the device push token. Most probably you won't need to customize that. Setting `url` overrides `baseUrl`.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(notificationRequest: NotificationRequest): Promise<void>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** Please note that this does not mean that the notification will be presented. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationRequest`](#notificationrequest).\n\n#### Returns\n\nIt returns a `Promise` resolving once the notification is successfully scheduled.\n\n#### Examples\n\n##### Presenting the notification to the user\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  message: \"I'm so proud of myself!\",\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequest, trigger: NotificationTrigger): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\n1. A [`NotificationRequest`](#notificationrequest) describing the notification to be triggered.\n2. A [`NotificationTrigger`](#notificationtrigger) describing when should the notification trigger.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: \"Time's up!\",\n    message: 'Change sides!',\n  },\n  {\n    seconds: 60,\n  }\n);\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  title: 'Remember to drink water!,\n}, {\n  seconds: 60 * 20,\n  repeats: true\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst triggerDate = new Date(Date.now() + 60 * 60 * 1000);\ntriggerDate.setMinutes(0);\ntriggerDate.setSeconds(0);\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: 'Happy new hour!',\n  },\n  triggerDate\n);\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync(\n    {\n      title: 'Hey!',\n    },\n    { seconds: 5, repeats: true }\n  );\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      sound: 'default' | 'defaultCritical' | 'custom' | null;\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      sound?: 'default' | string | null;\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` and `scheduleNotificationAsync`\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> Note: If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility { UNKNOWN, PUBLIC, PRIVATE, SECRET }\n\nexport enum AndroidAudioContentType { UNKNOWN, SPEECH, MUSIC, MOVIE, SONIFICATION }\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  soundUri: string | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  soundUri?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","_id":"expo-notifications@0.1.0-alpha.7","dist":{"shasum":"2ee2ba98a633af978e5cf1fcb59907a3059d64be","integrity":"sha512-k9piYo+CUBRC9oXv1CdvYNp5QGG6B7sxXAKaLRDJzwV55rasmSd/HuH4CoXOCc3wkYzY6O4zG+ce3Uj1EtUhWQ==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.0-alpha.7.tgz","fileCount":809,"unpackedSize":2286799,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJegi/7CRA9TVsSAnZWagAAoA0P/A/9HAbZkLTfWkgyv+IZ\nVfBPSzqJVdUkgWS6N8N7eIyKCl/Z1Ul6J6XY3CJrgzTxUdVb/ra/KtyPB1Ch\n1CqYfhR/xpc2OLNFUrYDY86uUAIgiJSyK4kGhd9uhfOpja586CLQJLQT9UXy\nJMRwWmlTBNTkLVCWVpfBL9mJVSVFYj4j6aJ8o2cnpL7xmTYO+1HpKxYkQEkS\nLl7eY0jljpjc7c1GDEtb6eHQWNey7qcg/6orKjuPZlEgBcuf3QHuB2V+il/b\noEz8EEN7XDhKB8JmYNydPLEgZd+XTxNpSKHTe4OJAcRiJXDAgjGRIRBadmMo\nz5kGXE3gSw40azlP3Y67TplcsSAQdUzMKZGjw/8uIQnrNcire5npKswlVlIE\nuZhEl80E3VuDye5AQbArulk89RgSZCXQquV+OtBbu2DdCMn+w/PmOC+IEe4u\nHFcRnhmQsR5i5mwyrKpcNdfuO5IdWQrnE41drw/DGzrdrjJXQzVvaUz+f2Jg\nM0PtmhFtZY1b3gxNSdm9OrWzHy8guNEIzgnWQFNBNuYOrqTHo7p3/CiY2XHD\nNAZQpuQ57Y1BQ5Hb1re0iwNTLCCdthkgNe7yh8NhPWWBvoMnRnYDQxQMYzQJ\nbiJvcZ9iNZYa+1raHu4VHZRC/Um49ISWKfqLCzHZ9TfEjxn1IpM9ai65Mkdw\nOKt/\r\n=AD/M\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCICO4sQGstFzXzhFtNW4mfiHDz73eXYzcQFB5c21wMgGxAiADOMWVmCkjzG19zC8hbtaZXimw1qzdea5Q1THAYn4kAQ=="}]},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.0-alpha.7_1585590266516_0.6249863636079389"},"_hasShrinkwrap":false},"0.1.0-alpha.8":{"name":"expo-notifications","version":"0.1.0-alpha.8","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"71839983dec66421bc6e7cd2f145884d7552b733","dependencies":{"badgin":"^1.1.5","expo-application":"^2.1.0","expo-constants":"<10.0.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7"},"readmeFilename":"README.md","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels.\n\n# API documentation\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasync) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistener) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscription) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistener) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistener) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistener) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscription) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeAllNotificationListeners) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandler) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasync) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasync) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasync) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasync) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasync) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`dismissNotificationAsync`](#dismissnotificationasync) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasync) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasync) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasync) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasync) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasync) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasync) -- deletes a notification channel group\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `pod install` in the `ios` directory after installing the npm package.\n\n### Configure for Android\n\nEnsure that your project is configured for Firebase (to verify if it is, check if `android/app` folder contains a `google-services.json` file).\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/versions/latest/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **deviceId (_string_)** -- The ID of the application installation. `expo-notifications` is capable of generating one for you and it defaults to it. Most probably you won't need to customize that.\n- **type (_string_)** -- Type of token sent to the server. Inferred from `devicePushToken`. Most probably you won't need to customize that.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that.\n- **baseUrl (_string_)** -- Base URL upon which the function will build a URL to which it will send the device push token. If `url` is defined, this option won't have any effect. Defaults to a production Expo backend URL. Most probably you won't need to change that.\n- **url (_string_)** -- Endpoint URL to which the function will send the device push token. Most probably you won't need to customize that. Setting `url` overrides `baseUrl`.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(notificationRequest: NotificationRequest): Promise<void>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** Please note that this does not mean that the notification will be presented. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationRequest`](#notificationrequest).\n\n#### Returns\n\nIt returns a `Promise` resolving once the notification is successfully scheduled.\n\n#### Examples\n\n##### Presenting the notification to the user\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  message: \"I'm so proud of myself!\",\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequest, trigger: NotificationTrigger): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandler) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\n1. A [`NotificationRequest`](#notificationrequest) describing the notification to be triggered.\n2. A [`NotificationTrigger`](#notificationtrigger) describing when should the notification trigger.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: \"Time's up!\",\n    message: 'Change sides!',\n  },\n  {\n    seconds: 60,\n  }\n);\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  title: 'Remember to drink water!,\n}, {\n  seconds: 60 * 20,\n  repeats: true\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst triggerDate = new Date(Date.now() + 60 * 60 * 1000);\ntriggerDate.setMinutes(0);\ntriggerDate.setSeconds(0);\n\nNotifications.scheduleNotificationAsync(\n  {\n    title: 'Happy new hour!',\n  },\n  triggerDate\n);\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync(\n    {\n      title: 'Hey!',\n    },\n    { seconds: 5, repeats: true }\n  );\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      sound: 'default' | 'defaultCritical' | 'custom' | null;\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      sound?: 'default' | string | null;\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` and `scheduleNotificationAsync`\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> Note: If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility { UNKNOWN, PUBLIC, PRIVATE, SECRET }\n\nexport enum AndroidAudioContentType { UNKNOWN, SPEECH, MUSIC, MOVIE, SONIFICATION }\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  soundUri: string | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  soundUri?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","_id":"expo-notifications@0.1.0-alpha.8","dist":{"shasum":"d14599e6b2d2947ca48c2ce8ee91e689d93b1e09","integrity":"sha512-+Ys09jWpcC/fQgyjxqbIerus3gZKtRtxNDzlqDvED5XNJc4khdvu2eBCDN7ATP8MjdA3Npm8iPG4mqtHQySj5A==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.0-alpha.8.tgz","fileCount":809,"unpackedSize":2285794,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJegjR+CRA9TVsSAnZWagAAkoEP/0yExnc9l7INE1uLsJHt\nhu6QNer716GdSV269lBtjd2klCzavcsPH9IyQKFXY+Nf5epxsJrfxqeQiwXx\n/Em3UOu50txhAkknT1gpuYINcLOsoXGx28NgeW2OmeygxXrKFLTM39NKD1Vi\nCIf2DtBSYUkxJX1ig0xFqb9+MYynYFttAALhr+PhJe5xNYL3NgNdEXrEwoou\nyGGgBGsj4q3UFIdN84iyBz5ZrnmAicb8vj6+bhIpMvu9LXkY36Oc448GINzR\nRF3LC3nYGvefXp27OBe6Ue6GDpqURCf9MLFpe2y162c40hR+Is3I0yFrylD4\nAxQiF3hVmpXc0KaNhB1cG6pazRZeoGxotWwmcFp5VFCsrewbBER6wcGGYSvb\nEgP2olEB2RYP8jlvJeD7w7gqv6/I/P4mDhwNtmGc2sNv12LpbCpCOVHE/IoD\nohzev43fTeI9LjYp2P5A/4paw5qwnEVvZLJVDJRhpIpag7whBPpc6VV+BNVT\n3462rcobIbkA69CLBR1xmXKuhSVJJ/Rmqg9PBoEfMg+BJOzFs2/hjJKjaY8p\nz3VZnOTB0H9/h5ynVPDANCSIGD6wftyxSJWc25xjGuwAy+CKcUGxptIBYWYm\nXtqo9tH07Cbt2CugO5qmtzTI5k7s/aZXWIPJJoAsVfUZ3hqM0eFqCVekqRZz\nDik9\r\n=K3Gp\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIB0qhMbTTQlmmkZXIlPTvOl3FpfcrOzrmiCvP0UCYQrXAiATKds6Oyljsu1EwtRS2u7+hsYr7CAVn+EQb5/gX/xAzQ=="}]},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.0-alpha.8_1585591422162_0.32112184395149934"},"_hasShrinkwrap":false},"0.1.0":{"name":"expo-notifications","version":"0.1.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"5d00c344e2c7b1068acbec4fa3505e9dde713af6","dependencies":{"badgin":"^1.1.5","expo-application":"^2.1.0","expo-constants":"<10.0.0","expo-module-scripts":"~1.2.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7"},"_id":"expo-notifications@0.1.0","_nodeVersion":"10.17.0","_npmVersion":"6.11.3","dist":{"integrity":"sha512-Bngejs/tMdf+I5F8LopFBfjXsApl9JMO90OLqHJvm0eTaY4Do27kh3+y1LnApl1ZFuETdHg6d70l6di9gAnkqQ==","shasum":"a2fbf117739005ad54e2448ccb25f7a5180abd01","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.0.tgz","fileCount":318,"unpackedSize":504071,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeg53NCRA9TVsSAnZWagAAgwYP/0fYD7TZhFjEt9rWVtvc\nrZFDhV0Xk3lS9FyyOgPTFjfviwf0ZTQrz6GuXpJtwL0DbXHy4FsHD2rKitFW\nNcyfgFKj0t76kDq0xGGyVW8gSQWle5a4ytjne+7giVvcSYW5eq2o5Z/Sh4au\n8mvpw0gSLV29NTopS1qxJcOJdSGDcaxqb7HcO8Qqysaa3ze488o2vjCXy3xy\n0jFGVx82iABdEXhUR8l3bBAtgaydLIFNd7getvstH2VsSUyIp1/fRX+nd2IW\ncF2L+j2G2MHDuD7CmuDjuMUGlPUkWdrpfzDGnEC5wyr2MBujoVLvj5GPDUxq\nYkEuj60HB6mg6oCBBo0gk8ENtdqd4V3d2+AWcDlvqPCtKlRvngujExPUa/eI\nqqhqUhppB3UC14GXlZZazK3MDgQjSpp+Rv+jlFQ85p4CPEWGzzDW7mZpp1Tk\nTeqhYdlwNT1i5YFHmcLXF0ZdkNUcFGKZoj2QI7+Xzi9S2VrMOlUq0ji9D3f5\nJPt36QMV0v8iUsFNjGgOmHBJZf/GxafZHXEmAaoytpzJ7LuVzsEIyKEDuV8Z\nq+U1BH8os/mASQsuQUIV7PeTfUKdSe2pd8XfPHANDqLAgvQKgD2/EP9Ov/+I\nKDiGvqX/qRDJ1dXrdPAt+MpVKeG82wPEHXfovcWX5Xs5VhF+QiCIMD24H24F\nGxTC\r\n=6QLA\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIDEcyiM5+814V5OV73dECrIV3b9DgkzOPEUNLsUfp9LDAiAzLZ3DiGTk7I2M87bMpT4sAmRDnQ4pWf6L1IjWpy1zPQ=="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"esamelson","email":"eric@expo.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.0_1585683917224_0.16024810046365157"},"_hasShrinkwrap":false},"0.1.1":{"name":"expo-notifications","version":"0.1.1","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"760658eab1d3ba6ef334d9779f2c5f28dfafc286","dependencies":{"badgin":"^1.1.5","expo-application":"^2.1.0","expo-constants":"<10.0.0","expo-module-scripts":"~1.2.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7"},"_id":"expo-notifications@0.1.1","dist":{"shasum":"a4b81cb8d666fa9de15f4d1f9dba0c51800ac01a","integrity":"sha512-5ZM7naDoTvuEmjD2V75cjMwRxIE0zD+WKlJBMsaajq2pWn9nPCbPAPZBdj+j3zEQKg4n5xWBLk+eqd9+gAAMlQ==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.1.tgz","fileCount":318,"unpackedSize":504071,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeg56LCRA9TVsSAnZWagAACFoP/1hnyRK8oRz7xj2CHALv\n8/n5RCnGWvlmfv72sc7DoDlT0HjVy1RxxvjCV17mSO4fL18n4dbopR/mVMuk\nl6jEUTWopfGe9xDiL4wkqiGpoy56Gub9OSZUpa2ExbNkVyqzRmVG7Mw3z3gu\nUQdaPAF6IkYS/MofrDuziAM1SP3QDhLsA6Pr1WWc++v4n3xDOexD8Oe5dLAs\nqCe/Qintmfw/uZPgTyXZchs0EypmEMEoB7AIF21Sl6gv+Nn+uFbwCLcu4tun\ntwCLmWM++tdITBzhLxLMqbrhTuCDUVZ/hmQRVdP9EoZA10E7U2vO2SxIfewc\nIA/FDCvDM9J0B32jjbw9v/ID1OTjOzfhGi2LH/2I2WTZ9G3zKVj8rHifXi8+\njPbzijJdBwbCrK3MMYb0bPX0MDCJLaRXyrd05WvChb6HAerI5hzg0JdMIVDO\nYvQBhBtrTmToWK84PEcUGaW3JLpQzAE5qK4GAbPigdxcu9pFfSX5aqg51BtT\nJyxWsWVAUtQp2zauwO4d7pPwqy2GatPk7xONGXzbgjdP5pGY/x5LERjyEgrX\nJqdEDFUbEG8sPHGmxPj4E7UUPLHiObYMEVnCGCfzzhmvVwjbqnVBrHgB/GOA\nvUXUESPOYcOU3zSZ2DnW5FPVzArQbHWS+SvBmaLvUHpReO4OMhVF1QEaVY7M\nOgWE\r\n=yS+7\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCeAmrUm6Ce9kajg/VVPzAGUNsfmzRfRgZWdmLJEJFuwwIhAKjpcXt16a0MkSZ0pQJZdVV+fWJIomb6tetU0EQaUXc2"}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"esamelson","email":"eric@expo.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.1_1585684106893_0.3715769396747379"},"_hasShrinkwrap":false},"0.1.2-alpha.0":{"name":"expo-notifications","version":"0.1.2-alpha.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"9621baaebb4bdbf35f43ac78fb7d659dd3739ee6","dependencies":{"badgin":"^1.1.5","expo-application":"^2.1.0","expo-constants":"<10.0.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"readmeFilename":"README.md","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels.\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `pod install` in the `ios` directory after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/versions/latest/guides/native-firebase/#bare-workflow-setup).\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/versions/latest/guides/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners-void) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeallnotificationlisteners-void) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/versions/latest/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true }\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      sound: 'default' | 'defaultCritical' | 'custom' | null;\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      sound?: 'default' | string | null;\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> Note: If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  soundUri: string | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  soundUri?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","_id":"expo-notifications@0.1.2-alpha.0","dist":{"shasum":"360de56ba35abd8bc9996ab79f52167d6b8954e3","integrity":"sha512-EoAYzIR4A0KYyrrUZ9INrXcOFGr87Fp3MmzX0iDAncT2CFzjc4FbGz4c2it/7EStOVGPfGaD62/yyEgwD3zggQ==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.2-alpha.0.tgz","fileCount":319,"unpackedSize":508184,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJei08jCRA9TVsSAnZWagAAPZUQAKEaFvqBPVKq8FEBOzvA\nzvwpHkftDX6YDdmCVX31avfmJkzcGUJ4Ol8dbJCqYaEeS/kcbrr6YD+8AsyP\nuFIPnktwizLi9+tMxKJwweQA/AuQ5FG2kX8VIL1h1kdLp759wwPhQzBfnjK2\nlNHZpaFHNI2K/aYPdSsNiIFvGtVKogbtqpRKHRN/4jPGYGQNRt5kFrEHEESd\nvd2+oKYIJ1QxjCAyIAyXeh0+n0tRlrMBJ6ERe70bEcE5IG5iNhdlz8iXo6vl\nzD0exvTM34cuJ56YIIlInkG3T0ZKFr957+Cjnin6C/IPG6WlIsXgn6J/B03L\nWQhjjscss/KALqu5Zmhj99z+6jBb+7E6+NKWzhtmrI6Sr4XWq33c/l30okSz\nFmMXtfUw48gojW+DBbrH/8n5WlwhBhwQcUdR8GYKv6iLwafY+LuHffIfka2E\nFw8A0VIKGKpA49aMulxkGbxQCfFEEZL/Q5+HtVcPrsJ5xLGC0pG3yk4I/JMm\n3/GLKqiYavWV+pgjswkIZ4cCTrtsWNZTgbQO4ATnYFuzeIw6GxdvaMqJT3s8\ndr+KbT8wEVaJ+nUeBy/TmxCIQ7JOxnNxCcZmouiZwEmJyOsXVLyKC3ik/f+Q\nS1J6c6djD+VeIsVmlkT/MfA3yqNgYX9SIORj0/NpWHrXY80XfRs2nme3SVSi\noG7+\r\n=3YpZ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDUV2Mw/eVg2Y5SQ6WNYt5pkUKi6Sofh/9QBVrGN09DtgIhAOV8ImHM7zjt75VnOzSidVSL2XYgV9cl/0Fwgv8C0+tm"}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.2-alpha.0_1586188066623_0.07727229670501345"},"_hasShrinkwrap":false},"0.1.2":{"name":"expo-notifications","version":"0.1.2","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"a1e37e3512b6e92bc69b9909b4921ada15638ab3","dependencies":{"badgin":"^1.1.5","expo-application":"~2.1.1","expo-constants":"<10.0.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"_id":"expo-notifications@0.1.2","dist":{"shasum":"dba02d64f8269bb49713dff29e5c0739a754eb4f","integrity":"sha512-+zJbnkEHeX93cTc9VhwOGJBGprD4phstFaSR3J2mKhPnPKi4u4ezLzTcbMdmK62vnCJC/OE6VIlnSKGwbyEb8g==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.2.tgz","fileCount":318,"unpackedSize":505485,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJenuAjCRA9TVsSAnZWagAAH7kP/3MZmkDVZrMHVyC3tbjQ\nbUFnDbT3/TYv5fyttlOhfiWlInjdsG6yURiQwK3RnxRYwdhgKOWIbFFmFF2T\nsSgziksWzkA4SK2XkpzU4lGHVCgPaXfctk3uUvzTT6I9M35zbXviHpXuJUjD\nVidRMo1h7O2mgmefHxe+3nBgz2XqGrVraCws3fl7lA6JJ9/pfuUHRRi6k0Zl\nJUn3T0MbyDCv8pqKigIP19AiQCcfWf94xcaPSwRb0LeyV/utRYjh0RA2PP+o\nrOCZXuDv55OxwH8CfzG2mIEN7JHh01RTS2tiymvQB6aI9TBNruqnH+cAybCO\nrKBkaletpal3YH9WSGKmqLRP+kMJ4TDG6zWo9pImpzpfWNY1tFPzlgYw7rzG\nKuN7fMbOn3a2H94UyzvLUXX07L9xbX0sAcdAdsjDpXjm+4Hj/JZJf+R8g3t0\n23ifEFQzxZWJsAH1EnhkO5qIeqJt2eUm1bzat4jASQqIXhUK60/o9anYNll2\n81qC7GyyXKOXj8Wd1A005jC80yfZfG5/i1lVaE8Ih6hRpL86A7MFco4ewSXe\nNWMowuQnDYcxMIx2sN/mltjnRIjXUy5PnTM8Ga56JdLj9snmeIIXsE1ILeUj\neLDHLKVSr5+/qYX9PzEBrJ6TjRk2+s6zGnvbaD9gc5zO7BTL7YrOi91eAzgY\npT9c\r\n=TO6N\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDC/fk2V287wZFJCY7JWTNPpl9UT8Oz++7NvUYVJQg91AIgQL5qs2bN1B0qXkLiP7hSj9ev5oGdqywswbbvJEcCqRs="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.2_1587470370856_0.6314292737436487"},"_hasShrinkwrap":false},"0.1.3-rc.0":{"name":"expo-notifications","version":"0.1.3-rc.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"c5511d39fb6eb9a2a0daf21a6a65315fa1388fac","dependencies":{"badgin":"^1.1.5","expo-application":"~2.1.1","expo-constants":"<10.0.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"readmeFilename":"README.md","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels.\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `pod install` in the `ios` directory after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/versions/latest/guides/native-firebase/#bare-workflow-setup).\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/versions/latest/guides/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners-void) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeallnotificationlisteners-void) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/versions/latest/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true }\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      sound: 'default' | 'defaultCritical' | 'custom' | null;\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      sound?: 'default' | string | null;\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> Note: If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  soundUri: string | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  soundUri?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","_id":"expo-notifications@0.1.3-rc.0","dist":{"shasum":"bcae82c0d144d90a4606506a8b2397c4fed69322","integrity":"sha512-ZJKAmsPPyF2ZbF683xsBZESwFIoKKUbkTkgjnmG6lkVOfE+ewOCgl5hilxaHCbY1bBzaY91/Wa/SJO1zxQPpog==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.3-rc.0.tgz","fileCount":318,"unpackedSize":506106,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeoDXBCRA9TVsSAnZWagAATicP/RJ6cTLCJvGl5AMuovhY\nF8slugM9RQQzQddOrZgyHpzmB2MPQoD0qzbUG5wfsIVM5tt8U/qmrtqe9Gx3\nRyE3TSXAZxSrTZEuwwO8DSakXw7j5upptOKw9fRRhHFsGCSsh6+THKkVIvQi\nFnbuLnak1sVWC58krNBAUkI5iaLAy7mUZkGcJf1c5iUrggn4qUC5BU4EwURS\nb5ANtdLC2eY5rxryh96EEfESEoV6hn+SvvLwRf6z0ipsNMou9j4ka83gNpX9\nrYadg5Wt3luYRAKcVyZY83PWocq/Pm7D/1fupAFdSUx+eKIQmvAnVyDZsqiq\nhpJcLjLPFT+47NYg2aO3rfMsNAOovKvFF4BL3G7IT8WgtcyxQHViDzQ8SUHx\nx0wICqubDpYdt8QB0fmSJ2JXqlKazUCUOMt92jqeuirxYnFvioqQACpJAcK3\n+IRqkh3OPG4G13ZW6H7NebZuQkvnmMBQRFaJ5UTt++rJpicxJm1x1FwLjWBc\niBXNOJwubJOX4TFmKqAxzCMKRJbO2cCJ6hNmNlCZ8aZlUDQ2TY7iRmZJLnQ4\ncwZt1L2aLvvqLOz+yRkzWIs+Xvmtl4kTJHmo/Kr6FITv2ChzbaCK5oQMnlUy\nR5Udb9KOdf3PZuSt+2PPWpZeE4xZ4X4SLOLdZngRq9/lV8BnJ9t0HHLY5wQu\n24g2\r\n=+Yl/\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGftq9XXXiwrrcuS3ClylqvkgJ9xT9l5d0gJ3KWX2UK9AiEA2p8IjOB7lEQoY6gMo4mpSEV4SSNL2EWj0hVgD5IGMsI="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.3-rc.0_1587557824702_0.5822598310853788"},"_hasShrinkwrap":false},"0.1.3":{"name":"expo-notifications","version":"0.1.3","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"11582aa1f805cea4dde59ab83aef88e2ef18a0ad","dependencies":{"badgin":"^1.1.5","expo-application":"~2.1.1","expo-constants":"<10.0.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"_id":"expo-notifications@0.1.3","dist":{"shasum":"d0ee5e94a25a5dbf758642cd6c77ad03616bcfd9","integrity":"sha512-HXKBHcHtaT9rw88bFN5SC46vOHXEi0NigKkpM7/gn4iTmMURVjnw03L5ixXEnAL3ZMBxStgXQe3K/kTyaPK+FA==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.3.tgz","fileCount":319,"unpackedSize":507995,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeqtHbCRA9TVsSAnZWagAAJIQP/31VjhN0PUk297M7tfIh\nwpnYt4wdha43q1bzg5DYafxKXb3eMaTtoA/okGhAMfajdPyfF2zaj80LhbmV\nGKjbjeUiRF7H6nwePaOi/kE1H5REarj7SL7IzyFSayiR8bFkT//2vQ4QhXOo\nUcUKyMaZ1nbdC1K7xWPQIgcHSRu9+m6rZlBQfCl9Mr3qOdnzj8HM5Zspsv5h\nUyWtBr8IJdSQGandwzcewQBL+EXgPnhpIEjAkbeWq6V5mjaMC+oo1htr9tpu\nBcKEcUGHXJwMehIGs5UIMgB/mHYpDJNr8+b9uKl1MzQtCj1zkbLkQlWgi9JJ\nwua7dqnt0CKPBMC4I00Hmr7LbwG6o0xPWgq1pG0DaDinDxqbOO5YbyQuRF2s\nhE6Wuh2Frj5u9M9h3iuRENAfIwGPZfnWuHQBHKJCbB36hWmD6JX6fkqAO+/n\nDXNoPj67cc0aV5xzz09drk9BmpZrUqYjANWBnilgZBYZUfUfxMHYWAzWc4vN\nI10eiq0uzbvmXj+67iqI1siz7xtZeOsuUL/8LgaRm3vEuLpeaCPmqYVzBHa5\n+kQC5gI+XY5uB7DZ1iMwR8YknkfDoQ/TAZmbCQHBDllcUet/XZfqhJeJGPkp\n78GvGIoUHG/8HK8IDvmioirGoqQvxeW0nFYNqeqoO/VaL9DJtV5gHdgLmXD1\n345F\r\n=RQDe\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDIzrFwfaiaPe/syH3IXO56FwOkAToNU/J2fBnUsIRVhAIgKWs1Kb0yWyJs8kINTEynRelXdJX+3HVZWT/l46kXcHQ="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.3_1588253146509_0.5036655145318387"},"_hasShrinkwrap":false},"0.1.4":{"name":"expo-notifications","version":"0.1.4","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"824a2d639389655e67825fab5a4bc19d217ab951","dependencies":{"badgin":"^1.1.5","expo-application":"~2.1.1","expo-constants":"<10.0.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"_id":"expo-notifications@0.1.4","dist":{"shasum":"4e2ce18f8e718c0fc9a9129a423f1cf7f7eff3bd","integrity":"sha512-y4pMuC9IKy6NLbUbfaGcERmSXFlomeB5cUA020k087TMmk4S/cvyFACFqZTI/JfFa5DXcYzSYmf7/UIkp3O0qA==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.4.tgz","fileCount":319,"unpackedSize":514785,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJer/NJCRA9TVsSAnZWagAAf7wQAKGP8Tn594LKOerek6oH\nmA1a9TiP7TwzJV27SUibTlmw7+fcYYgqYY4AV/Dx8Q3PQhBezsXVrpVJpCz2\nsPsNzh0kQcEGLYk8ccGE3uTA1DUgkQl9MFyKTRaYifQFJ7B3ETBWdQiJXB1u\nvnmYZevsTuzL6Ye7CD1Mtkm1tXehRFn3zGUazaYVIdUwGFW2N2qGxU7us8vk\nvOkqF4KxXjCotcae3MyELNzK3ZXNeC9r8/HW75ofvw+ahak7PyyjOc9CkEXx\nSY356k3Oo4b5SVmuIAPAE+3EwsxUcFC3bBHQq4PF4yjOytWh5Ju8Uk1ZXBLZ\n8sQKiFq6BW0iJxqujqIuOjKbZbGGBSwgHWpkCro8hhaOfYHQpVDk9TFuB/iB\n8fIDBZQjEdEAjwqBjiJvLteHh1vEU19izKkPSeoUsDe9r8va3NhDZIyEbzQV\nnqNLua7D8x04j+jSl2YLqSSDC64lmVxNjBl0QGEzlSc4RCxY7wubd3OxFq4u\nXKxXojOgjR7OK/6IWdVNkY/S44HFBM3Zv0mN5Wh5L2Mp+VpHGijuD8Mp48pU\n2oyMEEGrPfF08xjV9IuVMzl/JwzUE/QymGYXtynwW8fkrJbsBsFc3ZILUg6D\ninYb0APM5KR90zsHB9AmRpM6QjZhnFm7la4/G5VB7uvs5Oa848XzIjbaSj4w\nzWQN\r\n=jan9\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBOI4uIA04Xe45AMSFQn9BlXEA8zF5NHUQ8ALNuwZlXyAiACicMI3L/KdPjT3JqeqiSy/2ZHN3tUT4mwG4kU6YcdyQ=="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.4_1588589384615_0.7755060496802395"},"_hasShrinkwrap":false},"0.1.5":{"name":"expo-notifications","version":"0.1.5","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"92582ebd872c34b9446d08128f7fe6b11657ec86","dependencies":{"@unimodules/core":">=5.1.1","badgin":"^1.1.5","expo-application":"~2.1.1","expo-constants":"<10.0.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"_id":"expo-notifications@0.1.5","dist":{"shasum":"0a407b3e0738799dfe899eccacdfcaccdc6c6aa8","integrity":"sha512-Reh5koJWNu1p3CbkzQALN6hyDA+7MSD+QoBBMbhYyvchb+IRPy/KFrRVIC4aZeutA0W2dkr6gHnxJfaJjekpaA==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.5.tgz","fileCount":319,"unpackedSize":515850,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJesW2DCRA9TVsSAnZWagAAI4EP/jdJDmsgsukbYML+6VlL\nenyLl3HdH2b02AB8mAjOWQipje+M18G9u9QAzM0lC/G2dapkj8RVumPdAk9B\nyTG+01Og56ntoM1KwP+DAZom618UlvhwDqAN1QkmSZGhhn2DE4CFmAg3a1qY\n8pqX/lk3614KeMR8N0cSLRVMbTHx9u2fwYN0l4a/Gcj0vKNmNpcD9p6W7DeO\n2WTEqWSPtZTndUMX/9lTsilo35t+yCnvtRhTkuGF2MeySrFQvl1U1yzjoKQS\nQQwWIEFEa/UfXgtJWC9jSM1IKf4/jkOY/5beSLcW8ZknrtqEKd3yGd5rouSf\nffK25dMrarRbKwfRyMA0u1uWBLllUYanBQy8IOdd05pkiuoclj3KAAk3r+xQ\nsbebX18rcyye8z5J34c1Q719eM0tGufiFExTk+eCVk2jePS9FuLQbIGwlDFV\nBJ0YbyFqMZ3rfJ7YRLqPzck4UdG8pD0zgQft9A6Q+49FTQgeX139i5Bhgban\nXXFZ5TKmtvD8rtbFwBFXQnJ6PlQa9JzgfZAk1i+tt6w/h+wchv6R/YK4VdLN\naWoel1y7NwMLEh+IpgfgKrrt8v8a15krr7GpDu5U5xCtTux87U2ZMPenmkMv\n4g3Z/oawv0AFJhFRP9TU8I2NSCEuM0ItpO7z1o5IJOxw5oC0Ir9aI54v+/sM\nuNCx\r\n=5RxK\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIB1uh30ZEr1tUNwLwFEASCj2xBY5owyZysR/jXcwIepDAiEAqm8y+tSykROpzEcTA+5iI3/jMPeUD2wWlZtGUE6Z1ww="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.5_1588686210618_0.7079027994874545"},"_hasShrinkwrap":false},"0.1.6":{"name":"expo-notifications","version":"0.1.6","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"5a58a408ddb1c0019dce4a1612bc766916ee010a","dependencies":{"@unimodules/core":"~5.1.2","badgin":"^1.1.5","expo-application":"~2.1.1","expo-constants":"<10.0.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"_id":"expo-notifications@0.1.6","dist":{"shasum":"4d8ba070382eac5e9fc2482b8e7186a05cfc300b","integrity":"sha512-agxHAU9BTNMn/d3d43TiS4wHj6ZisNJw++lg+DL+NSiXc+WKWLq1J+4C/lpoAuXMgxMW/GTiRYJcubhWdhH+Qg==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.6.tgz","fileCount":319,"unpackedSize":516445,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJesZjGCRA9TVsSAnZWagAApjcP/1v+0B9NxgXucKl8A7Nt\n21fJuAA5ikZknZkxrPBCacMC9RuYtleo2CsAbrq82M7sn2r816ldCmmg6Etg\nCch7xcro6RlrUX3r5/Tq+Zovl7NhPl5IfZBPgQ0EgToZXp8o9e9uNKPIAORJ\nxx5TVPADW3a3Kn71N6sZE7DnBXXOF/9/EGz1iHO25fIac9PwdZHDm8AnmEoD\noibay3plwTttPVorikzuxMsNKGvcYtd3FYOV3rMJbqllSYn+1sFiI5TkZsJ9\ncRXhjpdwaAy79sE4OQw7Juz9EAhfw989Yx4fOVaGIxCb6Od/3YDsw9DzltaC\nxxFZPG62YfVeVqtDq4otw6GL/LtDyaY3/KyK9YcNR2wJGamN5YJ1nz5S1pd+\njQ78Ut//XoMuUxsS9yqqrKxfGeUKxh6PmFTy2T6H0TfBAa+y4YX14eMMm+km\n9aytKhqouZmKU9gp9zaapkclpgEuebHcU9jxhMZdtCajU9i9pfKEDS4/vFDo\niiLtJnINbY2+0KVD0vP5pwVeP4wMvLAJLNwFUxHRD4x1V8BkA3K9EfK+ZYwm\nM5bkn1nuackQ+dy8vKK38QSkNT124Zfyq2IHIYw5hkLN4eLcBIJXRHNUZtDB\nFwknriVYahvEhVv7gp/UtrK/O/D7afUdGrxbvTKGqS9vZXnHNnq1u/SfztyJ\nlKM3\r\n=fL5u\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQD3B7HSYkFEvnvg1AJ2aITfdoFawjm6k7PLyXpxLoUbXgIhALkR/hXBtxcx8kYY4oHvgwscWKzFvB+G0IdObSUoBLET"}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.6_1588697285927_0.9576485253915332"},"_hasShrinkwrap":false},"0.1.7":{"name":"expo-notifications","version":"0.1.7","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"510d930e99bf9ea3d08698b20f8bf7432fb0acea","dependencies":{"badgin":"^1.1.5","expo-application":"~2.1.1","expo-constants":"<10.0.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"_id":"expo-notifications@0.1.7","dist":{"shasum":"a0a62376f4271f7cd1403c22749af0bb0d338ad1","integrity":"sha512-yWGoCWQjQMVSMIsbhwR9pq/voAMTCgof+A7swV5uQM0X0WcfkqJMsB6Y5XMksdpkm+vEhvxRFyw0NXDso6pcjg==","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.1.7.tgz","fileCount":319,"unpackedSize":516996,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJesajECRA9TVsSAnZWagAAqXsP/2zpTYPMU7iE77x87gce\n28W5Z3ykO8t/R+hppW99mWIcJxIbgJQlgwpDEHlw6iPZUMPUdr4Mai1PAAS/\nHjIyeVDruuSsMoiF+r5z6avwsOjaa1oGs4+uOh+p1+R5TZ/g6XG1L2L7XftT\nFUshulBRDeZ3jOfG6QEh7L41G+46DXQWqFsRUDCGEpII4oK4+uJTA83sFK9h\nq05FRPq5dCH7lkonCAUw28dJr5lHj7Z5S8NLXosUwgYbYGCTJ6KE1eQOJmD3\nUwz2V44SQgiMu8Ma+oC1/KIReS8yqbEBLkzNT3IHoFPg9bIaEtWgJPDy+LD7\nxjwEdcWwOf+g1NpSy/i22AvgZfpGwCdxC86kLtJ2Ey1IvGsDJn7Hqzpqci7v\ngkq3usQCRaLWthf3fYBQE4Pewa2cbLKGyGLJpIjAkcibE7Ohttlltu/Hq8cC\nvKeobfmXNmE+WpSCtSCJmoYj0G6H+AfZR/NzssfF+geacQvUpZvG6QwHVR6e\naQ9s2iDn1MBNAgaVCenHI1dCuMY1S0YFVpjvQ1L3WYkSl7eLW0Q5YyPJ8kKt\n0f6I8zPKLwEISa0XkWWJrzW1K48jVpzQOFJSWRp4ztpRmx1jSQAU9bhywiGV\nEPPhdqr46fQp5sLinEg4N6/4EuFD0cuyGtw9wBJaOEM4KwnR4ZTZREdJrZMk\nHwCw\r\n=EeYq\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDHhciOYSJ1HJLSWKjANwrjMLv/L0tkyfgrmZMGhxM72gIhAPprGnetDnm+N07Y473inDc/8bpSb+MdqDaCfstbDck9"}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.1.7_1588701379560_0.31017450546064396"},"_hasShrinkwrap":false},"0.2.0":{"name":"expo-notifications","version":"0.2.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"gitHead":"dfc7fdb9aee4ef6fa10a9693e3d0935a2d500ae2","dependencies":{"badgin":"^1.1.5","expo-application":"~2.2.0","expo-constants":"9.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThe notification icon and the default color can be customized.\n- **To customize the icon**:\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n      1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n      2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n      3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n      4. in the end your `colors.xml` should look more or less like this:\n          ```java\n          <?xml version=\"1.0\" encoding=\"utf-8\"?>\n          <resources>\n            <color name=\"notification_icon_color\">#4630EB</color>\n          </resources>\n          ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/guides/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners-void) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeallnotificationlisteners-void) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true }\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.2.0","_nodeVersion":"14.3.0","_npmVersion":"6.14.4","dist":{"integrity":"sha512-Za7D4btHnDdxwtmj0JX7R7YINO1d62Wt8Js+XizOCg0bFh59lx+FNMxTioWfm4v/3eTuuQ8WFduDKUOLgzOqkg==","shasum":"3bc624d9dd066e1529bdc3f91d51649f0c5a4ccf","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.2.0.tgz","fileCount":320,"unpackedSize":547981,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJezo4NCRA9TVsSAnZWagAAxk8QAJf6kx05X2c//s2xRAv4\nhbwmVqMyhSATGEcrbfjTlYHqsacg5Lr0m9b7YEpRKPiByXqntvYUMPFGZ4Vt\nIxbp/Cqyew27FxgRn8Ktpop3YXQn9DYVZjb0oaKvDIuOZQINS9LkF6iSC5BH\n/fqroMRPB2hcW+zJiRFWOwK2ioHjR2fWE6EuMp7y40Zxf3x7ms+78V310GEm\nVgvDEvRd1oxmsnN2vnStnwbuJhq74QmsbdnruEYzLrSnsxdIR1XugM0qzWn+\nD7DCH+BSswmJCPCazmm92zmkTtxv/xplQrf5d7P2M0xQSzV2ldlGPzlE6T4/\nOxAiKhnH+G5FF0KYOxQYruB68uFEowzgs8tcL+b7HGQi3qkMgER78eznsevq\ndvLrYZdRC6qqJhmq1F40Xeg9FZNZwXoqM2Tch3qZ50X/NvqlJuIOJzBYQyom\niFBKIxzRFgnAWfBE0QznXzgN6vzMoSY/QzLSQlgICh1uKHf9TjEJRHyop+ql\ngg3iGijs+sCdGpHf6Itilswv4SYobEdoZ4Mej+kyqAfHcQ3UxXa3DVKKk+FN\nwbWHAmmtiRbQMD2LtOoGP5agUW+r3nCZVyfnivjQPvZFPHUX3ob12uCk14Wv\n3fQFBxZN3BzP9M+ORE1m9rIhvLmPcenxngbTR2i/k6g0XRfPBbOwoz6g9P3G\nAwrB\r\n=nLUt\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCMq6aRMAzRs1qPdWxBhTMj3gU/9z5XgNVsGZiBVh2SuQIhAMSQY3NiO1eX99jXIVqcBYKsCio9haJ/VaE4spArLKcA"}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"tsapeta","email":"sapeta.tomasz@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.2.0_1590595085459_0.08971757911472666"},"_hasShrinkwrap":false},"0.3.0":{"name":"expo-notifications","version":"0.3.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"badgin":"^1.1.5","expo-application":"~2.2.1","expo-constants":"9.1.1","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"gitHead":"264a8722e01eb91cf1ec20eb5bdd09dd26fb829d","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThe notification icon and the default color can be customized.\n- **To customize the icon**:\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n      1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n      2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n      3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n      4. in the end your `colors.xml` should look more or less like this:\n          ```java\n          <?xml version=\"1.0\" encoding=\"utf-8\"?>\n          <resources>\n            <color name=\"notification_icon_color\">#4630EB</color>\n          </resources>\n          ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/guides/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners-void) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeallnotificationlisteners-void) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true }\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.3.0","_nodeVersion":"12.13.1","_npmVersion":"6.12.1","dist":{"integrity":"sha512-NkVwjOlh0011ii1HASfgzaZdsEMDkDV+QuK2iMrLfmg34TCTdz3ISOxpAee77N5HyepyNUi9CIzIyQjHjxLETg==","shasum":"ced62886492c35f1de9787f8642c91635df7f1ff","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.3.0.tgz","fileCount":324,"unpackedSize":558041,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe0AKVCRA9TVsSAnZWagAAkHAP/R7lNmSIO0OmPfLs8mdM\nM+nlXAe+5XZrQJUeaQCByL2qaevTKJ0Ip2V8zaBOkSkjSq3c6mMQjheA/QdD\nu+NtnDtkFf+Sp0FttQ7/1ZAOlhA+1Y7e3aZk8JUi0Ul+liLRU0PqTiityKGK\nFmiG6SpUI35/0/XjwndDx3oA0JQ8+YAwhIbM2KglWSqV9ivk5g2uOdLOOlo2\nJ+uIHqSDl/lfJ9fK+Yrl85MYn8GPynLc1HQ47B/Pn9EnulcgZtHknMCgvBfA\nVnJQ8eSKz9KFOVz6JZ2/oS6Po/wUDTZAoaRtc0SbttjATVblSDAbA6WGuQ5T\nDZXwLnyc0m/hDBWMm2eCe8W0Qhtit9+wXHrvfqqvS6Jw4nK7ZY67y32k0u/C\nKbztjtDKMJY+F4tg/MMi4o7rT3KkDs2W4hnG3V4UTISM2OhzzOrmKQeas68j\nRFpv2203z6u30JSOamy71en+UP50jpvESBJL5Ebl0WFkmjo/dn57UFd2h5rv\nXDViyN6rQeWP8ieMGO2KsrsxpUmjTN2L55c67qUjK2cpLp2++fq1fWDcHUcQ\ncAmntkBeePLrG4kLiQNsuLbhOM+ykKHPRWjMSkDP5Hxz8p9oUlBsgNVXva4W\nR0vuoJwjLPbbGdkjqS5x8HcGNNZT8AAJbRzR5aJokeKJjQ+nXEOp8Q4dVUiW\nXJIP\r\n=5qEY\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCrPkCObc1xZBcSXnFFz9RvE2l2OuHVdxaAdobbTomgdwIgFbf3Q68UGFZBW/V7m5G9H5qypOT4O3ISNsVNIki+F9E="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"esamelson","email":"eric@expo.io"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.3.0_1590690453173_0.2402028638814897"},"_hasShrinkwrap":false},"0.3.1":{"name":"expo-notifications","version":"0.3.1","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"badgin":"^1.1.5","expo-application":"~2.2.1","expo-constants":"9.1.1","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"gitHead":"10c6d2bc05d4444e172c74eb16d1bc2fb9cbd1b1","_id":"expo-notifications@0.3.1","_nodeVersion":"12.7.0","_npmVersion":"6.10.0","dist":{"integrity":"sha512-KRwI5+i37V6HjHHfMZnNbx/Z+dtzxwTHXiuPaDfAzWwWdPmVZ+nQcmTt/M4xHfouoNi0OZgCQvldeIIdaMpXBg==","shasum":"5b8ac3c5211ddf0833539f1b3458f16f00b194b9","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.3.1.tgz","fileCount":324,"unpackedSize":564011,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe19i1CRA9TVsSAnZWagAAx2EP/jW05tGC92N6yeoY/Rm9\nbSdL6qpIAv5v8UXiFbj3XhfniXkyhOElOwIxFtEKnJdFk7VL3Q1mA9+37Dki\n+9sXNA6mJ15KBDhPbc2YECesCXwaTRhl2rx/xKUFxvC3VSfNfSne8oxY3KCt\n20ydzMFNlsU3KKzQXF6U/gyU0+iA8fIJbd9uEr1mYGZYizmuqjtl7C89vTWj\nQT4nMYCbTyN2d8a70HXTFRYJ9rDDdo1Puu3A7dP7cx9/YF7nXbpqFLXhZ4wp\nf2X+0sglKMaX2I3ed/CTqv7E7Psgb8oibdxgDtt28RoMJj4g9i5bFRYRoTYS\nYEb8LOfk41hL3L9Zbz8hCESOHL06yfLTWVf2uwVcsEAFY6Hu3258fwsfWrRd\nEqLCypzncuPTWmQ63g9Xg6a5lmRHOziRMbZ1pVFCNEWLzKCI5hbQp93dKjor\nt51j+4fChCRmQ2OlScD9wUS8poFLrDWcQdaVgyl8XZ6xAQ3iAHRsQdkGqBo+\nkc2DAkjYglemRPO+aKtxMNO9CTsuPFnEK82IiFlAKL8+ob5GF+sSA1rKYyFT\n6MJJZHq4ArYWhTFKZjPFCAh/SADqctf5+uUgqlhpLCMzB5okLL4GX005zxex\nQLpW33VT+wGJQue8MkbqGyDPiMqtYa7t88EViL9MR9nfJ8SyuFHLOVko8UnD\nZ4mb\r\n=exnS\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCPUyITmpraDS7qD7sZS8yX1g6SHFIv+XGGwvJ+BHBszgIhANlkryiVrF8ZXWJnfZNTbz+nJER3FWOK9gcKwJiYegVc"}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"me@bycedric.com","name":"bycedric"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.3.1_1591204020472_0.31221265842863355"},"_hasShrinkwrap":false},"0.3.2":{"name":"expo-notifications","version":"0.3.2","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"badgin":"^1.1.5","expo-application":"~2.2.1","expo-constants":"9.1.1","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"gitHead":"c771da9301b62081970b2ff6af5606ded4e01101","_id":"expo-notifications@0.3.2","_nodeVersion":"12.7.0","_npmVersion":"6.10.0","dist":{"integrity":"sha512-4hnQu5/rCDztXH06gsqHVKETcBWRAiRFm96frt+jh4yUfTCEOYPE1mLd3SVmcrNG0TTgVg6L+FVajtq1BtPkZw==","shasum":"ffac63ff814e9fa5fd1e51d8a0aa49c08cf2e860","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.3.2.tgz","fileCount":324,"unpackedSize":564288,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe4MPPCRA9TVsSAnZWagAA7WIQAJbMnmzkrz5E0547Zi8K\n+R9Gs/Gq4vLAcXVs1gYtp375Z1OizCu9B7NF+F5SqUk/WpW/MMJVynB4SME1\nAhd2XFZl70EY6OPyjXwpvN8Yf2cwPeo/xp0okhTGQ0Wv7c+JL22Oo2KI7J4y\nrtZZ2ODCNlvMQOgYknmiwqRtpZdHCqeC7stTiWoi38D8enDE0dQFBr8+IWzn\nK8G0uLCdqDUoIKa8y7be2luiBmeaFxqtA2JMMloSr6cDnujEYyeRzudXhCw+\nFPrkZPScMR/yLZo6wS9uzA4OLHDofdeUNeS5v71dmwkc8t/Is2Gl+H7cfV17\nbiFBw0WLtACl/QeoD3Wq7Onb1Rv2ylNxKMkDv6z12ooov8rlxfSijI1aFo1G\nYiQS+vXS4j85S4FGgH/vr58x/RbO7t1oGo0fuIYVpT2PxKgQxBI4csECmR4k\nj3MymVKIwWtBcUJm+vmxYr9s7/1gN/CqP6Oy2lPGbZFvmqTxbxUcV9uOWjjV\nGjp7LDA0pIicDmZ3PSEboS4HwmeMy39m7hjCtQKQ3Sf1c33bTd/b1uDnGNBF\nnE9ViCyT/ni498GNKkzgoqofKtya3a6HQRLrxXLDD3DniBYkBPz6liy5fCA2\nQgmnUXD9KFR5CjS4HZoO6RiIK4Q0a1qUajTDHgEKN48d5WikJhZ3JGxiSDXX\nBdZA\r\n=TB2X\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGa4zDtdXtE9IYcE96CTgfI/XglUGt/zBxtZpQ5nWO6uAiBHXHJGgbll96MtulehbSd60e7ssblWFc1LStPT7gBP2A=="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"me@bycedric.com","name":"bycedric"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"sjchmiela","email":"sjchmiela@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.3.2_1591788495043_0.97386839655658"},"_hasShrinkwrap":false},"0.4.0":{"name":"expo-notifications","version":"0.4.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"badgin":"^1.1.5","expo-application":"~2.2.1","expo-constants":"9.1.1","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"gitHead":"6597b78a4ac955e721b08bd3ac75aebb0f2c7d9e","_id":"expo-notifications@0.4.0","_nodeVersion":"14.3.0","_npmVersion":"6.14.5","dist":{"integrity":"sha512-x9vvRo/S5ui0GSEUkICa5TXRuhpAD4FeJPxs34oYtopprQsoHprobg5MPd5wPDzbxY/lRUeNceRcdYSS6FqzTA==","shasum":"32e2949ebad528463932f53c8983ab07e8c7ae4d","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.4.0.tgz","fileCount":385,"unpackedSize":587989,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe88qoCRA9TVsSAnZWagAAOGsP/jyKGqkDdeQGvk6WS+Yi\nzRudAR1FCCP2+bhJ27v1Xqrk2bLfeBS+T14DIFM3Ll8HgTZjhI8nnuK1hZCm\n9kSOaJsR1YloxbNfsUYYJmid2qpsGZVmGV6PQ3LvA5OOGmvllkolllF3Qr+o\nfmRWVLiwIDz8vvYwornnokfKOFzMSCBl4Uzt4GLsx2RNj8Mayo/QyugdFwDH\ne6h+iaQHuLG5o4+lmVUpNj5h/Os5iMJt7eCEPFsuhCVOUCA2IoXDXW4pHzRa\nN9Uol1Jx3sBdO5/a91gKeBbxDesYMO7WPIotWw8ou8IFElCdcLphonvZZz7b\nWnVW9kbD/kWP07ZA+h9FsmUnd05ZWhUC2OBFu4NtRkoo0dOGBV9nB/5TZt9K\nbVbMhzIgKoJqIoz6lp/r1NS6IlKzAhj+iNGUFepeYH3qEH1VNCCcMgXiTXQn\nb594XxY0BrvrEZOlXTOtSYIUjyApyV+4R+gs2SXt/yisnVucGihsaFiG9BmW\nJQ09w8JzcZBOY6UuqsbzyhWKFaiHPROLk1fNhXz2O1uNBkHLOODJfV3AyDD+\n+Eo4zUS6QCDp8TcMB78Tprr7z09LJrF8WbAN1uWVY1UmSEgDlSpFwS/q5ntV\nATt4gWleheOnUqYh99uRX/P+TYjhhmgz8UzQLDbBlNLGLsWnyMUY0vtrvLzY\n2YRL\r\n=xtNx\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDloLAl1QLEGsUIxT/i41AfieHn4jKia0swMhZa5uPxhAIgaRL5MpcvnREtTe1OW5F2oNjaej5I/KV3JG1toJp6YiE="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"me@bycedric.com","name":"bycedric"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"tsapeta","email":"npm@tsapeta.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.4.0_1593035431616_0.7590737246337502"},"_hasShrinkwrap":false},"0.3.3":{"name":"expo-notifications","version":"0.3.3","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"badgin":"^1.1.5","expo-application":"~2.2.1","expo-constants":"9.1.1","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"gitHead":"343ca1fa3ca79d153504c51fde793e6cf757c8b8","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThe notification icon and the default color can be customized.\n- **To customize the icon**:\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n      1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n      2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n      3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n      4. in the end your `colors.xml` should look more or less like this:\n          ```java\n          <?xml version=\"1.0\" encoding=\"utf-8\"?>\n          <resources>\n            <color name=\"notification_icon_color\">#4630EB</color>\n          </resources>\n          ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/guides/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners-void) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeallnotificationlisteners-void) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true }\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number;\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.3.3","_nodeVersion":"14.3.0","_npmVersion":"6.14.5","dist":{"integrity":"sha512-iBqvlbB6UVkU5yF4W9K/sqdPIbJ52VVeL7543G4IA3ARWhx6wdhfzcuGTCtUgV0XmkJu7vmPs+sC31aXjRa0Kg==","shasum":"3c7b7275516028853e02f5c796e3365d4fb572ad","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.3.3.tgz","fileCount":385,"unpackedSize":587278,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe89EgCRA9TVsSAnZWagAAIgIP/3LLjE4mPnjUcZMkIUaI\nJO666bV3X7cXJZKig7NdWgcRCNh6inxoupYE/NRXQEWb7WSmNmMTwlq/z88H\nGejv7SIUCEP6WOVcGE9fm/xvgl3sVnk/mP/1l4c8lDQK0uqTZCd/orov+e2a\nwD9zKku712+gselA+pLFeAXhhp/1/kPacp4iBe+5i47My87hrlBf1YLLhdm+\ntz8WZnV7o5mxG0ncX/HvTetl6UWTde4NY9DOfbmHJojadmUwJPG2UUSL7LPB\nQZkGNdD79u5WYNReVCM9dB48r5vLarpy6DA9udzmB+gR4HY9QDrx78vkUkMK\npyR5hwppAgKHkAbxrrDUTfodpfuapjxCN2u1+F0DSI6tbyHZZzFoUOH7+Efw\n9O9kDCYJXYi6TUlrFx5ZChjpxlnZ3HTEvMm3U5mwpKyahYDj74IaR3jRcYWw\np9ifVpnmIHsQuVkE/s953vU1v0xUd9UlVrZfpAZXyIJxlrtbtDcwRChLjjxP\nzTLJRe2j3w+abOpeHkLvpVxOY//0LVzrx208bOQ1dEIgmZNgIikynCEv4LaC\ng0ir58vGrEivdHLlktz2YwaOrQyLkA/QGgvRLSi6MG9/IEA0uGT8VYc584LA\nJrJYKSpH1Agnx19hxE7++1vMJjGDaubQLbu8jtysjtRH0EODJT7NRgNwa5PU\nRoVJ\r\n=9+KM\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC81mze1GuUsUR+m+NWi9l0hr2VLX0SFMZYL3Xf7TxQtQIhAOxYOrVgdcAx4KmXsyTovf8bxfMXiBh13bv5h6v5ms1s"}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"me@bycedric.com","name":"bycedric"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"tsapeta","email":"npm@tsapeta.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.3.3_1593037088247_0.1398688538517836"},"_hasShrinkwrap":false},"0.5.0":{"name":"expo-notifications","version":"0.5.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"badgin":"^1.1.5","expo-application":"~2.2.1","expo-constants":"9.1.1","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"gitHead":"1bf7e487c9ef2569c105578edcf935a3e1caad6b","_id":"expo-notifications@0.5.0","_nodeVersion":"14.3.0","_npmVersion":"6.14.5","dist":{"integrity":"sha512-kiBErnMQRQ9G5N+d5IqnDs2LRHcv4ZZNAvjTj6HhxUYV6vywOg4Fjrvik/4uidazeMxmqC1BkdghQx3kx6p1yw==","shasum":"c3b6a681d6db2992be87a8cf252d44675bed81b5","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.5.0.tgz","fileCount":394,"unpackedSize":609079,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfHn52CRA9TVsSAnZWagAAwF8P/jAub0ypXrF6ygF6qv8D\neaXGNJXXoG+8OxlXXaXl3gkPKluDOAPnD6Ec1X3rYuIpN4uhNzEQuK5JtRDw\nyfZAdfyXgXkfgzux+yUSj5TWOSFEp1UIdGRmjxIwTuxA9tDGtcT1WhdeeKdg\nREWjv/fjm1ZtjcF7bbV5vlctSx9bMptRWeu24mCjtlcW/+Vby1s/+Uo5+5h3\n536Or1wQmqBfQoVRJtybOS5AifxGtWud3zTuvtvBELrKqKM0J12NH9VU40tD\nNKhy6gQ6fEA64LDCIpHTnkdlb7Y2+nM2+QRSu/GfVycRc5QdD9+QI9UIw/PL\nwBEsqUb1OmOVG++FGOwpmRukY42GlvZzLJBjEwLo6SXMtD1UrbfdcX/7MfgQ\n9dAH5eEb3HZY/2mvNaWwj5XEuetrNAK62ur06leRWI1m7G34969AH+3ku//Z\nkjom0qcBjrW8Nabt210tqJaeWyRQnRsvp1hZV8LRVElGullnnTejFpFbeqxO\nUT6nlKdfgydl19DTIuo82oWGC3TiU3t1z03BwqXr4zBPxDxqf3oX0+xbt3n+\n82IBU5ZIZmtjtIvONk5n6QV8vGir2JSs2ukJHt7O/0Vd+HYQ1vtzfQqSyzsV\nZPixlC9MYc9VErYFNiyHQoRMRohZ961f0YY+Ml6np2o60Si2siMs3MIVRMot\nY8zX\r\n=71NN\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIDPMwoZiG+3H22uQVyOyJYauDiJNBB9Bvp1QFVVxuCXSAiAGcNX6sjcqqGBsTEzzAwDHSl5EizfAF7IZSiAmmAffCg=="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"me@bycedric.com","name":"bycedric"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"tsapeta","email":"npm@tsapeta.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.5.0_1595833974241_0.8512401760184829"},"_hasShrinkwrap":false},"0.6.0":{"name":"expo-notifications","version":"0.6.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"badgin":"^1.1.5","expo-application":"~2.2.1","expo-constants":"9.1.1","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"gitHead":"72de77b94403abba70dff9ac720991b2c522a9a0","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThe notification icon and the default color can be customized.\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners-void) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeallnotificationlisteners-void) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggereed. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncment`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.6.0","_nodeVersion":"14.3.0","_npmVersion":"6.14.5","dist":{"integrity":"sha512-dNtzmqk7iyUNKTEC+BPLt3QwATYljDulHApGmKyNTgd9B4OYdLaRh+FOJyAziJ/jL8IaYMPJO1PHd0YErx76YA==","shasum":"be6785f24398f04181515171af8898acaa88c838","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.6.0.tgz","fileCount":429,"unpackedSize":689803,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfIYHYCRA9TVsSAnZWagAA9f8P/jsnevlSqzssLp5Ux4W9\nBFu2u1OXqbFCrcIc/7fOFdC+nAklEqF/94c8izm9b4QCbN83bR+mreEMqCoM\nW8gvRaCLUsGS/N1yWRYMFSm/7PZVvNpd70J3TeJS0/BMsOwpjLsGTU4Jma6h\nXdWY9Ypw7IJCVVjhP2bZPLxi1/5LPlmnD5a/lQrYQWuzo+qWTVK1dvkUEAeP\nSSxJSSznKqNJkSaS0iL4nuVUoHNRSjhHbxY83n1k8cB5CBdb3fz8TwduGWT2\na39mgwTS+ZrgHyIah/j8jnP2uS5PXvrFQDfwbVryOr1QFMhpw8FG3O687KXC\nopmEPx3jtm9HZsOSaT9bz48+zZRoQSOH5wXVtWQDGHRvgCYo0BGxaWZeCevn\nEQd4l1h6DPrGqzL1+j9akU3H7YK8CIX14QhDhG4bSycUanO6nh1W7CglrsMR\nQdrhBMIog0PXqR54AjgFKtnBaUNRcgXMB0XJqIkTDXP0/5OpBF8+YSAyQO4v\nhIOrf+NF/sqqJtXyrSVy2Cnkiw6J1OzPL03fVGx926dpVPK1nqe0M0c/s3QO\n44yOCIyg8u9NBOQqCYaMnkAW55YJN2OJTjWhx9IN7E+qBeJ1LVNlRgxJpcD0\ndTp10ncbt4L6yYvsH2i13Smcjt0+cuApSj/V1By7dTUyCgY+WfZklPL6FhWw\nTWUa\r\n=1k/i\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIHnZQ2LkVJGVZ1WEhlrpjgVdrBW0IUPFLa+QYS0WfpviAiB+E4jwXIRjla8Bc1e17NN6V3maIr7+TtKXunz36nWZwA=="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"me@bycedric.com","name":"bycedric"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"tsapeta","email":"npm@tsapeta.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.6.0_1596031447242_0.7707146480917066"},"_hasShrinkwrap":false},"0.7.0":{"name":"expo-notifications","version":"0.7.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"badgin":"^1.1.5","expo-application":"~2.3.0","expo-constants":"9.2.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"gitHead":"2196cebae55bda181ccceadec809942f51ee9e39","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nThis library is not yet usable within managed projects &mdash; it is likely to be included in an upcoming Expo SDK release.\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\nThe notification icon and the default color can be customized.\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners-void) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeallnotificationlisteners-void) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncment`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.7.0","_nodeVersion":"12.16.1","_npmVersion":"6.13.4","dist":{"integrity":"sha512-+XfRsmhWeXnYW8HcRYRcCRxjiBjow6bwW9tQRTfjsAmBBy7tdZSstwW3jQxIPWOIXP8QAyYRLRIFUMLrwhlKBQ==","shasum":"7b2ae47b1af219e6ec73c01b86e59c7cd4b791d4","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.7.0.tgz","fileCount":435,"unpackedSize":690173,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfO+jOCRA9TVsSAnZWagAAWC8P/RWfT/x8sGLWVgLPwY33\ndFlVojcRR3vfsC7Q/Ks25fGIo9epnVNgnQqDBFSH3vA5qt12ybVrx6e6Okp6\nAh6XG7UZvYB2t1Gir3+XoqZSQvqt+uNWLzQVrfZs47be71VIus0ilUV5Pgma\nnl9Ep0YiX6b8DFfHkXW8HwVOv/yoaSDhTtVWqx4s+Y0QQb0MVKTDkTaNSTca\n7rHh9Kmx5rgcn5DdmSeBJb8U/oiLy+lgqhvOqWJG4BundtHaRMtJ5gdvLr15\nIZsV1PEkLpnwuWF28X/xR/oNF6AqVc9S7cs3Juno6vx9AMOvkCh5H+47OCf8\nsn0qkU9j5inv4SPo4HPk/WvW6nl8SvgRNGlXA5/BEY2/4D4fDBoWztAKBzQp\n4R9ws8wJfjL1sCPh/SkuXDJKyhWsrcPBzcoqrk19PlmyssgAkSDzAyFqdOjq\nG0yfRtOxG1Dy9w2EwnUGa1lLUegUy0iS7rL8BidTDIVYi8i6N6NICJWQXFe5\nzH7SfWkwGJgV4Ng0fs9YaqxNPC7UreOR1GNtnsHUiT66oqUX1/ONzLH/uW6M\nUOO8bn0Wjb1EFOOuFYlPcGjPFRPRcPg4C3vg/loGBs3Af9ii9NGIJtHqi27s\njHmHk8a/M0w5HWuPZOXoa5bHW36L2e6lIQC8D6tUlKjcknNrm2DrLkRE9Tek\n57Ns\r\n=5vjE\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICZDBAfAizQhvV+2SMFBoRgzND/ltv920MWCa/PvMxjmAiEAo1c1opg6SLQ7Rw281iJYs5KMxTXDmXD9H+J0Og+GjO0="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"me@bycedric.com","name":"bycedric"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.7.0_1597761741851_0.4187003780681984"},"_hasShrinkwrap":false},"0.7.1":{"name":"expo-notifications","version":"0.7.1","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"badgin":"^1.1.5","expo-application":"~2.3.0","expo-constants":"9.2.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"gitHead":"0b55ad5d1a6f3840af44212458120212a23134d1","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/unimodules/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\nThe notification icon and the default color can be customized.\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners-void) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n  - [`removeAllNotificationListeners`](#removeallnotificationlisteners-void) -- removes all listeners registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://expo.fyi/upload-notifications-credentials). TODO\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. You may need to define it in bare workflow, where `expo-constants` doesn't expose the manifest.\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container({ navigation }) {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, [navigation]);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n### `removeAllNotificationListeners(): void`\n\nRemoves all notification subscriptions that may have been registered with `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncment`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed.\n\n```ts\nexport interface PushNotificationTrigger {\n  type: 'push';\n  remoteMessage?: FirebaseRemoteMessage;\n}\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.7.1","_nodeVersion":"12.16.1","_npmVersion":"6.14.8","dist":{"integrity":"sha512-A1eqSwbvIfOt/N5vOQOEDs2nr3jSEaY1VY7f0CqBiXgk13wG5UTrNemozU/Lrgca/vEUs+nHp2s7Cz35w4tGUA==","shasum":"ac0eb7ad87dbe945cdac90c75bd8bd15c826aa78","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.7.1.tgz","fileCount":435,"unpackedSize":688132,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfRi/3CRA9TVsSAnZWagAA5FYP/2EYpoEMSe9JKoSkrDlf\nawItzMdSPZQ7LygzFqmTdmo/hu7ncZ2B7l+jrtMgmCsmZiY2sinZ+jO1pehh\nu2oUDCtWs0uyRRTtmgyfQ8XVVfmz0b56MBbj4XFWdHtHMG5E4zTgiOkj/PVa\n3rpbFtevJptQ1OKpoVoWSMaBd8XfRrp97Gv2ZR56/B6rZoQgLSXn3gvL2Mv7\nPvk5FybFo/kkgrF5hkE3Y0sNe+bO2QH4hQSAXt8zA5lQhUfcZZpX19ZJ8SsC\n/6gpNKIlP7Vb3B9dmH5oAC4GzEB9ctA7m7O+XO8hv7/aJq1lLZ0xwxvqDzW1\nUNBy7f//hNWshqbkrQ9ArsfwUm1sVmXGRDYxwei8w7ks42iUOdBXR3zUpoLu\n/FUWAIFE0/tNyepfbzVHo7rtLPE1wbwH8mNH+LCFbRo42G0lZ5d385lgtO0P\noFfR6Vp+aDZ1zSicB1NhE5D8ls31zkYsv6BN4hMvMPwXlekzE7z2m42VAgHy\nh8kiBRxjFVGT021VePCqQi2bL4p8i5HEEY8iNq8EYbYXxft13KMn5kJyaM6S\n9nluApDiVrRebirZ+gyHav+SzprzY6F0YxCtiflK7tzI1beKnY4k1aljYf4s\nDUkA4ZDuJuoKJTDp8pUl5Sa+D8NhZbM4dWZtLF1RztWHZLGTVNGTpFtgLd6h\nRz7f\r\n=x8VV\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDA4NtCgHkvt/RAphPiXW6RLlrkhbIQ9Wv0uVXp0brIygIgF44XF+76wDZ6UillZCmdvKD8PoSCi5jArqGd/9JjboM="}]},"maintainers":[{"email":"bartlomiejbukowski.b@gmail.com","name":"bbarthec"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"me@bycedric.com","name":"bycedric"},{"email":"ccheever@gmail.com","name":"ccheever"},{"email":"charliecruzan@gmail.com","name":"charliecruzan"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"eric@expo.io","name":"esamelson"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"support@expo.io","name":"expoadmin"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"ville.immonen@iki.fi","name":"fson"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"hrutjes@gmail.com","name":"ijzerenhein"},{"email":"jonathan@expo.io","name":"jkhales"},{"email":"czernekmichal@gmail.com","name":"mczernek"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"sapeta.tomasz@gmail.com","name":"tsapeta"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"wschurman@gmail.com","name":"wschurman"}],"_npmUser":{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.7.1_1598435318895_0.0945092567798933"},"_hasShrinkwrap":false},"0.7.2":{"name":"expo-notifications","version":"0.7.2","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://github.com/expo/expo/tree/master/packages/expo-notifications","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"badgin":"^1.1.5","expo-application":"~2.3.0","expo-constants":"9.2.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"gitHead":"a36598c63600807ae628fb5f401154f23507b0aa","_id":"expo-notifications@0.7.2","_nodeVersion":"12.16.1","_npmVersion":"6.14.8","dist":{"integrity":"sha512-a5QagTFObadEyWTDhAeHnzscLIUTIBF+iLsfKftegZjQIcv20mxu9Aom/e6OfMNg9470XV/HuuHaO9p+JaY9cg==","shasum":"2e275036c4f8cc6223a4de263117828bf253a95f","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.7.2.tgz","fileCount":435,"unpackedSize":688080,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfYxo3CRA9TVsSAnZWagAAGqgQAJ/QDBZ5ruf0Fjlg2mSf\nNlYBnv4j/QOCEXX+s7gA7axn9KQxF4L7msUzCmI3COjZhWmtweqHGtNGqcQj\nttGkNiVkowIKretusZad99HnWG1h5cjQrYaLAX14CmDUDgmnsTrqfCofIy/z\nn8jJwUJsnZL7JmU0whLnCkHUiH1GluE7vj3/jsr3qGCLmZ5PK/SkTwcmDf0t\n416L6D+/Tv3DGhJsaFJ/BNTF8+yec/gOE4XvBvPk2k5djGZRM00kh7HzFbmC\nXtaphybk8sOunG/0ocO+FRw8m3YgHi9FXaXRPFKNDAXFHaMoz3Fh6hmEDUg3\nYuxU9tp+pOchl/qB5UgrbkrAQ5W/Fv6glFGW61e6CFagVA4tsPZ9IU2FHS2W\nGMv8DBDATPDavclN8kTY2NEiOpqLRli80tcD86UnMmqD8Ai9WUY8c9zDg9gY\nSnjNSSSAFbc9vHjG+1V6+NTQjfoDO0dvVLmNu6FoCgotllf8K1WARSSPJuGu\nA6Xe6v7TjIByUbbvMhRVH8VPV3s3EZHfaZn3kC2iz0Ow3YXsShFCfXZIrzNv\nNq4eHirKb9KH452O0rB+mlD7DhdC0UQe2cYsOdJ9PPvB9Yh8iCIk9KjBb027\nZ+Eh9yTeScpGA4Qikze7kIM5qN+oTgrMocgyMCJ7YAJEDSp8rDQm+n062KY9\nMv7U\r\n=4gG6\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQD03gCYRaXGGRtdyS50OzXFzZoxexnid1FKw93C+V6kkAIgCZx2NLhoolv1LreynSUHcY2BDSn0xUINOmqv5JcyVpc="}]},"maintainers":[{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"expoadmin","email":"support@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"esamelson","email":"eric@expo.io"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"}],"_npmUser":{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},"directories":{},"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.7.2_1600330294555_0.7639477004228461"},"_hasShrinkwrap":false},"0.8.0":{"name":"expo-notifications","version":"0.8.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"badgin":"^1.1.5","expo-application":"~2.4.0","expo-constants":"9.3.0","uuid":"^3.4.0"},"devDependencies":{"@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0"},"gitHead":"bc6b4b3bc3cb5e44e477f145c72c07ed09588651","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\nThe notification icon and the default color can be customized.\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and  `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds on Android\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// Prepare the notification channel\nNotifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n  - [`removeAllPushTokenListeners`](#removeallpushtokenlisteners-void) -- removes all listeners registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n### `removeAllPushTokenListeners(): void`\n\nRemoves all push token subscriptions that may have been registered with `addPushTokenListener`.\n\n## Listening to notification events\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received \n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener (\n            (response) => {\n              const url = response.notification.request.content.data.url;\n\n              // Any custom logic to see whether the URL needs to be handled\n              //...\n\n              // Let React Navigation handle the URL\n              listener(url);\n            }\n          );\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}\n    >\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`).\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.8.0","_nodeVersion":"14.15.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-DvV+2UUmDiPl+DyA3ea4iegLZYWkSYqaMBWqDhTVkSG14savQhdpxWgUTwY2CsWlB7e3VlBKcpwEebrceq07Kg==","shasum":"a63fb9068c2b8e0a1baab2079e69854cb5460c27","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.8.0.tgz","fileCount":446,"unpackedSize":733589,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfs1i6CRA9TVsSAnZWagAAMccQAIwnUJUcsedYnZEM+xxH\nZg6HFYFdXrmeTHzAsT8RbK/J2MZVRdVm5QOkIUoxTm7CClcnYkYFpEu6iuSm\nVOZFpFqM02j3HkJcM5s8xRCViKkLKdjUJ6Cz7l1Tq5hjYSKUbylUm3Zf0ege\nMiJaheWU6E/WYILgG5a2o5ygGI9cgcxTN044iEIMzifkoEquI0guPbhxa214\nQ07mydc4XO9mOdxTcdS1WpEzLMHIj1/1GsAMCa/SyAiyjOS0ozXQ5WlDz/oY\ni2FcJqr8hsYBm4C1BrdRsBkWoqyEvmdqsrWJj5AzYRFHiVzswJlZUVFls1B+\nuIjYfZ5MnqvkSFypnT+O8lZJ4di1pShT18p9BhlFmQCm+uGK/bwKZz6wGcx1\naxgVFKcN3F2mrEsmcsoz0YkkYQ/fF2n9YeFR1BjlpludcH25yFEfyjLYjOTV\nfJqN6DL3EiVLeI3AZzTeZnTP+Pda2Y/zM4OQfujaEqp+z9ef9xnae6nVmOZJ\ni73I1ieuQjb/FqSxSobWsxt5I7HXSB3wbmy7COZSxyfaWAp454VMSxtx3YDd\nHUCaamgORpKn/i46xOhzn7Mmmw4nsWPyysuX1JRmGGzOv6xE3/lP5CEluYhf\noDjwfaJq5216GIfLgmwGZKUDk/ShSWDYZmrCmjPYvCmrCz8EwPm5BfchnQ2t\nwH4e\r\n=fpn4\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIDlZFY6EmLXRcqFOnPu4vgV+kJzBPyyNPnVO1vRqpBV5AiEAkjOg+JGJitIGcSnu0tdR5/fvVvsdYi1XzgnEcKqpueE="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"nikki93","email":"s.nikhilesh@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"expoadmin","email":"support@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"esamelson","email":"eric@expo.io"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.8.0_1605589177522_0.5107613337650903"},"_hasShrinkwrap":false},"0.8.1":{"name":"expo-notifications","version":"0.8.1","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","badgin":"^1.1.5","expo-application":"~2.4.1","expo-constants":"9.3.1","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0","node-fetch":"^2.6.1"},"readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\nThe notification icon and the default color can be customized.\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and  `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds on Android\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// Prepare the notification channel\nNotifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received \n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener (\n            (response) => {\n              const url = response.notification.request.content.data.url;\n\n              // Any custom logic to see whether the URL needs to be handled\n              //...\n\n              // Let React Navigation handle the URL\n              listener(url);\n            }\n          );\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}\n    >\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`).\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.8.1","_nodeVersion":"14.15.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-QGhP4Y/iTNbwvgsjdkoE2iQRbXcWLC9WPVWTLSkPt434Ot01M/XFoZtlLgeZyjiOm+/26IORUJus3vNG32KzEA==","shasum":"f495f78df0ae21103d41879be6f94f2cfc07ca1f","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.8.1.tgz","fileCount":455,"unpackedSize":783479,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfvuevCRA9TVsSAnZWagAAH5YP/R6GN3AjyPao6M/5F2jh\n0+go4xu+VK+xhYvceSUKWOnekHtNzDZxSZ/K5pNR61lZKdDRuarq9iS2dAQs\nE2ZU1Yx20ZDiyrYfkSxajxDKZ7SObZJqtCyVg7qIMSb/Rzpg3mEtaBv/+dkW\n15Y+W7juumb7g4p1KirMDS0zWxkVLtAWkghhPgvANrFa1Cz3jeJDbVc3IdRx\nzsrkWYmPPvg3eMI5wRslXkckAOef73mViXG4dfygTPZV7Juu8rOcafXZCfX5\nCTyu67oeDdguylVmsKMgAhMJoyubNUXddaalK7Or8X0iup+F3VewSOaMUn6c\nGhvYqob5AHsR3SwIs4FJFPZX422l6b52LGmslRw46/yNewifFUFf1pbN9X0/\nIQunR3DLDzawi4hL7oLuV8ncisn4rFYxb6raVSiXzdVbPQjvIesnqaVf1HjE\ng0GO87ZGIzGexOdAXdu5vyrHflFMc83p+F8QOO6m37aD7zJTpFh4UHY5COQe\nqk+GLmSg+EpV0fvMdDbTzK1Dpxjdqs39exkI1FWd+Ty2c34TrPb1Ovm8RiEL\nk1NeStiQDO38f96zwxMGZ7BQ2ilObEWzRjJQai/sBXYYZbvNjSi2GAWI2B6Y\nKSC2vgfpMn7pCCFE7nMc4nEBmhjrpANa2fZ5MCa8DAN5p7JC84Aw6Gp8rPnX\nEGGM\r\n=bl/k\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIE+BsOi9ZtQ8qav5J3vBwXHeMZh6wqGDIyCM5TL67TSvAiEAqt2punwpYhmhO+Ba2Mz7+QG908k6oOOB5mQSGcw6ev0="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"nikki93","email":"s.nikhilesh@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"expoadmin","email":"support@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"esamelson","email":"eric@expo.io"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.8.1_1606346670648_0.7974729411715473"},"_hasShrinkwrap":false},"0.8.2":{"name":"expo-notifications","version":"0.8.2","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":"<10.0.0","unimodules-permissions-interface":"*"},"dependencies":{"@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~2.4.1","expo-constants":"9.3.1","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0","node-fetch":"^2.6.1"},"gitHead":"9c95459d1e385bd9f279d42f25d41115823ce1da","_id":"expo-notifications@0.8.2","_nodeVersion":"14.15.0","_npmVersion":"6.14.8","dist":{"integrity":"sha512-eX/HB96FqXzSMAwtA/fhxB1tGYELQywPm7oBTfnALHH3MFHy1bW7NZYGcU82sDF+DF09uLZ4Fn4p5ValMWA5TA==","shasum":"69e04a4e48ec6bafaeb354d284fbc23c26f2d62d","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.8.2.tgz","fileCount":455,"unpackedSize":783742,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfxW4yCRA9TVsSAnZWagAAgvUP/RzuFo95x3nohWCxn7Qt\nMNHAtsFZ8RgYw2hvc3b3BDng55g12HRCLc5A+woY1HcLrFvv5/IgdDAFgK3Z\nbg0sLfb9KvYrEst8IjpZZiyeyZ46Ig4zn73mC1MJNS9bj5OH/mJj6cAY1ksH\n7yEuLAdkAzJdN5p+O3zQKsR+1mZ7AsWdTw7XvS71642LEeRQ+jZadwPA7wHb\n0ooDCfirJ1sIdT1XRULf1jIyhK9CcNp4UDSpUUGXtEwHPSa7sBEzN5HKLEH0\nuwwTlZzM775taTBqLWsLHK1hgOBStGNzPefZyoRAGgdlDRnPzapRkSTDl/qp\n0XzHxWDv8IMnJUDH7TLaQ76dwT9gKP9Wrn6ZsJg1XX7qjqeEGcK+n90VLrqL\npotNmzVlNvKXkXMV6FpHz7hai2sa5rNkBONR1dAnGkw3E2miAA/jFtHvcjP+\n8vwl0TXj9ldn3mY7eDGSwzz9EvFZoHOwPOxFY3HoKdGBnNX0f8yLDfX/MkS4\nCRpEjL6FZvlGJA0sOvpAhA/BhkRTaulYmYF9XJEwUcIVeRirAc0XCInEfU0M\nHL2inQCEx9UKS22MHunJZTlBGYQRd1BEDfT1KG6cTw563hajctDJ5Zq2DoEC\n0u13MNxuA5Q+fgS9jQEPjt+iAEA3BCvYHWYwQLpkFqx6p2494/byRkMdoxQH\nXYXY\r\n=EMv6\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGnKK0Gnl4aRwHP8cO6wJ2MPiLUzYUWRWNVsk26NwTFFAiEAx5RbZcNL/5O9LLXG1P669GsWfZJhCwZ9QtqrGh/ttdc="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"nikki93","email":"s.nikhilesh@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"expoadmin","email":"support@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"esamelson","email":"eric@expo.io"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.8.2_1606774321986_0.25759600316078757"},"_hasShrinkwrap":false},"0.9.0":{"name":"expo-notifications","version":"0.9.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0","unimodules-permissions-interface":"*"},"dependencies":{"@expo/config-plugins":"^1.0.14","@expo/image-utils":"^0.3.10","fs-extra":"^9.0.1","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.0.0","expo-constants":"10.0.0","uuid":"^3.4.0"},"devDependencies":{"@types/fs-extra":"^9.0.6","@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"~1.2.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"e362887ddc6ba4e3518efd623d64b3cbd301a6a9","_id":"expo-notifications@0.9.0","_nodeVersion":"14.15.0","_npmVersion":"6.14.9","dist":{"integrity":"sha512-xOOQNOXVlns9aHc4nV0IEIg6PvkVudWb6CDbVN7HkRx1X+Mkts9ZHtlF2nb/c86JLBCA8z28EPiSz1R2RlkePQ==","shasum":"ea1ba4574284c6096fc0cb40967be9ad727ced75","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.9.0.tgz","fileCount":472,"unpackedSize":2945283,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgAgr/CRA9TVsSAnZWagAAwcsP/RvXbKxONJEU2M+K4qH2\nVutBvMqXrx0tFMZg1+bqEkNe0iXRPSSf5f/UqQt5PlFYUOi0pvrbWpyOnqSb\nB9+kuFiEvt5o/vOgyq7/M7eE1lawmv0O4D5dwJrM3e9iTBeuYxmi55lO0yHw\n8DJndIQsh31KgFUo0aBdamvHnwEz5aH9jaLoDQcwsp0Joj3qcHZ2YqCVbRan\nx/UV+2e2+SBkJHT0Qsv/gsvPZh6O2WwD9up6ksvxAMMMAU5Ii45EX0n7PZeP\n1lHkQ4amDgneYJlxRb2Yd6x5bwow7G5auH6xZvTNQs1ZA87SUyX293/WV+Gr\nVzS+e75Aazgrv232lOD20zIpWpk/ZYtHQSz7mP+5Q9N5dCpBcE6xa22poqIi\nZsk5TwAccUzH187IKfWUfxsEec6JEnx9X56UCXgbA67sXNDj7Fh5gZ0om7sx\nrhlAuaudBuJPCANy14Kfc5MtK9vC4a1QZMRNn8RU5+ZPTtWeQzXXzgL4rSms\nfHCwbsYPmajSRf7qy8lguk0p46PWlugzAj9Gq//Pga6x+oKSjnbr9rto4zVZ\nKWGB41VY9e8hLi9TWjn5iK2suqryTMbXgvUdlaEbMr0/THBN5kqCrYSnmWtP\n32i7PZGLbcJyFHJi++OXznLWCPdyg/9yqBjQ1cDWW+qHKRNW8smJxTQaP76V\nyjlT\r\n=jpTk\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBe4AEI8dKTUMuxHrHPfDF7+sNArD3VBVayfE3e0eervAiB6Q5DiuEe3lUbjmGDaU8R1dhV2mZ4M9DhEQPhfhhvnEg=="}]},"_npmUser":{"name":"tsapeta","email":"npm@tsapeta.com"},"directories":{},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"nikki93","email":"s.nikhilesh@gmail.com"},{"name":"jonsamp","email":"sampjon@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.9.0_1610746622337_0.9285272666355278"},"_hasShrinkwrap":false},"0.10.0":{"name":"expo-notifications","version":"0.10.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0","unimodules-permissions-interface":"*"},"dependencies":{"@expo/config-plugins":"^1.0.18","@expo/image-utils":"^0.3.10","fs-extra":"^9.0.1","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.0.0","expo-constants":"10.0.1","uuid":"^3.4.0"},"devDependencies":{"@types/fs-extra":"^9.0.6","@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"35db222e6498eb297ca9ada76648b3bd23eb6fdf","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\nThe notification icon and the default color can be customized.\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and  `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds on Android\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// Prepare the notification channel\nNotifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received \n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener (\n            (response) => {\n              const url = response.notification.request.content.data.url;\n\n              // Any custom logic to see whether the URL needs to be handled\n              //...\n\n              // Let React Navigation handle the URL\n              listener(url);\n            }\n          );\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}\n    >\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.10.0","_nodeVersion":"14.15.4","_npmVersion":"6.14.10","dist":{"integrity":"sha512-UCqodiOUWCsdJ6NZauDXzRlRb6ts16g51Zx0lcFwB6qqINYoBBwnop5BlmLmxGCcQ+wvF21iVP4c+pasDzLXzQ==","shasum":"3c5fa13438d42167576a3b4f9524885687b263b5","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.10.0.tgz","fileCount":473,"unpackedSize":2971911,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgP/MZCRA9TVsSAnZWagAA7HkQAJie1qgdZ4d0QkgPj6+T\nBGO+YYnwWfLlB4ZZ7z24U2TRoBHzq9T4lBPxfwwI5+xLBk3Xp+ZKQpf5gVob\nCHkuG+Xu45PUJQiiNFLWOJDdaII/rNn6KMz7oTnkd7MqI3ru3dBfKiVb1zwq\nBx4sHIlaGG1OQ+ouqUTXOxBOtdKZpEBnC3/M+TBvyVZZ6u/FNVP0Ik+EFXNy\nKjHWKsGCk5hSuDjOsafj91O1dLLm2yhLMpOOfZaS2/g36rImt6L/lZIP+Ptp\ndQedmvITjG9OnAp8hNCyqW0JjdevQ5jeJSI2RWg+FHE6SELIwBpZbJgNvYjm\n6U53LkWk22Ljs6bGe8fh1+CD/ScQN7ZAGCR1xbaYXP0v84QzTSbR5HE/urRn\nEP9r1qmz2+vWItN2HzCRUJqwYBrm52nF6Vm/L6XlCkome4GguB42lu7OUufW\n7q3Fh6zxyFXC6QRcLWtVnmYBf+v46wXo26hJqdY5v/3xDI3f0cCa3i5UIyqd\nMMJUx4mitgckqz/7DBtM5RynN0IvNL1yhUHxnzx29ujKYPOwXwC2Tb6p7cLQ\n8WsyPssRVVBMeTMpmgtBC0h5KlD37+o9g3Cqw8sxrdvC4S/t5TD9DdqwaR+r\n1zV5FynNBHeG+K06ME15hSoK3S5M2tpu+BnwGcqHFn/OgREITNWeNgz3g/nu\nUyv6\r\n=XyWb\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC6CVzx8K42ywSUQzGnMJ6Jt8zkzAiF6gyuV1ykwaATwAIgblr0r4N7Uw0WE32ShbelAwrsJiCgRrc3hBz29NeOnNs="}]},"_npmUser":{"name":"charliecruzan","email":"charliecruzan@gmail.com"},"directories":{},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"nikki93","email":"s.nikhilesh@gmail.com"},{"name":"jonsamp","email":"sampjon@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.10.0_1614803736651_0.6977585829013897"},"_hasShrinkwrap":false},"0.11.0":{"name":"expo-notifications","version":"0.11.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0","unimodules-permissions-interface":"*"},"dependencies":{"@expo/config-plugins":"^1.0.18","@expo/image-utils":"^0.3.10","fs-extra":"^9.0.1","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.1.0","expo-constants":"10.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/fs-extra":"^9.0.6","@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"5b57d1fd0a20294c1dec7c43b5df34dd6425d1a5","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\nThe notification icon and the default color can be customized.\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and  `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds on Android\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// Prepare the notification channel\nNotifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received \n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener (\n            (response) => {\n              const url = response.notification.request.content.data.url;\n\n              // Any custom logic to see whether the URL needs to be handled\n              //...\n\n              // Let React Navigation handle the URL\n              listener(url);\n            }\n          );\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}\n    >\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.11.0","_nodeVersion":"14.15.2","_npmVersion":"6.14.9","dist":{"integrity":"sha512-0im4LWF2kCWQ/RFm0wwhJA7SNE8msMj4TPcF3ufj7IAu8stW21T9qkZvgksvrX66kUvlD53YhDoGZEJ3UwJJ0A==","shasum":"b0b0f6128923287eae5408678739d0e2b0fb2314","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.11.0.tgz","fileCount":473,"unpackedSize":2975917,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgSCPgCRA9TVsSAnZWagAAWfcP/1x87TIYFkNSEfDLBNDo\nV9xSTmNv/NgWV5NChRVEmGv+V7cr1U5x2XasGCA73aR3dVh6gWBAGNsnZhBs\nq8GPQgUbVs6FuRAC870WWHdzFdHM3I9ankT19O3ErFjbemypWaLwzJh48owu\ny4ES1OE29An1SJB/itz5NSG1jOVDcs2vmWhAV5y3mH9lgFG1SAkfVrUv+HNP\npYUHk/ZksZH7cZi8sdJZazt57Gs+HA9IKNzajzFp+pOyctKNTtcSqc0b2IPp\nIq17k96o1rOgHyXvURMVcP/R7+/gQU7FJvDm6SaP4BKN0lNfB0VnxF9zpOrk\nAdhkqN2obs4Q5CrgBcCYAkHDsCApyAG4kPYSkSYD/ZAKuorzQxGPQfQGdMW5\nnbOGRWBa18WouvCbN3lmkdqbsAiRsJX63Qh37ADA57EhLyAp+S69SUZC3qzW\nlaoh/w0n8aEO3q+gmRsW8ossvOhCPBhRPR2x+tzwxWCLBaMVSNjjHLaAnjkO\nEcFrKoy/DeE6uxEsQGODv9dpnT8F8WaHcpw7Ugeh6ZqMdVsHEC7DMvOtcKHv\nHAkEw2PsPf76IrraqArhJ1GmbaCpqhTts05NOOr0+mQXE/+CfPyKBMKZ+ciC\nbyBxDw11YgIbC41L/s/wffMFa5fpFoheMGsahS4uvZd8Uz/eBTLiCsr7EoCI\nUU90\r\n=B6Ky\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIFf0pi7PvcxbEqNWNIz/JckRGTOOOz4qyNH+nsQYAEu6AiB6UhUmJG1mAO4/PgjZQdu8e8pO29MzIhnWwjzEpz9Rew=="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"nikki93","email":"s.nikhilesh@gmail.com"},{"name":"jonsamp","email":"sampjon@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.11.0_1615340511758_0.36731398955054595"},"_hasShrinkwrap":false},"0.11.1":{"name":"expo-notifications","version":"0.11.1","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0","unimodules-permissions-interface":"*"},"dependencies":{"@expo/config-plugins":"^1.0.18","@expo/image-utils":"^0.3.10","fs-extra":"^9.0.1","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.1.0","expo-constants":"10.1.1","uuid":"^3.4.0"},"devDependencies":{"@types/fs-extra":"^9.0.6","@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"c2520eef58fddcc435c41d95829084f5f89b3e8e","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\nThe notification icon and the default color can be customized.\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds on Android\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// Prepare the notification channel\nNotifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.11.1","_nodeVersion":"14.15.2","_npmVersion":"6.14.9","dist":{"integrity":"sha512-KLyD5SN/aEKN74bZ2MOaUnMmDTNyle2QzXBY1qWZGZVEHLEMD7WvBQtnxvjNCnwbNurwB0cfg9QZsVz3YewOPw==","shasum":"cd43807c6e83b2a84895fed081e607c74b3fb877","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.11.1.tgz","fileCount":473,"unpackedSize":2978424,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgWW/ACRA9TVsSAnZWagAAE5AP/Rr0tu8PpWe7d8RsP+Sk\ne6aHFjNr87EktTn69qqvv8gHK7yiL0DEOpIQkH0PIZaKDXAErKbi3eR6YYBa\nNIxdzUlmzWUc4U//fa+41nBRfnE9XRvGX3dCGb0sChf6MIiMNGBk/yscUSnf\nN74ixGNJgRQu2E4nIklBkXH0vQXse1L+PLjP7TdqlZY+XmyQr5kkT79i0vFt\n8Zd5zarG6fvKaZUTNNPAA+taVUoYWM3sAkb8hoGMk4fynFcvvobxDGKtwQbg\nSHJuS1waAt+PutluQgSw03aBMyTUdfDY8sh1BNRGR6W9Opkt1GOgVhWwJIfq\ngYCoTCgF/UM9EjcqGaypi/4+x1aHCo8hb3yeSvB1P+FqURwrvtFVxq0V1Zpz\nWB9Qy5crSSfxz2CJGVOfmAKWexGfTry8V8stK6R9tYusnhurWheK9r58oYFq\nCMLd9/iGYjMEFelFzzjoPz7KqAQz1QlkRUKBoZPF84ZNJ9SV3NQ/s08wUdH4\nIqvPUz8kU6pfOh+yevhDOJSqy8lSRX7VHWkkxRC1Pg0q8BeBk9WoEt3qUAAO\nu5X/yrcbHacs1bCRYGwuLba3wbKu0h0Rm00EeA+7Y+lgQCzltKjaj7JErHmJ\nrrR5dcHKhRkC1i/srfDO67ifOqPccJPSXPAbHmNAqwm8XnBt/sc97D+dMfpr\nXOUY\r\n=j6R2\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIA5pv761eWrLBUkLkU0ip7CuikAZ9IYDE2vBYDY/UjRIAiEAjsUkdcePqEThdEqPTPHnMXJcRPuPtBnhFB/bis59jEg="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"nikki93","email":"s.nikhilesh@gmail.com"},{"name":"jonsamp","email":"sampjon@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.11.1_1616474047589_0.917897609650608"},"_hasShrinkwrap":false},"0.11.2":{"name":"expo-notifications","version":"0.11.2","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0","unimodules-permissions-interface":"*"},"dependencies":{"@expo/config-plugins":"^1.0.18","@expo/image-utils":"^0.3.10","fs-extra":"^9.0.1","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.1.0","expo-constants":"10.1.1","uuid":"^3.4.0"},"devDependencies":{"@types/fs-extra":"^9.0.6","@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"425be641cd8dd9eb89cba3f2649ce292856fab39","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\nThe notification icon and the default color can be customized.\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds on Android\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// Prepare the notification channel\nNotifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.11.2","_nodeVersion":"14.15.2","_npmVersion":"6.14.12","dist":{"integrity":"sha512-RDgaU+pSx6TsTxU7UDyU6/UsV7fyiPgjgspM1c3UGCQQrYD19kAdEEdVMEltntnM0mCUOZqRqZK0Jb21y0C3lA==","shasum":"9b11614730b9db644f53107dc72e4dd69d2c76a3","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.11.2.tgz","fileCount":473,"unpackedSize":2978838,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgY1v4CRA9TVsSAnZWagAA0GMP/ifzQkPUGvet0+G1QZs9\nRV4Ly5n3fvoJwwpAJWUrul5kOZWOwlu2K4qofqCVrdfzsK0hGX/Upa74TTvp\nyuVSfF7KdiPfffIdA+ueU1sh8oH90+fS3JuYBrNJvfnesNP9l8qme5xrr5ci\nKM33CaR5vff8lTclG4zgvVrv5DIPskrfIrHOXpvHySpofJT4kITWIsmtRUVi\ngTKDqD+viusyWtMMruedGnEsSWso7oiqy9DrQWlXrrE+BjZFjKXMTbrEfnJB\niwA4tCVkJH8cGYLJ/jCm/JguWetpTIkhhk9RocE9yJRPy/lcM9YHEt47TSpe\niSlBNJSrjSkoV4/FaTQhCH8lCF4+TquY8gb6CtyCmPPq3EU9dziJRFDRHaS5\nyhPCnBLQG2Vr7MTRougRR1/Gj5tWqyueov8FDJLSv5CI9ySN8AJ7HaN+8DZY\nFG0XxD7H0Y0OufRrcWpEnDsEQckZSYtBCpbLcM5BxAfJIqh0mxqZJhCVvUxy\nnrRELHqS91dOzEy89pwxK2xCCPFl8jCNk7w4dRO0AerRKO3M3P1PAPnZ1vFN\nIMx3n7E8p8yvq4NYCfPLIgh10ohp2laDSBY/QcWhCB1446SYqfYtNS70Qlvc\n6zguYjfAz1PaxOw6CDk7A995Omf1G2n1UH/CnhGOJGhYR6eWkxOBTEETTn16\nzSgL\r\n=/EFN\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIHh8Kg1F4qtLh2Owrmc+Em7rms5uM8CO1iH+mPHJBOrpAiEAo62EIPPEn1mMLlyo3oJXZ+VIERMdhc7rFsCVWpDEYeo="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"nikki93","email":"s.nikhilesh@gmail.com"},{"name":"jonsamp","email":"sampjon@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.11.2_1617124344137_0.8275121981166975"},"_hasShrinkwrap":false},"0.11.3":{"name":"expo-notifications","version":"0.11.3","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0","unimodules-permissions-interface":"*"},"dependencies":{"@expo/config-plugins":"^1.0.18","@expo/image-utils":"^0.3.10","fs-extra":"^9.0.1","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.1.0","expo-constants":"10.1.1","uuid":"^3.4.0","unimodules-permissions-interface":"~6.1.0"},"devDependencies":{"@types/fs-extra":"^9.0.6","@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"1e83e224c24d9fa33e1f7adc0b9c8c0b89fe27b5","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\nThe notification icon and the default color can be customized.\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds on Android\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// Prepare the notification channel\nNotifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.11.3","_nodeVersion":"14.15.2","_npmVersion":"6.14.12","dist":{"integrity":"sha512-3IZg4Pe6cbeb+ct+6d+6LcbtWtd7N+DOjchx00KfVf1FWo6254e0CeRvlNXAPbKGdBvE0ByqT4kSMqcbuUkSfQ==","shasum":"6ceb5e739b5b7a957d249557275e16715d0ea235","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.11.3.tgz","fileCount":473,"unpackedSize":2978974,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgZLS9CRA9TVsSAnZWagAA/icP+QFUgS/o/qxKFRarUkhw\nj++XY2gFQcf/v872vquwRhGz+KK4pXb4pdL+F8Priulm2v1F2E8G9nlc+fs2\nG4IrbAJ093Iy5MINzx+FuBlbI7CpgtJsROme39yl4UcBaqa9ikXMPARecHJP\nGEhqjN/uVRvETyQatVLn47Ot8dEUFltd/U2qqey9TBEJ2j8RPdY5KqY+Yy/I\n/VWGuvN352Ab4oilxd1n7Y44/xEtJn86M5db6MtWHAFk5qG+oZKsJHgAaoCD\nsrJhuXUEMDcIbjoY1UA5A3C3J2sfdxBzAkoWZEUbDc5832FQ/adrnddvxzbp\nNPJT6Ea3UvwRoaIycfTenXIe8v5QfSHcMvhzoGUoPikVIVkPVQpug+VCYtMm\ns1TfLNBhHcCFzFdwreLTVaHOF/FqgdyJDO4ECqfO3HFfgRNELEDpKz9Ncg/V\ngytN0+T2luvgAoJUaJJ7g0WXqfg1FK9KbW+VbIrmyVGgD7CCvwATSc5FiD1P\nPuxfCFLVEOj2Uaz9SxfuoMlk21CMU6xZjNAB94xxvTIMRpFt/PY+FvDa1/KD\nmhZJw0ylKtVe0VucBQfAK0W9Dt3EIqlcECTc8PCGcRhdgWIgVvJuC/UE0jcV\nP/cus5AT/wIEa8MGjkmI0pS3Y0Hp7SghBSYl2v6wpBOpnx+dvA/yB0s0RWBf\nZqTH\r\n=Eqw4\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDp142jn6+XO/AcoBKuo9XyCzWNA/Pc6+HHOMVVqgafaAIhAOqnTnMt37K7K7dqlBzdMyp5yt8xPlopDcKV12EvP5lt"}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"nikki93","email":"s.nikhilesh@gmail.com"},{"name":"jonsamp","email":"sampjon@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.11.3_1617212605284_0.4726690416788635"},"_hasShrinkwrap":false},"0.11.4":{"name":"expo-notifications","version":"0.11.4","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0","unimodules-permissions-interface":"*"},"dependencies":{"@expo/config-plugins":"^1.0.18","@expo/image-utils":"^0.3.10","fs-extra":"^9.0.1","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.1.1","expo-constants":"10.1.2","uuid":"^3.4.0","unimodules-permissions-interface":"~6.1.0"},"devDependencies":{"@types/fs-extra":"^9.0.6","@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"ef873567599c2604c2d255c85ec91d910667b892","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\nThe notification icon and the default color can be customized.\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds on Android\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// Prepare the notification channel\nNotifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.11.4","_nodeVersion":"14.15.2","_npmVersion":"6.14.12","dist":{"integrity":"sha512-esmVLsuyvJI5pcws3MFi+2fBnV2+UMiVrnmKmRHeytepuQrfM8hQlA65GB8sasHPivZ0q8LC/MqCwmdp69eeMw==","shasum":"4098ee99c088ef788a07c5b3c0c1b31071478837","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.11.4.tgz","fileCount":473,"unpackedSize":2979236,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgcNfsCRA9TVsSAnZWagAAduAP/2JhEYF+hwfNXnSv28as\nOOhOLWoFoklVJCTRPCT9goIPBuxzHQkAibz6MDQU21w4sz9JUPRciVXbmaFc\nMm9YL28vAfQl+8f23vFyqffonpE1PAMWZ636ZGilPY4aSldGKG2OEmUDMlnN\nKkVhPQXa7oiWuJDZK1oPZL+OYjU1wqMjPGypM98Q9m3xxJ7kG4RTtXVb0OGe\nNb9MfhUcX9ZqC/r/DS/CiBWT5ecBJa08AvhyoqcStpdQ9JM4th4NEssa/gn7\nrc7YbLkcPymdpGBjegM4+7B9EOeiBg2Bh8dWcQMVAQM36HuhjsCsRB1eTBFE\nAGhOl3AfN4icRtgUBsuETxuspHUsRDm5VUAOE/3A2hcwjXole/ZGQ7a6ttCC\n3r3K97ZBz8qM0yuYdo8GWEPCXk+8cHSyjYe10piV2m4jTlCwiiI8vgpgidwM\nnEPpYaFagIlaibyJYjjhWYdkvqpQp4qVds7DnAkvOm7NwqeMefLT03VVEj6a\nHS4SXHbprbaqaY+DT/pH0BVJNaw5snGD6PbG1E5MdirrVPRZv6zOjkRnNX1K\nSZFPPxQu2IMbB4Um0d39bsQqkSxp4R1UUlZZVSOOxXxkqxj+jt3vYQKGSBfx\nt/psx6UAW69MARSOpLIBkHcMeN9zUm75TTNOEgbDnqHIgtsKgK9E/7WDDLL1\n4/YC\r\n=a+7M\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQC2b2MYSOCXoOyI71H2SiSoeLcNtwfmPedlGvA8McECCQIgQ+mffDwk69ikeanDPrEZtIws6NVEKCpm98Ov3xq/+rs="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"nikki93","email":"s.nikhilesh@gmail.com"},{"name":"jonsamp","email":"sampjon@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.11.4_1618008043723_0.49705875928210963"},"_hasShrinkwrap":false},"0.11.5":{"name":"expo-notifications","version":"0.11.5","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0","unimodules-permissions-interface":"*"},"dependencies":{"@expo/config-plugins":"^1.0.18","@expo/image-utils":"^0.3.10","fs-extra":"^9.0.1","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.1.2","expo-constants":"10.1.3","uuid":"^3.4.0","unimodules-permissions-interface":"~6.1.0"},"devDependencies":{"@types/fs-extra":"^9.0.6","@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"9c6693e1e8997dd279d408b0f6e6490897713085","_id":"expo-notifications@0.11.5","_nodeVersion":"14.15.2","_npmVersion":"6.14.12","dist":{"integrity":"sha512-YaaeYaYuv0ElGDq2s6wantI/VPUI1K31CwRC5UBUOPDXVJcRf4vcLWNvKiRo4ZscsdWpbkiiYqTK5Xaa5zmMYw==","shasum":"9cabfb2c81f55117eb076c983bc7a9479cff68d9","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.11.5.tgz","fileCount":473,"unpackedSize":2979264,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgdfe/CRA9TVsSAnZWagAAVFQP/1h/tduFPQ2Tl+Disc0o\ny7/tQCd4d1UNW+nJjyoirT4LicGg95e38MdUpzzsb6M5ktXvMwb7W77qVfki\nk/EklMdRFEntZlQxhZfOsBhiEgGQkM9kD+TjpUH/9eeGVKT0yb2T/oVM9Gcq\n4YkAM7WOjkU2naYaqaxWkENVyJkknF4fvm8XhcHHR3/j5vHx0VHtwEpUg1Zz\nWpbnq3uEGGpaGMUhvp4vJq9jQGsKa6UmRmdndjKthmsYwRe06qEtHTLSg7oS\np0/vtvu3XYGzLR1x1t3HitCJUKAKYJoXYJrEdgJFOjc2F9H6vksfsbomqPu8\nwDvk9nKHjQNMEse24Tk+6kyqxEUnCadoJEBcIvuJv1xpUV5Ks38XdqmLCHbu\nsV4EfSvEU4iZoe3mxC5FCd0qFZMScaC82bOlXzBRRwpA9pnt6zdumSM1sFYl\n+a+jwPauMZETR7f5GlV9AvyaxGqi6inIBdKzLg0BuwNn0fmPuQfyT9hcNrlj\nUQgzR9fW5EA5rfpQ1pzjjGzzkOjUT3OxHmqmzvFjFoA01uJ4/50kQrbz4oa3\nAM/pOgm8WvenFV7a+FbqhpyWWhT1qHjLoBZ3YECMEiPOB+dK694bNw3yXapL\nAmjf/REGxoGrYFTwsDO6FeIvGhO0u8BNpHNQCW4U5Tk4dfFglECSGRvv4fNh\nNwkb\r\n=85Al\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEMCIEngjb6YheTdY29ylz+HeQhc5KyFOKN/DCO3tqdnHZM/Ah9buRBqIRZqVUmkwckz6burZm5eisR2wn0Mcv91BrBM"}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"sjchmiela","email":"sjchmiela@gmail.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"mczernek","email":"czernekmichal@gmail.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"ijzerenhein","email":"hrutjes@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"nikki93","email":"s.nikhilesh@gmail.com"},{"name":"jonsamp","email":"sampjon@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.11.5_1618343871472_0.9856551140357575"},"_hasShrinkwrap":false},"0.11.6":{"name":"expo-notifications","version":"0.11.6","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0","unimodules-permissions-interface":"*"},"dependencies":{"@expo/config-plugins":"^1.0.18","@expo/image-utils":"^0.3.10","fs-extra":"^9.0.1","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.1.2","expo-constants":"10.1.3","uuid":"^3.4.0","unimodules-permissions-interface":"~6.1.0"},"devDependencies":{"@types/fs-extra":"^9.0.6","@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"552e4360dc8adacb2b3173051dc50d7fb6afbf84","_id":"expo-notifications@0.11.6","_nodeVersion":"14.15.2","_npmVersion":"6.14.12","dist":{"integrity":"sha512-skVEOHXKXrXBWofCQ/Zn7yKhAFA2EN0fd9mXqpkbF6nE4NKE7pn63gTWpyCy6sXC9M3YUal8yT0vp9GkD2FsmA==","shasum":"0ea45b23b1f5572b40d64afee24abaa5a1c10800","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.11.6.tgz","fileCount":473,"unpackedSize":2979526,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgf3IdCRA9TVsSAnZWagAAIQkP/1b/ZUoyzMbvB0fuv5A9\nGESLnyUTkIja5yI9xT/97iclZwywWjGTfde2/cpsKNdNuEDyzuOElL3iO1wS\noNeNHaRo3r/g8aHV0WhxB6eqorh2cZ8cwh1l3E29iPTHfrDecp5kxMVRkRJl\ntykHzkYC4kSnOSkkvYodoDqBTtTk7qKEFbBs+IS+T/Z3N+ijDrST1T5It0+K\nyRK6Fy/c0he5HRGXZO9hzlBivXJ+7yGsDgMYY1UCCCP+wZXi07nY8ibEFqU8\n4behM2TbPfbgI96QDjAJR0sWnfeYUVrS0KTyOhhn5bpBCHkdK7zgOIiudpXV\nISAYt9r8j+VwxJpKrKxe1XQvOM822M8CTRM85ORONmnZ/1x1hizZuiSpHNrW\nbXePn2/YsOVKw2H9lfkQRGAPHs0JNBCYQnliWf3GtAA9pbTgjb99XJ7YWn9S\nagdg5BoS42jyE0x4/pKR35Muqs1n1WoPOux5uzfMkWyL2Vtim71gj6PIunL5\nkX/Nb41BDNqC6rM2kUVp9YjQP53ifxum6r7Xy/vU+CjoTqjyaWLGX4FhDw3b\nDGXaPlqHoOBE/1a5DijOmMv4O+gDLdVfxJwK9QqlRbdxdTdnrPNBIRb20Kjs\nOqellN0Cy3Tr/Qc8JH0nwmxhu8alE9FKDlJBCsCd7IBbjJHtvUPzGxmdugAb\nJwpW\r\n=YzyJ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCICjuHh2JQcaeobdIzrqB5JJdImUGYnvELJobfIB5viEhAiEAj9ZVHE6mTUQBX5IJ9rvKzdj5Pl2eqHwRthknlxxb5i8="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.11.6_1618965020928_0.19340527442522948"},"_hasShrinkwrap":false},"0.12.0":{"name":"expo-notifications","version":"0.12.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","unimodules-task-manager-interface":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0"},"dependencies":{"@expo/config-plugins":"^2.0.0","@expo/image-utils":"^0.3.10","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.2.0","expo-constants":"11.0.0","expo-modules-core":"~0.1.1","fs-extra":"^9.0.1","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"b33f5e224578564c3e4b1b467f258cc119b3b786","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications in the foreground and background,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\n### Optional setup for notification icon, tint color, and custom sounds\n\nIf you're using EAS Build or the bare workflow, you can set your Android notification icon and color tint, add custom push notification sounds, and set your iOS notification environment using the `expo-notifications` config plugin ([what's a config plugin?](http://docs.expo.io/guides/config-plugins/)). To setup, just add the config plugin to the `plugins` array of your `app.json` or `app.config.js`:\n\n```json\n{\n  \"expo\": {\n    ...\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"icon\": \"./local/path/to/myNotificationIcon.png\",\n          \"color\": \"#ffffff\",\n          \"sounds\": [\"./local/path/to/mySound.wav\", \"./local/path/to/myOtherSound.wav\"],\n          \"mode\": \"production\"\n        }\n      ]\n    ],\n  }\n}\n```\n\n<details><summary><strong>Expand to view property descriptions and default values</strong></summary> <p>\n\n- **icon**: Android only. Local path to an image to use as the icon for push notifications. 96x96 all-white png with transparency.\n- **color**: Android only. Tint color for the push notification image when it appears in the notification tray. Default: \"#ffffff\".\n- **sounds**: Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.\n- **mode**: iOS only. Environment of the app: either 'development' or 'production'. Default: 'development'.\n\n</p>\n</details>\n\nThen rebuild the app. If you're using the bare workflow, make sure to run `expo prebuild` first (this will apply the config plugin using [prebuilding](https://expo.fyi/prebuilding)).\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds\n\nCustom notification sounds are only supported when using [EAS Build](https://docs.expo.io/build/introduction/), or in the bare workflow.\n\nTo add custom push notification sounds to your app, add the `expo-notifications` plugin to your `app.json` file:\n\n```json\n{\n  \"expo\": {\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"sounds\": [\"local/path/to/mySoundFile.wav\"]\n        }\n      ]\n    ]\n  }\n}\n```\n\nAfter building your app, the array of files will be available for use in both [`NotificationContentInput`](#notificationcontentinput) and [`NotificationChannelInput`](#notificationchannelinput). You _only_ need to provide the base filename- here's an example using the config above:\n\n```ts\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  sound: 'mySoundFile.wav', // Provide ONLY the base filename\n});\n\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    sound: 'mySoundFile.wav', // Provide ONLY the base filename\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails',\n  },\n});\n```\n\nYou can also manually add notification files to your Android and iOS projects if you prefer:\n\n<details><summary><strong>Manually adding notification sounds on Android</strong></summary> <p>\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\nFor the example below to work, you would place your `email-sound.wav` file in `android/app/src/main/res/raw/`.\n\n```ts\n// Prepare the notification channel\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n</p>\n</details>\n\n<details><summary><strong>Manually adding notification sounds on iOS</strong></summary> <p>\n\nOn iOS, all that's needed is to place your sound file in your Xcode project, and then specify the sound file in your `NotificationContentInput`, like this:\n\n```ts\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'notification.wav',\n  },\n  trigger: {\n    // ...\n  },\n});\n```\n\n</p>\n</details>\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\nNotification events include incoming notifications, interactions your users perform with notifications (this can be tapping on a notification, or interacting with it via [notification categories](#managing-notification-categories-interactive-notifications)), and rare occasions when your notifications may be dropped.\n\nA few different listeners are exposed, so we've provided a chart below which will hopefully help you understand when you can expect each one to be triggered:\n\n| User interacted with notification? | App state  | Listener(s) triggered                                                   |\n| :--------------------------------- | :--------: | ----------------------------------------------------------------------- |\n| false                              | Foreground | `NotificationReceivedListener`                                          |\n| false                              | Background | `BackgroundNotificationTask`                                            |\n| false                              |   Killed   | none                                                                    |\n| true                               | Foreground | `NotificationReceivedListener` & `NotificationResponseReceivedListener` |\n| true                               | Background | `NotificationResponseReceivedListener`                                  |\n| true                               |   Killed   | `NotificationResponseReceivedListener`                                  |\n\n> In the chart above, whenever `NotificationResponseReceivedListener` is triggered, the same would apply to the `useLastNotificationResponse` hook.\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Handling incoming notifications when the app is not in the foreground (not supported in Expo Go)\n\n> **Please note:** In order to handle notifications while the app is backgrounded on iOS, you _must_ add `remote-notification` to the `ios.infoPlist.UIBackgroundModes` key in your app.json, **and** add `\"content-available\": 1` to your push notification payload. Under normal circumstances, the ‚Äúcontent-available‚Äù flag should launch your app if it isn‚Äôt running and wasn‚Äôt killed by the user, _however_, this is ultimately decided by the OS so it might not always happen.\n\n### `registerTaskAsync(taskName: string): void`\n\nWhen a notification is received while the app is backgrounded, using this function you can set a callback that will be run in response to that notification. Under the hood, this function is run using `expo-task-manager`. You **must** define the task _first_, with [`TaskManager.defineTask`](https://docs.expo.io/versions/latest/sdk/task-manager/#taskmanagerdefinetasktaskname-task). Make sure you define it in the global scope.\n\nThe `taskName` argument is the string you passed to `TaskManager.defineTask` as the \"taskName\". The callback function you define with `TaskManager.defineTask` will receive the following arguments:\n\n- **data**: The remote payload delivered by either FCM (Android) or APNs (iOS). [See here for details](#pushnotificationtrigger).\n- **error**: The error (if any) that occurred during execution of the task.\n- **executionInfo**: JSON object of additional info related to the task, including the `taskName`.\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n### `unregisterTaskAsync(taskName: string): void`\n\nUsed to unregister tasks registered with `registerTaskAsync`.\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.12.0","_nodeVersion":"14.15.2","_npmVersion":"6.14.13","dist":{"integrity":"sha512-tn2W1XcmNHrTvWxaueA3oLFQi865NaN2rmrwODrmQP9HgCOfIoWyc4BBDSC08KvtO7uqNv1wAqLrTTGqn4Y4RQ==","shasum":"80872756e3f3cc2f8c4f5cf4e79560be9749d861","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.12.0.tgz","fileCount":499,"unpackedSize":3143758,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgyk1MCRA9TVsSAnZWagAAz5YQAIGhN8jn8wmLebX8zXDd\n01zPnPhJ4LN8XPnNsx8TqKC1oRwHfeiEVkCMwRlAXPFYyfE4sTLjzJ0Uj8As\nlXVx5HV3Ve5ilj89JSw3LMR4a46djFFSdF0zwNnUlUNyG71gQm4e0DLbhOXG\nyIxpgcrzsfF6f+cxNCfVyTYYeZMZzixOUl2vJVvRqeJmrF2hslb4h0cVMLuG\nEAcbaQRlc61H8V6oE8S0TbErPD5SodxUx5lM1sNeylaNJpNIl0MxbrRJLeGr\n6P8mDjHIaDwfhBd4xONPQp1tHO6tq+SfpFiQUsjKH9JSY/KICkgpjyVGwZIi\n7H1yU+5hz0aQ9fcWAzqQNMtHATnfsyd56rOU4s9XCZLsKjjvzRwB3wdaogWK\nflf8T6RDH/JQnIWBSeNQ4dN/4w4P2VagTlb4x8hs2SPZ0XUtu2HJlkrXX1ST\nHjsB+gsdSUJwBqQFF78jqm76tvZCbdo3xedcAi2MPgrZsSS8jZtgDpQQY9uk\nIPO10/QGsOpSyNd4Y/Z5SASsQk+NLzPiVIuXxhTHJmWwF/krFE43mJym1VRB\nluXUkwJW+dE7WCluFe9s5Fvx320MyHK5bCDPWlsJ1Jsqp/TdsXpQovo/T3u+\nLyW5kUpJnmAYMn+jlPt5hDhZVu4W5Jb9nkTY6nvdTwfrwsEPw5sBJcNr27Qo\ng638\r\n=hnzW\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDEfYK8qahA9dIhzdq74M/2shGOrVsuaHQK3RQL48E/TAIgUnx2JqXzGO1EypWS695TCjs/LYiFqlVv9Q2KBVZ7VxU="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"haydendaly","email":"haydencdaly@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.12.0_1623870795547_0.9065819008023626"},"_hasShrinkwrap":false},"0.12.1":{"name":"expo-notifications","version":"0.12.1","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","unimodules-task-manager-interface":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0"},"dependencies":{"@expo/config-plugins":"^2.0.0","@expo/image-utils":"^0.3.10","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.2.0","expo-constants":"11.0.1","expo-modules-core":"~0.2.0","fs-extra":"^9.0.1","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"6e8cfadff90f106d6321d0dd8c4158f12a973d30","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications in the foreground and background,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\n### Optional setup for notification icon, tint color, and custom sounds\n\nIf you're using EAS Build or the bare workflow, you can set your Android notification icon and color tint, add custom push notification sounds, and set your iOS notification environment using the `expo-notifications` config plugin ([what's a config plugin?](http://docs.expo.io/guides/config-plugins/)). To setup, just add the config plugin to the `plugins` array of your `app.json` or `app.config.js`:\n\n```json\n{\n  \"expo\": {\n    ...\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"icon\": \"./local/path/to/myNotificationIcon.png\",\n          \"color\": \"#ffffff\",\n          \"sounds\": [\"./local/path/to/mySound.wav\", \"./local/path/to/myOtherSound.wav\"],\n          \"mode\": \"production\"\n        }\n      ]\n    ],\n  }\n}\n```\n\n<details><summary><strong>Expand to view property descriptions and default values</strong></summary> <p>\n\n- **icon**: Android only. Local path to an image to use as the icon for push notifications. 96x96 all-white png with transparency.\n- **color**: Android only. Tint color for the push notification image when it appears in the notification tray. Default: \"#ffffff\".\n- **sounds**: Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.\n- **mode**: iOS only. Environment of the app: either 'development' or 'production'. Default: 'development'.\n\n</p>\n</details>\n\nThen rebuild the app. If you're using the bare workflow, make sure to run `expo prebuild` first (this will apply the config plugin using [prebuilding](https://expo.fyi/prebuilding)).\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds\n\nCustom notification sounds are only supported when using [EAS Build](https://docs.expo.io/build/introduction/), or in the bare workflow.\n\nTo add custom push notification sounds to your app, add the `expo-notifications` plugin to your `app.json` file:\n\n```json\n{\n  \"expo\": {\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"sounds\": [\"local/path/to/mySoundFile.wav\"]\n        }\n      ]\n    ]\n  }\n}\n```\n\nAfter building your app, the array of files will be available for use in both [`NotificationContentInput`](#notificationcontentinput) and [`NotificationChannelInput`](#notificationchannelinput). You _only_ need to provide the base filename- here's an example using the config above:\n\n```ts\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  sound: 'mySoundFile.wav', // Provide ONLY the base filename\n});\n\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    sound: 'mySoundFile.wav', // Provide ONLY the base filename\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails',\n  },\n});\n```\n\nYou can also manually add notification files to your Android and iOS projects if you prefer:\n\n<details><summary><strong>Manually adding notification sounds on Android</strong></summary> <p>\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\nFor the example below to work, you would place your `email-sound.wav` file in `android/app/src/main/res/raw/`.\n\n```ts\n// Prepare the notification channel\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n</p>\n</details>\n\n<details><summary><strong>Manually adding notification sounds on iOS</strong></summary> <p>\n\nOn iOS, all that's needed is to place your sound file in your Xcode project, and then specify the sound file in your `NotificationContentInput`, like this:\n\n```ts\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'notification.wav',\n  },\n  trigger: {\n    // ...\n  },\n});\n```\n\n</p>\n</details>\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\nNotification events include incoming notifications, interactions your users perform with notifications (this can be tapping on a notification, or interacting with it via [notification categories](#managing-notification-categories-interactive-notifications)), and rare occasions when your notifications may be dropped.\n\nA few different listeners are exposed, so we've provided a chart below which will hopefully help you understand when you can expect each one to be triggered:\n\n| User interacted with notification? | App state  | Listener(s) triggered                                                   |\n| :--------------------------------- | :--------: | ----------------------------------------------------------------------- |\n| false                              | Foreground | `NotificationReceivedListener`                                          |\n| false                              | Background | `BackgroundNotificationTask`                                            |\n| false                              |   Killed   | none                                                                    |\n| true                               | Foreground | `NotificationReceivedListener` & `NotificationResponseReceivedListener` |\n| true                               | Background | `NotificationResponseReceivedListener`                                  |\n| true                               |   Killed   | `NotificationResponseReceivedListener`                                  |\n\n> In the chart above, whenever `NotificationResponseReceivedListener` is triggered, the same would apply to the `useLastNotificationResponse` hook.\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Handling incoming notifications when the app is not in the foreground (not supported in Expo Go)\n\n> **Please note:** In order to handle notifications while the app is backgrounded on iOS, you _must_ add `remote-notification` to the `ios.infoPlist.UIBackgroundModes` key in your app.json, **and** add `\"content-available\": 1` to your push notification payload. Under normal circumstances, the ‚Äúcontent-available‚Äù flag should launch your app if it isn‚Äôt running and wasn‚Äôt killed by the user, _however_, this is ultimately decided by the OS so it might not always happen.\n\n### `registerTaskAsync(taskName: string): void`\n\nWhen a notification is received while the app is backgrounded, using this function you can set a callback that will be run in response to that notification. Under the hood, this function is run using `expo-task-manager`. You **must** define the task _first_, with [`TaskManager.defineTask`](https://docs.expo.io/versions/latest/sdk/task-manager/#taskmanagerdefinetasktaskname-task). Make sure you define it in the global scope.\n\nThe `taskName` argument is the string you passed to `TaskManager.defineTask` as the \"taskName\". The callback function you define with `TaskManager.defineTask` will receive the following arguments:\n\n- **data**: The remote payload delivered by either FCM (Android) or APNs (iOS). [See here for details](#pushnotificationtrigger).\n- **error**: The error (if any) that occurred during execution of the task.\n- **executionInfo**: JSON object of additional info related to the task, including the `taskName`.\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n### `unregisterTaskAsync(taskName: string): void`\n\nUsed to unregister tasks registered with `registerTaskAsync`.\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.12.1","_nodeVersion":"14.15.2","_npmVersion":"6.14.13","dist":{"integrity":"sha512-LpbgzBcJyjlaXWzIaE2n30mpVZWCDOms5f8bn/vy5Br/HK8WE52YyMYkBVv+ibiyhUdrd066q35DtYlJTn9lJg==","shasum":"dd143406b408ce531c0c5e1244655e4475a7e791","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.12.1.tgz","fileCount":499,"unpackedSize":3143844,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg0S3mCRA9TVsSAnZWagAAb9wP/3LzHTc7KJLQssnENmJ1\nShJjIgODZyFlEhmq6vo/aRKgQVSy3OPeuT6hehtPWht61DafffKgmHUjCPx6\ngcAzKXSNhLzrYcUHdV4A5v3xtyu3asUUxTJpBWfIBLUW6SSC67fzXObPfokG\nkpRRz74as/iX66O4zQk4jqvlizuoFAD0s9hwoERGRPHXlkle4WadwcQMdVKj\nQdilaXF6D29kvahIv7CIrQTTNJvxlLlo6EvU8HwobTk9RrX/0Fb0etzpAqYa\n7w7upvaaBHfm+6o7Cumt4QIqXcFpVzyr1ERPHmzC4hQsAHPhhdj5mav95/cA\nGuN2IK8bk2vMMv2dIK8gJaF2KLtqRDw6lyNFffIH+1nS0hWvShV/GQMsIfn5\ne9kp3vEdu/EN7u+//YNpUk1Hj+8KMFqGO/8VejO2p5Dgl+O/fCfpnqGyLaz7\n8rOlgo18G8xPEKVZn3NuLMd/9e2a4VI9U/RuFsfle9rF2toTJ4bzP9pELL1i\n17ZwO8F45KdXD3oy74rODEeej1s2Qv2Sf0KV6lNUnDGElKW8Gy3d0BaXi1ZZ\nSLSyQ90rjJlBQ7DTRbzVSpO/gCFZb5pc9ZHwPwAmBfDCpk+DjP0cs4CBLfwA\nET1eT0FRsV5E/EBwiqrszr+il//O3PCFB4RJ8sRRTY/xubEwngGGsETj8pmE\n6kQw\r\n=1M0k\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBvgtPfAsTybD/xs9ssi67/zcj2bokB2mJXmMmBhbzp4AiAlLU/mRkOUiGqhuwrdntf2kF9Os5eFBpQLgzjdY2CajA=="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"haydendaly","email":"haydencdaly@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.12.1_1624321510062_0.17017973416339527"},"_hasShrinkwrap":false},"0.12.2":{"name":"expo-notifications","version":"0.12.2","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","unimodules-task-manager-interface":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0"},"dependencies":{"@expo/config-plugins":"^3.0.0","@expo/image-utils":"^0.3.10","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.2.0","expo-constants":"11.0.1","expo-modules-core":"~0.2.0","fs-extra":"^9.0.1","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"4fc9d282ff7ab2fa9040b775aeca7c30f5167b17","_id":"expo-notifications@0.12.2","_nodeVersion":"14.15.2","_npmVersion":"6.14.13","dist":{"integrity":"sha512-SCI2nBdhZXZxR2LR4/ixcit/tNOkC7eHD+fWkTpxky/I4ZSBCpP/nhrdD5Sr0G3o/r86/OSXY8XRRrp2pKG8iA==","shasum":"54b29b522e0a441f44b2749d86d3e9448f1f423d","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.12.2.tgz","fileCount":499,"unpackedSize":3142850,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg1OfMCRA9TVsSAnZWagAAmk8P/293RmW8cd/DDtK9uRLF\neVFvWKcHgXw9Le9Gswup3EicRuNpOBxEd69MeYI7si1Wf7wRzE8YONATk3bK\nfBCT380Ov9evsErhzNE7UVqzKNC8wqCOPBy8M9wnFLXSXQza1BdBNwxNtNbG\nYn9NZleeq3lk1MTHN2jyktNkPeeQHluujMwoV8BI60QZ7SS3rTDEYYbwzQS2\npOnC5CcWS0eW2OvOhJaaC4whHl/tD3GRDsPY+uBzoV9ycOOXdmUUrAZD76kl\nqHbw5oACUdyDfu3HrXcwgfXUKCbTp0Or2vTilGMS8E/FfEMq46QlC2zqMzF4\n0bFSgN2qHE6235hau5CLVVrKref8Zfq23kgr/hJRq9nvqAppxDRXju3Ao6DB\nrUcgASOJdwMq5FrmAeqLSdX/nqnhd5X1D2+jS2hyK3g2Op7a3eAjwnQTARCt\n6OxhPKAslUPD0TyuTyzGnNzMK+9I+fVkPy/mYeyF95a9b8sCQOcxmIk/wzLj\nq+pU+hwRx/jI27QKoLd6jK5zmFzkfWyW8NWwYwybECLOMj5VO3bvB6L1OifJ\naP2f+RzdeFcqaBJ/WSAXbo1hKboGXUF5aDr/hHUtU1eho1veGNA7b3wJa4sm\n3OZt7ZyaoU5rX4Qa6siEpIKPTUvOBP2xLYvyaiwgjcHKiXngId6IMmeotVWh\nsEvm\r\n=l+Aj\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCxXKRNW43qh5D1MS9cFtqXiSwn32X5rrKna6zCdBlpJwIgEvcnI0qiJFa/EsjQNVQ661C1v90KSwcl8xz9trK5+xg="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"haydendaly","email":"haydencdaly@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.12.2_1624565707600_0.4536839396679231"},"_hasShrinkwrap":false},"0.12.3":{"name":"expo-notifications","version":"0.12.3","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.io/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"unimodulePeerDependencies":{"@unimodules/core":"*","unimodules-task-manager-interface":"*","expo-application":"^2.1.0","expo-constants":">=9.3.3 <11.0.0"},"dependencies":{"@expo/config-plugins":"^3.0.0","@expo/image-utils":"^0.3.10","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~3.2.0","expo-constants":"11.0.1","expo-modules-core":"~0.2.0","fs-extra":"^9.0.1","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"c2fe33c58a80fe4b0e2498e5075c86f533ffaa19","_id":"expo-notifications@0.12.3","_nodeVersion":"14.15.2","_npmVersion":"6.14.13","dist":{"integrity":"sha512-4N8uoDJwYYXeIH+iGtjA9H6dF4yaEdDyFoYcUbHwsC1MUCL9CquDXpxoO1X2GCBFpwE0kqkyXTOCDqLAQlj5PA==","shasum":"19a574a05634540670a69e242de5c8cb3b8d14d5","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.12.3.tgz","fileCount":499,"unpackedSize":3143193,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJg52A8CRA9TVsSAnZWagAAth0P/jRnyougKAYDz5691e+n\nR94Hk249IlGP49EEbeAS2/l8HJPlaYx/QwjeOMS5CSlYDUy6hVOfSe4b2vHM\nlfivK1PKOp5YBMhGICPlje2E5Uaq+wkOmyGvzX/uJ6tWKMKHFreEVJ/BGfOk\npKe0yj/T4MaPmC33i8m53olJZDTnvAu9rQf97Jd0P/h+FYv8PE3314sIdvC3\nujWXsmTT6MjJvRNlb7a4Icm1SIsjPxiUKJlF5frk0Qeh8nzufJdEk5LR8mtx\nfTESYmF7oOLpAxKmImf8+lohKTfvIeHrnXr5TET6LWWrJUnvmfNaQYS+SKcb\nWybMsamCxKBgZscFYEH9wxrcY2kpcueTR1pyJKaq1RbhnpDC+FqXFyOJ1gDK\n02pAyTWPu8L9L0EJUniafjC2TWUpVMcNSG6Aar1pGu4doTtYRcggxq2LmNZO\n9C/TLfCITy9Q6/6Ge1elZmV/vpqELwwfdfKfB5PBM4g/IPQV73Cdp3JP85/y\nfmI8CjJyeh89wDoaFUIJaoTAZhux+9OTeyZY3zzCMLNjPBydFn22H/ESOXOg\nhCG2bt2zf78mxfCgJ2PArQomCrvAOidyewZttr984BG1vFflj9LkFhbon2j1\nUFttdgRquKf37rZBUOOWc9ZOohO0bzZeqdQK3bF37c3AaBXPfChRq0aLmOBV\nHuIt\r\n=m4xp\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCSgcfoDy7q4VaG+1nOTO9DMN0f9j6DbhPgpw+6agxejQIhALwlEV74SG05RM5Q96YqK5SXoiGuHX0JzSuzF82LaDdm"}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"haydendaly","email":"haydencdaly@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.12.3_1625776187833_0.03478216140072221"},"_hasShrinkwrap":false},"0.13.0":{"name":"expo-notifications","version":"0.13.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"^3.1.0","@expo/image-utils":"^0.3.16","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.0.0","expo-constants":"~12.0.0","expo-modules-core":"~0.4.0","fs-extra":"^9.0.1","unimodules-task-manager-interface":"~7.0.0","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"1fffde73411ee7a642b98f1506a8de921805d52b","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications in the foreground and background,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\n<details><summary><strong>Expand to view how the notification icon and the default color can be customized in a plain React Native app</strong></summary> <p>\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n</p>\n</details>\n\n### Config plugin setup (optional)\n\nIf you're using EAS Build, you can set your Android notification icon and color tint, add custom push notification sounds, and set your iOS notification environment using the expo-notifications config plugin ([what's a config plugin?](http://docs.expo.io/guides/config-plugins/)). To setup, just add the config plugin to the plugins array of your `app.json` or `app.config.js` as shown below, then rebuild the app.\n\n```json\n{\n  \"expo\": {\n    ...\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"icon\": \"./local/path/to/myNotificationIcon.png\",\n          \"color\": \"#ffffff\",\n          \"sounds\": [\"./local/path/to/mySound.wav\", \"./local/path/to/myOtherSound.wav\"],\n          \"mode\": \"production\"\n        }\n      ]\n    ],\n  }\n}\n```\n\n<details><summary><strong>Expand to view property descriptions and default values</strong></summary> <p>\n\n- **icon**: Android only. Local path to an image to use as the icon for push notifications. 96x96 all-white png with transparency.\n- **color**: Android only. Tint color for the push notification image when it appears in the notification tray. Default: \"#ffffff\".\n- **sounds**: Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.\n- **mode**: iOS only. Environment of the app: either 'development' or 'production'. Default: 'development'.\n\n</p>\n</details>\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds\n\nCustom notification sounds are only supported when using [EAS Build](https://docs.expo.io/build/introduction/), or in the bare workflow.\n\nTo add custom push notification sounds to your app, add the `expo-notifications` plugin to your `app.json` file:\n\n```json\n{\n  \"expo\": {\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"sounds\": [\"local/path/to/mySoundFile.wav\"]\n        }\n      ]\n    ]\n  }\n}\n```\n\nAfter building your app, the array of files will be available for use in both [`NotificationContentInput`](#notificationcontentinput) and [`NotificationChannelInput`](#notificationchannelinput). You _only_ need to provide the base filename- here's an example using the config above:\n\n```ts\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  sound: 'mySoundFile.wav', // Provide ONLY the base filename\n});\n\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    sound: 'mySoundFile.wav', // Provide ONLY the base filename\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails',\n  },\n});\n```\n\nYou can also manually add notification files to your Android and iOS projects if you prefer:\n\n<details><summary><strong>Manually adding notification sounds on Android</strong></summary> <p>\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\nFor the example below to work, you would place your `email-sound.wav` file in `android/app/src/main/res/raw/`.\n\n```ts\n// Prepare the notification channel\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n</p>\n</details>\n\n<details><summary><strong>Manually adding notification sounds on iOS</strong></summary> <p>\n\nOn iOS, all that's needed is to place your sound file in your Xcode project, and then specify the sound file in your `NotificationContentInput`, like this:\n\n```ts\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'notification.wav',\n  },\n  trigger: {\n    // ...\n  },\n});\n```\n\n</p>\n</details>\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\nNotification events include incoming notifications, interactions your users perform with notifications (this can be tapping on a notification, or interacting with it via [notification categories](#managing-notification-categories-interactive-notifications)), and rare occasions when your notifications may be dropped.\n\nA few different listeners are exposed, so we've provided a chart below which will hopefully help you understand when you can expect each one to be triggered:\n\n| User interacted with notification? | App state  | Listener(s) triggered                                                   |\n| :--------------------------------- | :--------: | ----------------------------------------------------------------------- |\n| false                              | Foreground | `NotificationReceivedListener`                                          |\n| false                              | Background | `BackgroundNotificationTask`                                            |\n| false                              |   Killed   | none                                                                    |\n| true                               | Foreground | `NotificationReceivedListener` & `NotificationResponseReceivedListener` |\n| true                               | Background | `NotificationResponseReceivedListener`                                  |\n| true                               |   Killed   | `NotificationResponseReceivedListener`                                  |\n\n> In the chart above, whenever `NotificationResponseReceivedListener` is triggered, the same would apply to the `useLastNotificationResponse` hook.\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Handling incoming notifications when the app is not in the foreground (not supported in Expo Go)\n\n> **Please note:** In order to handle notifications while the app is backgrounded on iOS, you _must_ add `remote-notification` to the `ios.infoPlist.UIBackgroundModes` key in your app.json, **and** add `\"content-available\": 1` to your push notification payload. Under normal circumstances, the ‚Äúcontent-available‚Äù flag should launch your app if it isn‚Äôt running and wasn‚Äôt killed by the user, _however_, this is ultimately decided by the OS so it might not always happen.\n\n### `registerTaskAsync(taskName: string): void`\n\nWhen a notification is received while the app is backgrounded, using this function you can set a callback that will be run in response to that notification. Under the hood, this function is run using `expo-task-manager`. You **must** define the task _first_, with [`TaskManager.defineTask`](https://docs.expo.io/versions/latest/sdk/task-manager/#taskmanagerdefinetasktaskname-task). Make sure you define it in the global scope.\n\nThe `taskName` argument is the string you passed to `TaskManager.defineTask` as the \"taskName\". The callback function you define with `TaskManager.defineTask` will receive the following arguments:\n\n- **data**: The remote payload delivered by either FCM (Android) or APNs (iOS). [See here for details](#pushnotificationtrigger).\n- **error**: The error (if any) that occurred during execution of the task.\n- **executionInfo**: JSON object of additional info related to the task, including the `taskName`.\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n### `unregisterTaskAsync(taskName: string): void`\n\nUsed to unregister tasks registered with `registerTaskAsync`.\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n> On Android, setting `shouldPlaySound: false` will result in the drop-down notification alert **not** showing, no matter what the priority is. This setting will also override any channel-specific sounds you may have configured.\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.13.0","_nodeVersion":"16.0.0","_npmVersion":"6.14.13","dist":{"integrity":"sha512-GoxOyzSzBNhlWqJTTIZGlbDAjuBeM59/1hIAmNKJJe+eGTeRRnCAyZ3Ak6OAdLF27Ue0uqRq9q0JVtzHphJ4iA==","shasum":"7092a004e9f0b9f101c2c5ff741b79fe47c5803a","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.13.0.tgz","fileCount":499,"unpackedSize":3139427,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCID3kNdO8xlG51n9Ab+3bejDk89CR7SyC4H9UOLh0dQkJAiBdNG8NbmSMhXfIm+bpAEPYHaDLIE8AiKKqFJgDDlYMlw=="}]},"_npmUser":{"name":"tsapeta","email":"npm@tsapeta.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"fson","email":"ville.immonen@iki.fi"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"haydendaly","email":"haydencdaly@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.13.0_1632842481802_0.8650037422351124"},"_hasShrinkwrap":false},"0.13.1":{"name":"expo-notifications","version":"0.13.1","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"^3.1.0","@expo/image-utils":"^0.3.16","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.0.0","expo-constants":"~12.1.0","expo-modules-core":"~0.4.2","fs-extra":"^9.0.1","unimodules-task-manager-interface":"~7.0.1","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"2718b696f4a6919905b0f47ebb24ff65b42d8ff9","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications in the foreground and background,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\n<details><summary><strong>Expand to view how the notification icon and the default color can be customized in a plain React Native app</strong></summary> <p>\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n</p>\n</details>\n\n### Config plugin setup (optional)\n\nIf you're using EAS Build, you can set your Android notification icon and color tint, add custom push notification sounds, and set your iOS notification environment using the expo-notifications config plugin ([what's a config plugin?](http://docs.expo.io/guides/config-plugins/)). To setup, just add the config plugin to the plugins array of your `app.json` or `app.config.js` as shown below, then rebuild the app.\n\n```json\n{\n  \"expo\": {\n    ...\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"icon\": \"./local/path/to/myNotificationIcon.png\",\n          \"color\": \"#ffffff\",\n          \"sounds\": [\"./local/path/to/mySound.wav\", \"./local/path/to/myOtherSound.wav\"],\n          \"mode\": \"production\"\n        }\n      ]\n    ],\n  }\n}\n```\n\n<details><summary><strong>Expand to view property descriptions and default values</strong></summary> <p>\n\n- **icon**: Android only. Local path to an image to use as the icon for push notifications. 96x96 all-white png with transparency.\n- **color**: Android only. Tint color for the push notification image when it appears in the notification tray. Default: \"#ffffff\".\n- **sounds**: Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.\n- **mode**: iOS only. Environment of the app: either 'development' or 'production'. Default: 'development'.\n\n</p>\n</details>\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds\n\nCustom notification sounds are only supported when using [EAS Build](https://docs.expo.io/build/introduction/), or in the bare workflow.\n\nTo add custom push notification sounds to your app, add the `expo-notifications` plugin to your `app.json` file:\n\n```json\n{\n  \"expo\": {\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"sounds\": [\"local/path/to/mySoundFile.wav\"]\n        }\n      ]\n    ]\n  }\n}\n```\n\nAfter building your app, the array of files will be available for use in both [`NotificationContentInput`](#notificationcontentinput) and [`NotificationChannelInput`](#notificationchannelinput). You _only_ need to provide the base filename- here's an example using the config above:\n\n```ts\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  sound: 'mySoundFile.wav', // Provide ONLY the base filename\n});\n\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    sound: 'mySoundFile.wav', // Provide ONLY the base filename\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails',\n  },\n});\n```\n\nYou can also manually add notification files to your Android and iOS projects if you prefer:\n\n<details><summary><strong>Manually adding notification sounds on Android</strong></summary> <p>\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\nFor the example below to work, you would place your `email-sound.wav` file in `android/app/src/main/res/raw/`.\n\n```ts\n// Prepare the notification channel\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n</p>\n</details>\n\n<details><summary><strong>Manually adding notification sounds on iOS</strong></summary> <p>\n\nOn iOS, all that's needed is to place your sound file in your Xcode project, and then specify the sound file in your `NotificationContentInput`, like this:\n\n```ts\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'notification.wav',\n  },\n  trigger: {\n    // ...\n  },\n});\n```\n\n</p>\n</details>\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\nNotification events include incoming notifications, interactions your users perform with notifications (this can be tapping on a notification, or interacting with it via [notification categories](#managing-notification-categories-interactive-notifications)), and rare occasions when your notifications may be dropped.\n\nA few different listeners are exposed, so we've provided a chart below which will hopefully help you understand when you can expect each one to be triggered:\n\n| User interacted with notification? | App state  | Listener(s) triggered                                                   |\n| :--------------------------------- | :--------: | ----------------------------------------------------------------------- |\n| false                              | Foreground | `NotificationReceivedListener`                                          |\n| false                              | Background | `BackgroundNotificationTask`                                            |\n| false                              |   Killed   | none                                                                    |\n| true                               | Foreground | `NotificationReceivedListener` & `NotificationResponseReceivedListener` |\n| true                               | Background | `NotificationResponseReceivedListener`                                  |\n| true                               |   Killed   | `NotificationResponseReceivedListener`                                  |\n\n> In the chart above, whenever `NotificationResponseReceivedListener` is triggered, the same would apply to the `useLastNotificationResponse` hook.\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Handling incoming notifications when the app is not in the foreground (not supported in Expo Go)\n\n> **Please note:** In order to handle notifications while the app is backgrounded on iOS, you _must_ add `remote-notification` to the `ios.infoPlist.UIBackgroundModes` key in your app.json, **and** add `\"content-available\": 1` to your push notification payload. Under normal circumstances, the ‚Äúcontent-available‚Äù flag should launch your app if it isn‚Äôt running and wasn‚Äôt killed by the user, _however_, this is ultimately decided by the OS so it might not always happen.\n\n### `registerTaskAsync(taskName: string): void`\n\nWhen a notification is received while the app is backgrounded, using this function you can set a callback that will be run in response to that notification. Under the hood, this function is run using `expo-task-manager`. You **must** define the task _first_, with [`TaskManager.defineTask`](https://docs.expo.io/versions/latest/sdk/task-manager/#taskmanagerdefinetasktaskname-task). Make sure you define it in the global scope.\n\nThe `taskName` argument is the string you passed to `TaskManager.defineTask` as the \"taskName\". The callback function you define with `TaskManager.defineTask` will receive the following arguments:\n\n- **data**: The remote payload delivered by either FCM (Android) or APNs (iOS). [See here for details](#pushnotificationtrigger).\n- **error**: The error (if any) that occurred during execution of the task.\n- **executionInfo**: JSON object of additional info related to the task, including the `taskName`.\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n### `unregisterTaskAsync(taskName: string): void`\n\nUsed to unregister tasks registered with `registerTaskAsync`.\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n> On Android, setting `shouldPlaySound: false` will result in the drop-down notification alert **not** showing, no matter what the priority is. This setting will also override any channel-specific sounds you may have configured.\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.13.1","_nodeVersion":"14.15.2","_npmVersion":"7.20.3","dist":{"integrity":"sha512-mWzsT2o1mXPdcoVhr7sApljXYzqyCUHNsdRFAUTeznJrw2NeoWQtFtGiI1lM4dWoz1b/rgFdDRxPe+3NTkuHLA==","shasum":"c3c1302fc8056055f0852e2aadfef43d6ccc006d","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.13.1.tgz","fileCount":499,"unpackedSize":3139850,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIAfLnlu18YSrEkYcse9hX+ntbGSuBBof6LeXbDmuJVVeAiEAlWDsUxShgWZJnFIuDtvAKbHksbKO2PcLBOlmt1QLUWA="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.13.1_1633129577487_0.9804668748789727"},"_hasShrinkwrap":false},"0.13.2":{"name":"expo-notifications","version":"0.13.2","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"^3.1.0","@expo/image-utils":"^0.3.16","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.0.0","expo-constants":"~12.1.1","expo-modules-core":"~0.4.3","fs-extra":"^9.0.1","unimodules-task-manager-interface":"~7.0.2","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"d23e1ac491da96b51c25eb2533efcd56499ee287","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications in the foreground and background,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.io/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `react-native-unimodules` package](https://github.com/expo/expo/tree/master/packages/react-native-unimodules) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.io/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\n<details><summary><strong>Expand to view how the notification icon and the default color can be customized in a plain React Native app</strong></summary> <p>\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n</p>\n</details>\n\n### Config plugin setup (optional)\n\nIf you're using EAS Build, you can set your Android notification icon and color tint, add custom push notification sounds, and set your iOS notification environment using the expo-notifications config plugin ([what's a config plugin?](http://docs.expo.io/guides/config-plugins/)). To setup, just add the config plugin to the plugins array of your `app.json` or `app.config.js` as shown below, then rebuild the app.\n\n```json\n{\n  \"expo\": {\n    ...\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"icon\": \"./local/path/to/myNotificationIcon.png\",\n          \"color\": \"#ffffff\",\n          \"sounds\": [\"./local/path/to/mySound.wav\", \"./local/path/to/myOtherSound.wav\"],\n          \"mode\": \"production\"\n        }\n      ]\n    ],\n  }\n}\n```\n\n<details><summary><strong>Expand to view property descriptions and default values</strong></summary> <p>\n\n- **icon**: Android only. Local path to an image to use as the icon for push notifications. 96x96 all-white png with transparency.\n- **color**: Android only. Tint color for the push notification image when it appears in the notification tray. Default: \"#ffffff\".\n- **sounds**: Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.\n- **mode**: iOS only. Environment of the app: either 'development' or 'production'. Default: 'development'.\n\n</p>\n</details>\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.io/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds\n\nCustom notification sounds are only supported when using [EAS Build](https://docs.expo.io/build/introduction/), or in the bare workflow.\n\nTo add custom push notification sounds to your app, add the `expo-notifications` plugin to your `app.json` file:\n\n```json\n{\n  \"expo\": {\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"sounds\": [\"local/path/to/mySoundFile.wav\"]\n        }\n      ]\n    ]\n  }\n}\n```\n\nAfter building your app, the array of files will be available for use in both [`NotificationContentInput`](#notificationcontentinput) and [`NotificationChannelInput`](#notificationchannelinput). You _only_ need to provide the base filename- here's an example using the config above:\n\n```ts\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  sound: 'mySoundFile.wav', // Provide ONLY the base filename\n});\n\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    sound: 'mySoundFile.wav', // Provide ONLY the base filename\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails',\n  },\n});\n```\n\nYou can also manually add notification files to your Android and iOS projects if you prefer:\n\n<details><summary><strong>Manually adding notification sounds on Android</strong></summary> <p>\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\nFor the example below to work, you would place your `email-sound.wav` file in `android/app/src/main/res/raw/`.\n\n```ts\n// Prepare the notification channel\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n</p>\n</details>\n\n<details><summary><strong>Manually adding notification sounds on iOS</strong></summary> <p>\n\nOn iOS, all that's needed is to place your sound file in your Xcode project, and then specify the sound file in your `NotificationContentInput`, like this:\n\n```ts\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'notification.wav',\n  },\n  trigger: {\n    // ...\n  },\n});\n```\n\n</p>\n</details>\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.io/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.io/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/master/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.io/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.io/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.io/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.io/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.io/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.io/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\nNotification events include incoming notifications, interactions your users perform with notifications (this can be tapping on a notification, or interacting with it via [notification categories](#managing-notification-categories-interactive-notifications)), and rare occasions when your notifications may be dropped.\n\nA few different listeners are exposed, so we've provided a chart below which will hopefully help you understand when you can expect each one to be triggered:\n\n| User interacted with notification? | App state  | Listener(s) triggered                                                   |\n| :--------------------------------- | :--------: | ----------------------------------------------------------------------- |\n| false                              | Foreground | `NotificationReceivedListener`                                          |\n| false                              | Background | `BackgroundNotificationTask`                                            |\n| false                              |   Killed   | none                                                                    |\n| true                               | Foreground | `NotificationReceivedListener` & `NotificationResponseReceivedListener` |\n| true                               | Background | `NotificationResponseReceivedListener`                                  |\n| true                               |   Killed   | `NotificationResponseReceivedListener`                                  |\n\n> In the chart above, whenever `NotificationResponseReceivedListener` is triggered, the same would apply to the `useLastNotificationResponse` hook.\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Handling incoming notifications when the app is not in the foreground (not supported in Expo Go)\n\n> **Please note:** In order to handle notifications while the app is backgrounded on iOS, you _must_ add `remote-notification` to the `ios.infoPlist.UIBackgroundModes` key in your app.json, **and** add `\"content-available\": 1` to your push notification payload. Under normal circumstances, the ‚Äúcontent-available‚Äù flag should launch your app if it isn‚Äôt running and wasn‚Äôt killed by the user, _however_, this is ultimately decided by the OS so it might not always happen.\n\n### `registerTaskAsync(taskName: string): void`\n\nWhen a notification is received while the app is backgrounded, using this function you can set a callback that will be run in response to that notification. Under the hood, this function is run using `expo-task-manager`. You **must** define the task _first_, with [`TaskManager.defineTask`](https://docs.expo.io/versions/latest/sdk/task-manager/#taskmanagerdefinetasktaskname-task). Make sure you define it in the global scope.\n\nThe `taskName` argument is the string you passed to `TaskManager.defineTask` as the \"taskName\". The callback function you define with `TaskManager.defineTask` will receive the following arguments:\n\n- **data**: The remote payload delivered by either FCM (Android) or APNs (iOS). [See here for details](#pushnotificationtrigger).\n- **error**: The error (if any) that occurred during execution of the task.\n- **executionInfo**: JSON object of additional info related to the task, including the `taskName`.\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n### `unregisterTaskAsync(taskName: string): void`\n\nUsed to unregister tasks registered with `registerTaskAsync`.\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n> On Android, setting `shouldPlaySound: false` will result in the drop-down notification alert **not** showing, no matter what the priority is. This setting will also override any channel-specific sounds you may have configured.\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.13.2","_nodeVersion":"14.15.2","_npmVersion":"7.20.3","dist":{"integrity":"sha512-x+u+bTBws7YuKF37BaSUcoVzpv9tkFZ8HZi1g6TdIFGG03iSXtrgjWrqXi3JGBLiR+TDPpQt1dJSo2g32Nn6UA==","shasum":"e2671b6dcb77feddb7d0727cf53fcc02dc2af0a1","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.13.2.tgz","fileCount":499,"unpackedSize":3139936,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIBOKK3mdOKSECQ0DDoSlzTSmcJFr6DJgoYwB0E72L18cAiAm4tRKUAL3JMnjiwb2Oj3Z0BpZ24YajTRohczIWvG2Xg=="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"kgc00","email":"kirbygc00@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.13.2_1634323757122_0.9484639011078213"},"_hasShrinkwrap":false},"0.13.3":{"name":"expo-notifications","version":"0.13.3","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"^4.0.2","@expo/image-utils":"^0.3.16","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.0.0","expo-constants":"~12.1.2","expo-modules-core":"~0.4.4","fs-extra":"^9.0.1","unimodules-task-manager-interface":"~7.0.3","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^2.15.5","node-fetch":"^2.6.1"},"gitHead":"4fa0497a180ae707fa860cb03858630ab7af19f4","_id":"expo-notifications@0.13.3","_nodeVersion":"14.15.2","_npmVersion":"7.20.3","dist":{"integrity":"sha512-2iQVydhLZ+S3s/tKdcBPRWQyqztQOyex9WaSDj/2noKLWBpIqFouV/Dln+8vYj/BAKb0JoeHko6XA+wnel7qdA==","shasum":"94e638f8ef56de4ddb67ed8cc2a36510a1d90cbc","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.13.3.tgz","fileCount":499,"unpackedSize":3140022,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIH8TM3BxKO+7V/KvP1Edxer0AQZ2Zu6raCdv3bSm0wPCAiEAsJAghBtVmsEHr+/90v9auNdPDt9F97xkfQHPA/l7aHM="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"kgc00","email":"kirbygc00@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.13.3_1634850662328_0.15574395557573872"},"_hasShrinkwrap":false},"0.14.0":{"name":"expo-notifications","version":"0.14.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"^4.0.2","@expo/image-utils":"^0.3.16","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.0.0","expo-constants":"~13.0.0","fs-extra":"^9.1.0","unimodules-task-manager-interface":"~7.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^3.2.0","node-fetch":"^2.6.1"},"peerDependencies":{"expo":"*"},"gitHead":"2e5c6983b86d5ecfca028ba64002897d8adc2cc4","_id":"expo-notifications@0.14.0","_nodeVersion":"16.13.0","_npmVersion":"8.1.0","dist":{"integrity":"sha512-6Fj58FrPng6GS+TBQPdSL5wZWztJS5qPxL/hEoB0olirsgw07+C5CPy0TkF5bUM1PjwDKuqqyfVsLxdNodB0Dg==","shasum":"e58c13e2d47e26a1b8c6b4a64cf181771f5d69f4","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.14.0.tgz","fileCount":499,"unpackedSize":3140159,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhqohFCRA9TVsSAnZWagAADFUP/1dbE0qi9j3NeczaEs3f\nJG1ifQy6mIKk4jGH3DcK4advlPhjLVjhOgBy3ZHijI/QLGahSpFneH0x8pFw\n6fr1GjlVNQD1b20dTgtKSJpZ7Eoau+GhvogAoi7BDFbch9OnsXtt5/PQUmzm\nW38Rm0IfbjE6qm6zcym4KJ+RX4XumRrUk0VIbeRBjP/l1pF1itpbn7yF7Mv7\nI5Z+joG5h516RqdlHkifKaW7Z3zcheSpiOMdlkIlVY5BXlgRQjNhyWsXXD8D\nAi+0Pr/WcSWkxMEWcQMu/COz/+q/pF+oAs892FB+J1tc0Bb3bfgxRQsCgV3k\nnVMYAzp+G+IDq7d5Rsa9v7pirhWxLiZ1v+UFXf/IrcVMYMkerDEgNDpAO+tf\nay1pAorYkVOirOAYnUfxcFVQZlueZgIpUvYhAgGqefESyVetL1hVUfy25RVd\nBY5noCcEx6UhBfansUPjSyMQ4BySWG/29waslgKZm09mJRFb6Ne8ASXTPAYY\n1Ddornz50L8EtAp58neaCBQ0KeCEvI1zaM06oTnscwJBiL6TbWF0QlAmUE09\n7gluztmOHzqe6dxIVdalM5QBEkfoIupOuaACljjI47AAtlwa4w0rVZMwoRGD\ndwyDAZBHdakD0ZJOQzoyVAa54Smv/I98ak3YPZuV5AhPCSPfl/lWVv32WfmV\niEJ7\r\n=T5t2\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQC51+oPw+m/TmV1tVx6Srqmw5DKBLJcqzan1RTvQJ+krgIhAPOlg0i/LLY34paMtk/HI/6Zp29OLizfCtFYwGcqdeFv"}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"kgc00","email":"kirbygc00@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.14.0_1638565957233_0.8478202800803891"},"_hasShrinkwrap":false},"0.14.1":{"name":"expo-notifications","version":"0.14.1","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"^4.0.2","@expo/image-utils":"^0.3.16","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.0.0","expo-constants":"~13.0.0","fs-extra":"^9.1.0","unimodules-task-manager-interface":"~7.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^3.2.0","node-fetch":"^2.6.1"},"peerDependencies":{"expo":"*"},"gitHead":"ba24eba18bf4f4d4b0d54828992d81a2bb18246a","_id":"expo-notifications@0.14.1","_nodeVersion":"16.13.1","_npmVersion":"8.1.2","dist":{"integrity":"sha512-0L+DFMQmVfMhonza8MFP4aI/6ADKEx/Mn5NzQlBZpo6PinpsPFpQP7of+pihx2onCkmeN8OIsLFS5O6QqzH3rA==","shasum":"fe2b122ed79488e754b7f993f9b802eaf60b51a3","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.14.1.tgz","fileCount":499,"unpackedSize":3140320,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh+YjGCRA9TVsSAnZWagAA2OQP+wR+oONHpnELuxIA42V+\nekBYgIpshMggzhurb0UeFDrupLCp8SRD+TFWUgPud+Rn+ipacYiKulcoPxpH\nHCbVS2TuDOJs5NPXXgKcexKTu/pCjJ1wjo9qs7aLlUMC760pfsm4pHPevrjl\nmpkThiMRTglyk7XGB8Giv5NyLhhmG47xIPqtJ5i//g6FfDHpU8QKNfveFgus\nnEpnGRnpWT39e4EPMcKg4sb28DiiItzUH9FOCqNGUD+/cgm51bH4mxM0sPlV\nrGyTg8xhTaeMpqcLHS+fb7G5IXF8Dl+DSdw/HADn2paFeLsxN3SeEH1mg3KT\npvkiJvveFD+O0/Trh1FCcwLe26Bi+HTODlnNE9VSro+CJwFTwgHZD9Ib8WfQ\nYs6SnRUz7KKuUN5+P0Mr6A5p7S4GqgCOf7hAOXIOi+EP3hR2uaOUqw+EQQIx\n9cgNMb02yWNBKgkyZqtcO2VcroNWF2WeWDbsE1NyTPuZIoJrJXpTh6oHxoAf\nXuBVe3WLSUlNwA9zt6LPN+28hhksRogFvCNzBnfBsumuxSjfjRbnBPxu31RW\nT+aWRBvRplZbyC/91Ed4pcB96qc9ZWhGL3x6k1pbRVXHNENjECyp9a8qmDz0\nWY7FaTQhTEg8LSVAEhXwozypR43K9rPmnkEvZjr3yX2bjQyIskJuRxFPDiXh\nrxJO\r\n=DqEJ\r\n-----END PGP SIGNATURE-----\r\n","signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIH365l4K0LCACBlmOS2NfZH9UO3HwLnzgeE6V/AWM2qGAiBFtMebY9wj1p9Npzr/QQ1xs+cEPokk1E5KA7ZlTvPjxg=="}]},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"kgc00","email":"kirbygc00@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"charliecruzan","email":"charliecruzan@gmail.com"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"jkhales","email":"jonathan@expo.io"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.14.1_1643743430589_0.33414738184332426"},"_hasShrinkwrap":false},"0.15.0":{"name":"expo-notifications","version":"0.15.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"^4.0.14","@expo/image-utils":"^0.3.18","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.1.0","expo-constants":"~13.1.0","fs-extra":"^9.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^3.2.0","node-fetch":"^2.6.7"},"peerDependencies":{"expo":"*"},"gitHead":"22dce752354bb429c84851bc4389abe47a766b1f","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications in the foreground and background,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.dev/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `expo` package](https://docs.expo.dev/bare/installing-expo-modules/) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.dev/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\n<details><summary><strong>Expand to view how the notification icon and the default color can be customized in a plain React Native app</strong></summary> <p>\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n</p>\n</details>\n\n### Config plugin setup (optional)\n\nIf you're using EAS Build, you can set your Android notification icon and color tint, add custom push notification sounds, and set your iOS notification environment using the expo-notifications config plugin ([what's a config plugin?](http://docs.expo.dev/guides/config-plugins/)). To setup, just add the config plugin to the plugins array of your `app.json` or `app.config.js` as shown below, then rebuild the app.\n\n```json\n{\n  \"expo\": {\n    ...\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"icon\": \"./local/path/to/myNotificationIcon.png\",\n          \"color\": \"#ffffff\",\n          \"sounds\": [\"./local/path/to/mySound.wav\", \"./local/path/to/myOtherSound.wav\"],\n          \"mode\": \"production\"\n        }\n      ]\n    ],\n  }\n}\n```\n\n<details><summary><strong>Expand to view property descriptions and default values</strong></summary> <p>\n\n- **icon**: Android only. Local path to an image to use as the icon for push notifications. 96x96 all-white png with transparency.\n- **color**: Android only. Tint color for the push notification image when it appears in the notification tray. Default: \"#ffffff\".\n- **sounds**: Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.\n- **mode**: iOS only. Environment of the app: either 'development' or 'production'. Default: 'development'.\n\n</p>\n</details>\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.dev/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds\n\nCustom notification sounds are only supported when using [EAS Build](https://docs.expo.dev/build/introduction/), or in the bare workflow.\n\nTo add custom push notification sounds to your app, add the `expo-notifications` plugin to your `app.json` file:\n\n```json\n{\n  \"expo\": {\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"sounds\": [\"local/path/to/mySoundFile.wav\"]\n        }\n      ]\n    ]\n  }\n}\n```\n\nAfter building your app, the array of files will be available for use in both [`NotificationContentInput`](#notificationcontentinput) and [`NotificationChannelInput`](#notificationchannelinput). You _only_ need to provide the base filename- here's an example using the config above:\n\n```ts\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  sound: 'mySoundFile.wav', // Provide ONLY the base filename\n});\n\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    sound: 'mySoundFile.wav', // Provide ONLY the base filename\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails',\n  },\n});\n```\n\nYou can also manually add notification files to your Android and iOS projects if you prefer:\n\n<details><summary><strong>Manually adding notification sounds on Android</strong></summary> <p>\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\nFor the example below to work, you would place your `email-sound.wav` file in `android/app/src/main/res/raw/`.\n\n```ts\n// Prepare the notification channel\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n</p>\n</details>\n\n<details><summary><strong>Manually adding notification sounds on iOS</strong></summary> <p>\n\nOn iOS, all that's needed is to place your sound file in your Xcode project, and then specify the sound file in your `NotificationContentInput`, like this:\n\n```ts\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'notification.wav',\n  },\n  trigger: {\n    // ...\n  },\n});\n```\n\n</p>\n</details>\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.dev/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.dev/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/main/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.dev/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.dev/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.dev/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.dev/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.dev/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.dev/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\nNotification events include incoming notifications, interactions your users perform with notifications (this can be tapping on a notification, or interacting with it via [notification categories](#managing-notification-categories-interactive-notifications)), and rare occasions when your notifications may be dropped.\n\nA few different listeners are exposed, so we've provided a chart below which will hopefully help you understand when you can expect each one to be triggered:\n\n| User interacted with notification? | App state  | Listener(s) triggered                                                   |\n| :--------------------------------- | :--------: | ----------------------------------------------------------------------- |\n| false                              | Foreground | `NotificationReceivedListener`                                          |\n| false                              | Background | `BackgroundNotificationTask`                                            |\n| false                              |   Killed   | none                                                                    |\n| true                               | Foreground | `NotificationReceivedListener` & `NotificationResponseReceivedListener` |\n| true                               | Background | `NotificationResponseReceivedListener`                                  |\n| true                               |   Killed   | `NotificationResponseReceivedListener`                                  |\n\n> In the chart above, whenever `NotificationResponseReceivedListener` is triggered, the same would apply to the `useLastNotificationResponse` hook.\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Handling incoming notifications when the app is not in the foreground (not supported in Expo Go)\n\n> **Please note:** In order to handle notifications while the app is backgrounded on iOS, you _must_ add `remote-notification` to the `ios.infoPlist.UIBackgroundModes` key in your app.json, **and** add `\"content-available\": 1` to your push notification payload. Under normal circumstances, the ‚Äúcontent-available‚Äù flag should launch your app if it isn‚Äôt running and wasn‚Äôt killed by the user, _however_, this is ultimately decided by the OS so it might not always happen.\n\n### `registerTaskAsync(taskName: string): void`\n\nWhen a notification is received while the app is backgrounded, using this function you can set a callback that will be run in response to that notification. Under the hood, this function is run using `expo-task-manager`. You **must** define the task _first_, with [`TaskManager.defineTask`](https://docs.expo.dev/versions/latest/sdk/task-manager/#taskmanagerdefinetasktaskname-task). Make sure you define it in the global scope.\n\nThe `taskName` argument is the string you passed to `TaskManager.defineTask` as the \"taskName\". The callback function you define with `TaskManager.defineTask` will receive the following arguments:\n\n- **data**: The remote payload delivered by either FCM (Android) or APNs (iOS). [See here for details](#pushnotificationtrigger).\n- **error**: The error (if any) that occurred during execution of the task.\n- **executionInfo**: JSON object of additional info related to the task, including the `taskName`.\n\n#### Examples\n\n```ts\nimport * as TaskManager from 'expo-task-manager';\nimport * as Notifications from 'expo-notifications';\n\nconst BACKGROUND_NOTIFICATION_TASK = 'BACKGROUND-NOTIFICATION-TASK';\n\nTaskManager.defineTask(BACKGROUND_NOTIFICATION_TASK, ({ data, error, executionInfo }) => {\n  console.log('Received a notification in the background!');\n  // Do something with the notification data\n});\n\nNotifications.registerTaskAsync(BACKGROUND_NOTIFICATION_TASK);\n```\n\n### `unregisterTaskAsync(taskName: string): void`\n\nUsed to unregister tasks registered with `registerTaskAsync`.\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n> On Android, setting `shouldPlaySound: false` will result in the drop-down notification alert **not** showing, no matter what the priority is. This setting will also override any channel-specific sounds you may have configured.\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.15.0","_nodeVersion":"16.0.0","_npmVersion":"6.14.15","dist":{"integrity":"sha512-iD7Q7t/J3m1TTI5AXFsFOTKuFotVXrTWmOfD6A4vT2tB0svBCUgJoAIipB+8trTRh86z25uMMPoPq83W2keI8w==","shasum":"4ef5f1d58ec17cda841a53fe5be5904f9e322dfb","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.15.0.tgz","fileCount":583,"unpackedSize":3165310,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIEB2GWyDioHwOANRSlBdCFQEA5fWGOFsFfM5pZW+XO5PAiEA1vqDzKWZRz5EzQZ0VtEBic9pyPSR5d/B+oVASscgh8I="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiXX+6ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrhshAAminzWNSPRR66b1ud44rWO4GGHz+IDW1905cs9l1fyzCLJCt5\r\nF6KXZZeCQJFgWEe00MWJP++BYWl36j+Km9x5k7PZzFVJSliQjZaQAGrd1d38\r\nMGenWyJaTs43r5qPn/hSlSUsIQLzST80UU1Lcjg02LBoEP7DqFu8fB4zzRmy\r\nA9bVzg3diQfnjV7U5m1XESlIdg5ViajDuZPt6hi3nUJP1888ZmCufpad4yQ0\r\nmJQabyY72NSBNVmbzOiXH4rPH6v0Xv21EgoOouSYLnd598g4m+HZHX0BRrVH\r\nkMpgqm/dOz2e75Lu3exrnVLVyPjQE00JgC59JIF/rvivj0GQPTZ2+NowREb9\r\nUdGDzz73Kz7p8KzG1R94a54sDBhd8gc8eFd3g1fJxD7FnCB/7umqrJxNK3oq\r\nYqI361LhIUYiO/u7JWSR5nrzHZuCrljhIHeO87dENcNBx0nx19sZX5+B/i62\r\nTA/eXZ1uN1uLB4fpcq/jamce/EL0jhs30xfmDxSZgHBTH2PUNujoJpQJkOW3\r\nHsFY7iNVqX7cSX06LLqCxNiFkZU6VIRHynlGosbN0oPF8FsoRUqTEUatZzd2\r\nWLNZhkqrrIbeDHTDjjKjhmEZPWmZV2esfDKzvkxnLIo1mTaFDibNKoKSkBju\r\nr8ftERo+Zxf2McARA5aCSgr7T6eHYpMHEAE=\r\n=9Z1S\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"tsapeta","email":"npm@tsapeta.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"kbrandwijk","email":"kim.brandwijk@gmail.com"},{"name":"kgc00","email":"kirbygc00@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.15.0_1650294714318_0.4576069307352826"},"_hasShrinkwrap":false},"0.15.1":{"name":"expo-notifications","version":"0.15.1","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"^4.0.14","@expo/image-utils":"^0.3.18","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.1.0","expo-constants":"~13.1.0","fs-extra":"^9.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^3.2.0","node-fetch":"^2.6.7"},"peerDependencies":{"expo":"*"},"gitHead":"be6e0e7ea3f7fd1ab8368137260a7ad1b1bf12a8","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications in the foreground and background,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.dev/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `expo` package](https://docs.expo.dev/bare/installing-expo-modules/) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.dev/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\n<details><summary><strong>Expand to view how the notification icon and the default color can be customized in a plain React Native app</strong></summary> <p>\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n</p>\n</details>\n\n### Config plugin setup (optional)\n\nIf you're using EAS Build, you can set your Android notification icon and color tint, add custom push notification sounds, and set your iOS notification environment using the expo-notifications config plugin ([what's a config plugin?](http://docs.expo.dev/guides/config-plugins/)). To setup, just add the config plugin to the plugins array of your `app.json` or `app.config.js` as shown below, then rebuild the app.\n\n```json\n{\n  \"expo\": {\n    ...\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"icon\": \"./local/path/to/myNotificationIcon.png\",\n          \"color\": \"#ffffff\",\n          \"sounds\": [\"./local/path/to/mySound.wav\", \"./local/path/to/myOtherSound.wav\"],\n          \"mode\": \"production\"\n        }\n      ]\n    ],\n  }\n}\n```\n\n<details><summary><strong>Expand to view property descriptions and default values</strong></summary> <p>\n\n- **icon**: Android only. Local path to an image to use as the icon for push notifications. 96x96 all-white png with transparency.\n- **color**: Android only. Tint color for the push notification image when it appears in the notification tray. Default: \"#ffffff\".\n- **sounds**: Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.\n- **mode**: iOS only. Environment of the app: either 'development' or 'production'. Default: 'development'.\n\n</p>\n</details>\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.dev/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds\n\nCustom notification sounds are only supported when using [EAS Build](https://docs.expo.dev/build/introduction/), or in the bare workflow.\n\nTo add custom push notification sounds to your app, add the `expo-notifications` plugin to your `app.json` file:\n\n```json\n{\n  \"expo\": {\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"sounds\": [\"local/path/to/mySoundFile.wav\"]\n        }\n      ]\n    ]\n  }\n}\n```\n\nAfter building your app, the array of files will be available for use in both [`NotificationContentInput`](#notificationcontentinput) and [`NotificationChannelInput`](#notificationchannelinput). You _only_ need to provide the base filename- here's an example using the config above:\n\n```ts\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  sound: 'mySoundFile.wav', // Provide ONLY the base filename\n});\n\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    sound: 'mySoundFile.wav', // Provide ONLY the base filename\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails',\n  },\n});\n```\n\nYou can also manually add notification files to your Android and iOS projects if you prefer:\n\n<details><summary><strong>Manually adding notification sounds on Android</strong></summary> <p>\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\nFor the example below to work, you would place your `email-sound.wav` file in `android/app/src/main/res/raw/`.\n\n```ts\n// Prepare the notification channel\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n</p>\n</details>\n\n<details><summary><strong>Manually adding notification sounds on iOS</strong></summary> <p>\n\nOn iOS, all that's needed is to place your sound file in your Xcode project, and then specify the sound file in your `NotificationContentInput`, like this:\n\n```ts\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'notification.wav',\n  },\n  trigger: {\n    // ...\n  },\n});\n```\n\n</p>\n</details>\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.dev/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.dev/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/main/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.dev/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.dev/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.dev/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.dev/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.dev/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.dev/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\nNotification events include incoming notifications, interactions your users perform with notifications (this can be tapping on a notification, or interacting with it via [notification categories](#managing-notification-categories-interactive-notifications)), and rare occasions when your notifications may be dropped.\n\nA few different listeners are exposed, so we've provided a chart below which will hopefully help you understand when you can expect each one to be triggered:\n\n| User interacted with notification? | App state  | Listener(s) triggered                                                   |\n| :--------------------------------- | :--------: | ----------------------------------------------------------------------- |\n| false                              | Foreground | `NotificationReceivedListener`                                          |\n| false                              | Background | `BackgroundNotificationTask`                                            |\n| false                              |   Killed   | none                                                                    |\n| true                               | Foreground | `NotificationReceivedListener` & `NotificationResponseReceivedListener` |\n| true                               | Background | `NotificationResponseReceivedListener`                                  |\n| true                               |   Killed   | `NotificationResponseReceivedListener`                                  |\n\n> In the chart above, whenever `NotificationResponseReceivedListener` is triggered, the same would apply to the `useLastNotificationResponse` hook.\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Handling incoming notifications when the app is not in the foreground (not supported in Expo Go)\n\n> **Please note:** In order to handle notifications while the app is backgrounded on iOS, you _must_ add `remote-notification` to the `ios.infoPlist.UIBackgroundModes` key in your app.json, **and** add `\"content-available\": 1` to your push notification payload. Under normal circumstances, the ‚Äúcontent-available‚Äù flag should launch your app if it isn‚Äôt running and wasn‚Äôt killed by the user, _however_, this is ultimately decided by the OS so it might not always happen.\n\n### `registerTaskAsync(taskName: string): void`\n\nWhen a notification is received while the app is backgrounded, using this function you can set a callback that will be run in response to that notification. Under the hood, this function is run using `expo-task-manager`. You **must** define the task _first_, with [`TaskManager.defineTask`](https://docs.expo.dev/versions/latest/sdk/task-manager/#taskmanagerdefinetasktaskname-task). Make sure you define it in the global scope.\n\nThe `taskName` argument is the string you passed to `TaskManager.defineTask` as the \"taskName\". The callback function you define with `TaskManager.defineTask` will receive the following arguments:\n\n- **data**: The remote payload delivered by either FCM (Android) or APNs (iOS). [See here for details](#pushnotificationtrigger).\n- **error**: The error (if any) that occurred during execution of the task.\n- **executionInfo**: JSON object of additional info related to the task, including the `taskName`.\n\n#### Examples\n\n```ts\nimport * as TaskManager from 'expo-task-manager';\nimport * as Notifications from 'expo-notifications';\n\nconst BACKGROUND_NOTIFICATION_TASK = 'BACKGROUND-NOTIFICATION-TASK';\n\nTaskManager.defineTask(BACKGROUND_NOTIFICATION_TASK, ({ data, error, executionInfo }) => {\n  console.log('Received a notification in the background!');\n  // Do something with the notification data\n});\n\nNotifications.registerTaskAsync(BACKGROUND_NOTIFICATION_TASK);\n```\n\n### `unregisterTaskAsync(taskName: string): void`\n\nUsed to unregister tasks registered with `registerTaskAsync`.\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n> On Android, setting `shouldPlaySound: false` will result in the drop-down notification alert **not** showing, no matter what the priority is. This setting will also override any channel-specific sounds you may have configured.\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.15.1","_nodeVersion":"16.3.0","_npmVersion":"6.14.16","dist":{"integrity":"sha512-gvfnB4GeWcxeYM2/tQadsM1yeL5VkWQhzGJOdyD9GUoZkLc2Pp33Ay2W0cuPn9OfjL0/Hx+MOEwOObjjEc8gQg==","shasum":"96b8962a7e7fe5a7843d82428d5f3ed0dbca9def","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.15.1.tgz","fileCount":581,"unpackedSize":3161184,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEQCIGkI77g01WxGpBptbUfk2SP/4Jbdd6PyY/rIxSzovSUvAiBuFn7QXXBUOwnXQglibMD9QXfTaDpkfdLPmx1DuchN1g=="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiaVCxACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmq8JBAAlyUxkYO6+xAOvMO3qnmW56NFRXJMtfrsgzM0fncPrhQ96JM5\r\njPDFGd0qso14RBNXzfXpBN2vuSi9eE7CdiJzDlpZcMBwv8DLATV8BHxPQo70\r\nKmnVtSB8uXk/y945THexiScyWiyQ46y8vIwbfHlXd8MFbWLVrSPQ/KPg1y6q\r\ngZPmxuFTCI8+P89QT352srGOu/ELhaJtKKH1+w8WsyuIPBsSGkE0qbW7hc4B\r\n/EY6khzC4XiZPuCQywSMZMyHA+TBu7bhOvwGdyGt34rQENei2IJ/vBRBhGTz\r\nEElxE3ZivrkgljgIBRLySapZadpsTtr0ZnqkQCDJ/9EBir8xCwL+b5zJe9xB\r\nyBw+9JCNXR5h1F4m8M3pmP4bg49VYUK/iK7hTt0NDmIZJdd1VbMb6gh5ju61\r\nIEGJBAoKqj7jud5sxlUejYIx8J225p4IclT2fN6OFLqzsGivgAtxcE+exJPG\r\njbrUgsK4A8uycUf5DbPrNg6+zTqZm0GLjbwlo00TG0S19MXpPV8DsOkx+SvO\r\nLEOyOsnf7JKg5llPkcs93duPLH4j+5+yX3fydGIxK2Q7U+136wfvGe6QHDih\r\nTeGa7mx1XemM0WICcW6bX8G1GoxZoC87M2tuyYF7CejQNCqjXcic8f3S7L5t\r\nK37TM79F+0r7xyshxiH7vTnj+EjaWJFyAfk=\r\n=fzD3\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"tsapeta","email":"npm@tsapeta.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"kbrandwijk","email":"kim.brandwijk@gmail.com"},{"name":"kgc00","email":"kirbygc00@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.15.1_1651069104965_0.37661450502103166"},"_hasShrinkwrap":false},"0.15.2":{"name":"expo-notifications","version":"0.15.2","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"^4.0.14","@expo/image-utils":"^0.3.18","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.1.0","expo-constants":"~13.1.0","fs-extra":"^9.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^3.2.0","node-fetch":"^2.6.7"},"peerDependencies":{"expo":"*"},"gitHead":"b9d655c1bed682ad8919e071dd923968773f05b5","_id":"expo-notifications@0.15.2","_nodeVersion":"16.13.0","_npmVersion":"8.1.0","dist":{"integrity":"sha512-ZlOzQ8Lp1MgkwmiBsgg95nQHHbTOg8LHwmB816qxNKWeFvlyr/wQSgTZJNklL1uuv/+jC/YyKWoANfodahcAbQ==","shasum":"8c9d3b43624e7a08bfc12ccec714717bfeb30c10","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.15.2.tgz","fileCount":581,"unpackedSize":3162531,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDbqyOanoCUcJSBkJN3BBuUc+1bFyWa+ucplVMxgrW+5QIgVMlQhxfZCbyoUUtpXD7zvtnAy7iHjZQFtPXK4+QFyPw="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJidCFSACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrThg/9GJbCsF9dPB9kLH5NLW4oJ8ThLRQRThNxD+sZhMPx4vIeagPI\r\nElKSbH40Bb2AvdJABJdTUVzOnd+XGMmGbev+88csxOqOdyYWz+AJ/KLCQfjA\r\nKstRUkDuYk4cW7+zlqt/Jlpu5YPPfRECQJgZwkWttG+tsIQ03JcJaorULrbl\r\nvMH+dtJwA52LyJBXR7oSRXdFnamW7tjVDTtKIo9doaevQK9K2YLZqjlOf/Id\r\ntGbuGDJDCibOZxwn7upLsoBslhhtDm+07GzyKkP6Tw5Z5qm3Nm3kaWHvqFRH\r\ngPSyfEI7dn9KhJTcYOxZONAx1xzz0wmREx2abP210zDL/HjkGooFtOtD4cc1\r\nP3YMN6UadVzwxUkYMzuYCF2ZaP1dYaai69vDeM2rLEZmzCZC8SiNqJ96fN3j\r\njA0fE7Xex6mUJ81Ex9BctkVltXQ99LkSxf6rjwhx8PgTUglZ3/rPwPZNDJOz\r\n6d7bDmDOyzFGYzQmRSg6jK83fi1E2FKtuOFOY4pBzGBpNp5c/px8Wvq9f0j4\r\nowhYG39yFEUgS8Ty28z+0tlHsg+7bFM/HOszT2D2GUrMaXWdPohDEYyDhKRc\r\n0eKjv1TTJJUlwyMJ+cKhLsRDdcy/kZY3IwbORmbXqbeI6PCJK0HMzmwA6bQd\r\ngPFGDKmY0LnR2J9JqCrVys2gw4YIig1VGlk=\r\n=dCqL\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"kbrandwijk","email":"kim.brandwijk@gmail.com"},{"name":"kgc00","email":"kirbygc00@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.15.2_1651777874234_0.604339318623234"},"_hasShrinkwrap":false},"0.15.3":{"name":"expo-notifications","version":"0.15.3","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"^4.0.14","@expo/image-utils":"^0.3.18","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.1.0","expo-constants":"~13.1.0","fs-extra":"^9.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^3.2.0","node-fetch":"^2.6.7"},"peerDependencies":{"expo":"*"},"gitHead":"aa4163b5cb533fd4b3fc583e3958b36eaa97617c","_id":"expo-notifications@0.15.3","_nodeVersion":"16.13.0","_npmVersion":"8.1.0","dist":{"integrity":"sha512-ln2aFWxKj3jEr5fRTgudxq5v0my+GyYUcfKiKJ7Z/7flRczjZ2Kp8WChZllRYAvncybpghMzpksKg8f5YtAZ2g==","shasum":"d87dfc2601620ea89ed1a154a3e71ff7e99256d2","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.15.3.tgz","fileCount":587,"unpackedSize":3177865,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQDFyOgtFG5Rf7Ncpmqa9sQT8LIDZ9otnJaYVia8X/IkYwIgMC2S6B1kyWJs8EYKhks++T3n0ZPTRH2PTjYZmU0dttU="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJirMvEACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrcOxAAiCw0k3dCbzLL9dzDivqbXtDny2glUiMBux6nRs7M7dluLQub\r\naHwzD12ADZvAqszm5z5DmYQDHpdfZhazsXNpGNKdK0foQ663tXNKHFNRMrLU\r\n+ywCxXOVyGcL98L78brGK0UMAqEZ9Vjr+K6SoiwhxAA7KWEQWBOfIxDrGew/\r\ngXn8057c4DGMpFsiPWNz/ORAVffw5cRewaOqiDxgonQbWTvhxHb+2RD2RsOl\r\nA2F7MiR2ZFbu366Jec4EFNPES8DeZiMD81O5pId1zdpuTD3X/3ob29BK2s3/\r\nbi0K+4ghZgvPkNEYhCJAh8uyRua2iwPvTiDSBPqGX5YF5Va/BcReRMhWKQZJ\r\ng87GL5GQGrr4KsOa5wqpSrfkojMrRJHszv6mNKbd4QwNJrWkiaaiutNoPNiv\r\naCUrNAwYgQovpqh2oMKeLII4G7IY2WlW7bERMyccFDMLaRk6UL3AO/iWVA0A\r\nV7Ww2x3SVJ6jn28TqvrKFWfR0qe421LgDb7kKbn9Z5G6F12wS6EqQzBEgQNL\r\n1lAwKchXOdcoeLyHu14z7xZ9u++zKJ0oWYmpSVbVdo4MISAeFcH+uf8qgoHk\r\nKlRRxS2ZyAxvwpW2HY98w4i5kKbeUqS7N8FvLeRYzgVDjboyYqKVm6v27lbp\r\ngi7t3zEOWn+iBsEr+1DOeYI6fqM6hfSaEhg=\r\n=9bb3\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"kudochien","email":"ckchien@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"kbrandwijk","email":"kim.brandwijk@gmail.com"},{"name":"kgc00","email":"kirbygc00@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.15.3_1655491524471_0.08520183045175633"},"_hasShrinkwrap":false},"0.15.4":{"name":"expo-notifications","version":"0.15.4","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"^4.0.14","@expo/image-utils":"^0.3.18","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.1.0","expo-constants":"~13.1.0","fs-extra":"^9.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^3.2.0","node-fetch":"^2.6.7"},"peerDependencies":{"expo":"*"},"gitHead":"702fddee92d0d96c29fc8144fa08d07ba0995492","_id":"expo-notifications@0.15.4","_nodeVersion":"16.13.0","_npmVersion":"8.1.0","dist":{"integrity":"sha512-CHjzA0d4NQU9Es//tTSEKQl3Hfj9hdrV6k79G+2/dnAXIa+KjvDGUTjPlhVqvt9ApT4Ly6UbwoY5Cb5qgKMEWA==","shasum":"e255927a239a1b49bf6dfe3d2d6d3fee308165e2","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.15.4.tgz","fileCount":587,"unpackedSize":3178138,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIGgF6ClSf78VGbZ9Icb/PONgYoTkGrSZH1xYJapphAvrAiEAvly0pz6jQsMy3qgWhjvcY11U133Jucaz+xCSRJWgzzk="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiuekoACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpXJA/9G27hMzlAPv8KVEybnwsVVKPXxHtoRbw5YpOZ0paJ9lJX664f\r\ni78CD32gB6wiHSX40GSm6rnQbWDHORcCx2lciQ+/gaVSPIGifMzYOf/T90JD\r\nWWNEmVhQKMO7UTzygwwRKM8/1PwFBxhu/mvkdIXZKtARTYQEWv4i80uOS6dn\r\nWHIhBN6sj84iiuVa3rcElVSmaXZx5SKXnJj8/zdcs5I61sD2T3+TvBNGXIKy\r\njUe52jxUoBOVt5gUOnsEP9vA3cuXf3E2aNFlGz3d3Uz0zh9qL4m7ch+VAp98\r\nOqXKtsHb/Ir+Yyf/n5B5qilVO78FXGF4hgwm7gT+KJ148+bpOy4X2gsndu/S\r\ngQ06j8bnUlNLg7conNEIZ/DOWmtL3goOo7uDdy3CIvG50Z8J00HhOFtbm+JQ\r\nhF01n4OQbdVkdaQ4YzZhaVTpa0d0xgC0U98wlbp7NMpx2n3DivvRWbjQsEGS\r\nCv8Qh4DyOwhMAhIHD0RDkQQocvq56SYjGzNumSQZ28vCBu6vn44Hy2NqzGu+\r\nM2lTzlMw5SHuC9jAfnTzeztPylioPhr0NpxX1FulCr6lWbzJhxZQYvLz+Pqh\r\nHW90XWN7ZSTs5JD7KZkXYhmZZRLjFLCx0vWY/u7b5dFAdAzPQzZbZFN2S2Z2\r\nTkN4JyELoU782dbo9JCV8cR5pnJrnA+K67U=\r\n=kMB1\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"kudochien","email":"ckchien@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"kbrandwijk","email":"kim.brandwijk@gmail.com"},{"name":"kgc00","email":"kirbygc00@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.15.4_1656351016539_0.9239961108312629"},"_hasShrinkwrap":false},"0.16.0":{"name":"expo-notifications","version":"0.16.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"~5.0.0","@expo/image-utils":"^0.3.18","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.2.0","expo-constants":"~13.2.0","fs-extra":"^9.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^3.2.0","node-fetch":"^2.6.7"},"peerDependencies":{"expo":"*"},"gitHead":"6e131f2da851a47c3a24eb3d6fc971a1a7822086","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications in the foreground and background,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.dev/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `expo` package](https://docs.expo.dev/bare/installing-expo-modules/) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.dev/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\n**Note:** Starting from Android 12 (API level 31), to schedule the notification that triggers at the exact time, you need to add `<uses-permission android:name=\"android.permission.SCHEDULE_EXACT_ALARM\"/>` to **AndroidManifest.xml**. You can read more about the exact alarm permission [here](https://developer.android.com/about/versions/12/behavior-changes-12#exact-alarm-permission).\n\n<details><summary><strong>Expand to view how the notification icon and the default color can be customized in a plain React Native app</strong></summary> <p>\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n</p>\n</details>\n\n### Config plugin setup (optional)\n\nIf you're using EAS Build, you can set your Android notification icon and color tint, add custom push notification sounds, and set your iOS notification environment using the expo-notifications config plugin ([what's a config plugin?](http://docs.expo.dev/guides/config-plugins/)). To setup, just add the config plugin to the plugins array of your `app.json` or `app.config.js` as shown below, then rebuild the app.\n\n```json\n{\n  \"expo\": {\n    ...\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"icon\": \"./local/path/to/myNotificationIcon.png\",\n          \"color\": \"#ffffff\",\n          \"sounds\": [\"./local/path/to/mySound.wav\", \"./local/path/to/myOtherSound.wav\"],\n          \"mode\": \"production\"\n        }\n      ]\n    ],\n  }\n}\n```\n\n<details><summary><strong>Expand to view property descriptions and default values</strong></summary> <p>\n\n- **icon**: Android only. Local path to an image to use as the icon for push notifications. 96x96 all-white png with transparency.\n- **color**: Android only. Tint color for the push notification image when it appears in the notification tray. Default: \"#ffffff\".\n- **sounds**: Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.\n- **mode**: iOS only. Environment of the app: either 'development' or 'production'. Default: 'development'.\n\n</p>\n</details>\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.dev/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds\n\nCustom notification sounds are only supported when using [EAS Build](https://docs.expo.dev/build/introduction/), or in the bare workflow.\n\nTo add custom push notification sounds to your app, add the `expo-notifications` plugin to your `app.json` file:\n\n```json\n{\n  \"expo\": {\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"sounds\": [\"local/path/to/mySoundFile.wav\"]\n        }\n      ]\n    ]\n  }\n}\n```\n\nAfter building your app, the array of files will be available for use in both [`NotificationContentInput`](#notificationcontentinput) and [`NotificationChannelInput`](#notificationchannelinput). You _only_ need to provide the base filename- here's an example using the config above:\n\n```ts\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  sound: 'mySoundFile.wav', // Provide ONLY the base filename\n});\n\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    sound: 'mySoundFile.wav', // Provide ONLY the base filename\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails',\n  },\n});\n```\n\nYou can also manually add notification files to your Android and iOS projects if you prefer:\n\n<details><summary><strong>Manually adding notification sounds on Android</strong></summary> <p>\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\nFor the example below to work, you would place your `email-sound.wav` file in `android/app/src/main/res/raw/`.\n\n```ts\n// Prepare the notification channel\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n</p>\n</details>\n\n<details><summary><strong>Manually adding notification sounds on iOS</strong></summary> <p>\n\nOn iOS, all that's needed is to place your sound file in your Xcode project, and then specify the sound file in your `NotificationContentInput`, like this:\n\n```ts\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'notification.wav',\n  },\n  trigger: {\n    // ...\n  },\n});\n```\n\n</p>\n</details>\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.dev/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.dev/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/main/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.dev/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.dev/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.dev/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.dev/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.dev/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.dev/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\nNotification events include incoming notifications, interactions your users perform with notifications (this can be tapping on a notification, or interacting with it via [notification categories](#managing-notification-categories-interactive-notifications)), and rare occasions when your notifications may be dropped.\n\nA few different listeners are exposed, so we've provided a chart below which will hopefully help you understand when you can expect each one to be triggered:\n\n| User interacted with notification? | App state  | Listener(s) triggered                                                   |\n| :--------------------------------- | :--------: | ----------------------------------------------------------------------- |\n| false                              | Foreground | `NotificationReceivedListener`                                          |\n| false                              | Background | `BackgroundNotificationTask`                                            |\n| false                              |   Killed   | none                                                                    |\n| true                               | Foreground | `NotificationReceivedListener` & `NotificationResponseReceivedListener` |\n| true                               | Background | `NotificationResponseReceivedListener`                                  |\n| true                               |   Killed   | `NotificationResponseReceivedListener`                                  |\n\n> In the chart above, whenever `NotificationResponseReceivedListener` is triggered, the same would apply to the `useLastNotificationResponse` hook.\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Handling incoming notifications when the app is not in the foreground (not supported in Expo Go)\n\n> **Please note:** In order to handle notifications while the app is backgrounded on iOS, you _must_ add `remote-notification` to the `ios.infoPlist.UIBackgroundModes` key in your app.json, **and** add `\"content-available\": 1` to your push notification payload. Under normal circumstances, the ‚Äúcontent-available‚Äù flag should launch your app if it isn‚Äôt running and wasn‚Äôt killed by the user, _however_, this is ultimately decided by the OS so it might not always happen.\n\n### `registerTaskAsync(taskName: string): void`\n\nWhen a notification is received while the app is backgrounded, using this function you can set a callback that will be run in response to that notification. Under the hood, this function is run using `expo-task-manager`. You **must** define the task _first_, with [`TaskManager.defineTask`](https://docs.expo.dev/versions/latest/sdk/task-manager/#taskmanagerdefinetasktaskname-task). Make sure you define it in the global scope.\n\nThe `taskName` argument is the string you passed to `TaskManager.defineTask` as the \"taskName\". The callback function you define with `TaskManager.defineTask` will receive the following arguments:\n\n- **data**: The remote payload delivered by either FCM (Android) or APNs (iOS). [See here for details](#pushnotificationtrigger).\n- **error**: The error (if any) that occurred during execution of the task.\n- **executionInfo**: JSON object of additional info related to the task, including the `taskName`.\n\n#### Examples\n\n```ts\nimport * as TaskManager from 'expo-task-manager';\nimport * as Notifications from 'expo-notifications';\n\nconst BACKGROUND_NOTIFICATION_TASK = 'BACKGROUND-NOTIFICATION-TASK';\n\nTaskManager.defineTask(BACKGROUND_NOTIFICATION_TASK, ({ data, error, executionInfo }) => {\n  console.log('Received a notification in the background!');\n  // Do something with the notification data\n});\n\nNotifications.registerTaskAsync(BACKGROUND_NOTIFICATION_TASK);\n```\n\n### `unregisterTaskAsync(taskName: string): void`\n\nUsed to unregister tasks registered with `registerTaskAsync`.\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n> On Android, setting `shouldPlaySound: false` will result in the drop-down notification alert **not** showing, no matter what the priority is. This setting will also override any channel-specific sounds you may have configured.\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.16.0","_nodeVersion":"16.13.0","_npmVersion":"8.1.0","dist":{"integrity":"sha512-Q0pbjh5mWR8BxS1UvcKZskEyYd5p72IfU1/VHemm1q44kKBbH+0oFMaPzkNpQcy73L6p4rl/jiQ+4xUpjYm68g==","shasum":"0de62ffeef55b841f86bb678e17880788acd4a43","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.16.0.tgz","fileCount":587,"unpackedSize":3178058,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIF6x5XSW8DpJmTBdhxQgP0WRrdFeot14zYRp4H2xFv8HAiEAj2iP3TyWneA5adNsECIwPk82jVxOmUJ4TAqmItjTQ90="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJix2opACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqmFw/8De28kpBV5OGimrVy19y7y2vDrQB3PDQl064laD2LfLqKljA/\r\naUrnB6ti6TATdRZTt2d2jia8jKL2uezOO+ClqtfY9xc66K66QIhsdvCmf8wZ\r\nEI3XKgBu/zTZxsw92aZkkQ5mRy37Scl6ULBWR2wvSnB5Cco3Q4J/Pa4MXJD4\r\nHNpXO4MZ1iOiNCfL3FSMvC+b85wS1QFitu0Sj8bpkmJU77RofatTkXfo/m5Z\r\nEjD0h3sBL7vaK/d3u8KOa8mnZP24m/X6sdjMmWiHX33py/gEFbvH/fbkWKxl\r\n5S/2NPkQXpDXbp7yg10OM/5quE0uOQRNGA8qxp9iaqogR19BF0C3L/Z7otns\r\nM0rrkbFmeBzogUY0noYQxtqvQGN7IfUrebfySsi0zE9UzZ3un7QlL+Ng9NqW\r\nrf7w5Oknea/oKkL9jFvq4zP1tPyCYm8lziX2IkuoG1w9y/9Q/oQPqSbG3nWS\r\nLU+CDnyJ3F2vKtN/LPaSZfwXFJrEituZ1nDZw3fBb05de3wN3Lr7/isG2+d5\r\njlsa9SKkEYjjiXpSZnY0u4TRVZcQY0SuOk5rhm17ALscx7fPr6U018kDNDtF\r\nbMh2K0Zb/4LglQShW+pNYzFDYIW6W7eS9TrmjOMi8baNb6eUKkiutYKvE7Ll\r\nSftIw29Mpx9y3FdvOkF1SsYXjAEr9TZU6eE=\r\n=OJn3\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"brentvatne","email":"brentvatne@gmail.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"kbrandwijk","email":"kim.brandwijk@gmail.com"},{"name":"kgc00","email":"kirbygc00@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.16.0_1657236009309_0.9832088607226994"},"_hasShrinkwrap":false},"0.16.1":{"name":"expo-notifications","version":"0.16.1","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/config-plugins":"~5.0.0","@expo/image-utils":"^0.3.18","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~4.2.0","expo-constants":"~13.2.0","fs-extra":"^9.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^2.0.0","memfs":"^3.2.0","node-fetch":"^2.6.7"},"peerDependencies":{"expo":"*"},"gitHead":"c6678c65b68e45062d49a2deea8e822f69388278","_id":"expo-notifications@0.16.1","_nodeVersion":"16.15.1","_npmVersion":"8.11.0","dist":{"integrity":"sha512-GYXZnR5VCU79tM/2senPJ0jWq04PFAvh3chFYaz9qvUjJwl/AV/BQz0xOUNXGXmm8nBf6FA8B4exDV8h4KhV6g==","shasum":"4e6c74fb6b3aa615a36f587e0fd4876ca48ecf91","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.16.1.tgz","fileCount":587,"unpackedSize":3176505,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCzLjRBguLnBVZa+xVwzipuEzv2deKJg3LdYFTx/srlSQIgPndtKCb1DgTsgTl5agfgpVlbp8KxS5I/H8jKwQXjm0s="}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi0vu8ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr5mg//VWe84bNkMJksR7DXtwx7UwhqmxOcucTkXo0zvWtiG3Y4OGx7\r\n1TJWr5b3Y8K/EsU9FhmtBTd1DHidwT9i0Kxxh3N403PTM/bNzzMYGuEY9pze\r\n/mT1sPtHhtAPYuF4wTNSqCtwIELCnr2nvvWj4n4jx3rTP3MSqDaWmZOzGvQH\r\nP1rbfTgouvRH8B2CXtbgdhHXW4LGFlcJybXBY7Fpp9DVHIUaidjVE86EbUPw\r\nZd5uM5nNM2zmGEulns20yRZ/YxP2xKkBYPNZN5vmAzxN53duaon5ydpGLn7t\r\nDWUEFn2CV0A0/+Zu1vCu4YN+pzvlFSU6FGPlwFuzaulxhLEV8BZkQs1JwE1E\r\njjHrnFy8xG0Btx5um3lr3VycHCTTgSdDwhcvyNdSq69GoA0aT2/y3UJIIxDu\r\nhg5lpX34iji9+VmGhcstmN+D2kB5TRgJFgrN7eQ8bAyMQcc/mLWbSjVC7A3x\r\nndmRERdzipJ9J6lLYCKLZXQ8iXYH7nitSbZ7qhTGS9wgBIgxQkEzTVUGQ6aH\r\nw0fej+VkfOxtZNEOQZSJ0yFKRztpqNnR4tVTeaeGHJRF3MvttmcmFnY+tcyW\r\nYR1Q1lS+iebzXeMgc/M6U7zGfaM5lTGZbgcNllQI+xISBU1oEOjLxtbe0a2o\r\n4TmPDfoYF3OgxVjJt+ARa6FFsqSFwOK/G+0=\r\n=Rd37\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"tsapeta","email":"npm@tsapeta.com"},"directories":{},"maintainers":[{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"bbarthec","email":"bartlomiejbukowski.b@gmail.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"christopherwalter","email":"chris@christopherwalter.com"},{"name":"kbrandwijk","email":"kim.brandwijk@gmail.com"},{"name":"kgc00","email":"kirbygc00@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"ccheever","email":"ccheever@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"esamelson","email":"eric@expo.io"},{"name":"expoadmin","email":"support@expo.io"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.16.1_1657994172176_0.20163924683014955"},"_hasShrinkwrap":false},"0.17.0":{"name":"expo-notifications","version":"0.17.0","description":"Notifications module","main":"build/index.js","types":"build/index.d.ts","sideEffects":["./build/DevicePushTokenAutoRegistration.fx.js"],"scripts":{"build":"expo-module build","clean":"expo-module clean","lint":"expo-module lint","test":"expo-module test","prepare":"expo-module prepare","prepublishOnly":"expo-module prepublishOnly","expo-module":"expo-module"},"keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"bugs":{"url":"https://github.com/expo/expo/issues"},"author":{"name":"650 Industries, Inc."},"license":"MIT","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","jest":{"preset":"expo-module-scripts/ios"},"dependencies":{"@expo/image-utils":"^0.3.18","@ide/backoff":"^1.0.0","abort-controller":"^3.0.0","assert":"^2.0.0","badgin":"^1.1.5","expo-application":"~5.0.0","expo-constants":"~14.0.0","fs-extra":"^9.1.0","uuid":"^3.4.0"},"devDependencies":{"@types/node-fetch":"^2.5.7","@types/uuid":"^3.4.7","expo-module-scripts":"^3.0.0","memfs":"^3.2.0","node-fetch":"^2.6.7"},"peerDependencies":{"expo":"*"},"gitHead":"eab2b09c735fb0fc2bf734a3f29a6593adba3838","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications in the foreground and background,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.dev/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `expo` package](https://docs.expo.dev/bare/installing-expo-modules/) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.dev/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\n**Note:** Starting from Android 12 (API level 31), to schedule the notification that triggers at the exact time, you need to add `<uses-permission android:name=\"android.permission.SCHEDULE_EXACT_ALARM\"/>` to **AndroidManifest.xml**. You can read more about the exact alarm permission [here](https://developer.android.com/about/versions/12/behavior-changes-12#exact-alarm-permission).\n\n<details><summary><strong>Expand to view how the notification icon and the default color can be customized in a plain React Native app</strong></summary> <p>\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n</p>\n</details>\n\n### Config plugin setup (optional)\n\nIf you're using EAS Build, you can set your Android notification icon and color tint, add custom push notification sounds, and set your iOS notification environment using the expo-notifications config plugin ([what's a config plugin?](http://docs.expo.dev/guides/config-plugins/)). To setup, just add the config plugin to the plugins array of your `app.json` or `app.config.js` as shown below, then rebuild the app.\n\n```json\n{\n  \"expo\": {\n    ...\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"icon\": \"./local/path/to/myNotificationIcon.png\",\n          \"color\": \"#ffffff\",\n          \"sounds\": [\"./local/path/to/mySound.wav\", \"./local/path/to/myOtherSound.wav\"],\n          \"mode\": \"production\"\n        }\n      ]\n    ],\n  }\n}\n```\n\n<details><summary><strong>Expand to view property descriptions and default values</strong></summary> <p>\n\n- **icon**: Android only. Local path to an image to use as the icon for push notifications. 96x96 all-white png with transparency.\n- **color**: Android only. Tint color for the push notification image when it appears in the notification tray. Default: \"#ffffff\".\n- **sounds**: Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.\n- **mode**: iOS only. Environment of the app: either 'development' or 'production'. Default: 'development'.\n\n</p>\n</details>\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.dev/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds\n\nCustom notification sounds are only supported when using [EAS Build](https://docs.expo.dev/build/introduction/), or in the bare workflow.\n\nTo add custom push notification sounds to your app, add the `expo-notifications` plugin to your `app.json` file:\n\n```json\n{\n  \"expo\": {\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"sounds\": [\"local/path/to/mySoundFile.wav\"]\n        }\n      ]\n    ]\n  }\n}\n```\n\nAfter building your app, the array of files will be available for use in both [`NotificationContentInput`](#notificationcontentinput) and [`NotificationChannelInput`](#notificationchannelinput). You _only_ need to provide the base filename- here's an example using the config above:\n\n```ts\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  sound: 'mySoundFile.wav', // Provide ONLY the base filename\n});\n\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    sound: 'mySoundFile.wav', // Provide ONLY the base filename\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails',\n  },\n});\n```\n\nYou can also manually add notification files to your Android and iOS projects if you prefer:\n\n<details><summary><strong>Manually adding notification sounds on Android</strong></summary> <p>\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\nFor the example below to work, you would place your `email-sound.wav` file in `android/app/src/main/res/raw/`.\n\n```ts\n// Prepare the notification channel\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n</p>\n</details>\n\n<details><summary><strong>Manually adding notification sounds on iOS</strong></summary> <p>\n\nOn iOS, all that's needed is to place your sound file in your Xcode project, and then specify the sound file in your `NotificationContentInput`, like this:\n\n```ts\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'notification.wav',\n  },\n  trigger: {\n    // ...\n  },\n});\n```\n\n</p>\n</details>\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.dev/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.dev/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/main/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.dev/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.dev/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.dev/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.dev/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.dev/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.dev/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\nNotification events include incoming notifications, interactions your users perform with notifications (this can be tapping on a notification, or interacting with it via [notification categories](#managing-notification-categories-interactive-notifications)), and rare occasions when your notifications may be dropped.\n\nA few different listeners are exposed, so we've provided a chart below which will hopefully help you understand when you can expect each one to be triggered:\n\n| User interacted with notification? | App state  | Listener(s) triggered                                                   |\n| :--------------------------------- | :--------: | ----------------------------------------------------------------------- |\n| false                              | Foreground | `NotificationReceivedListener`                                          |\n| false                              | Background | `BackgroundNotificationTask`                                            |\n| false                              |   Killed   | none                                                                    |\n| true                               | Foreground | `NotificationReceivedListener` & `NotificationResponseReceivedListener` |\n| true                               | Background | `NotificationResponseReceivedListener`                                  |\n| true                               |   Killed   | `NotificationResponseReceivedListener`                                  |\n\n> In the chart above, whenever `NotificationResponseReceivedListener` is triggered, the same would apply to the `useLastNotificationResponse` hook.\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Handling incoming notifications when the app is not in the foreground (not supported in Expo Go)\n\n> **Please note:** In order to handle notifications while the app is backgrounded on iOS, you _must_ add `remote-notification` to the `ios.infoPlist.UIBackgroundModes` key in your app.json, **and** add `\"content-available\": 1` to your push notification payload. Under normal circumstances, the ‚Äúcontent-available‚Äù flag should launch your app if it isn‚Äôt running and wasn‚Äôt killed by the user, _however_, this is ultimately decided by the OS so it might not always happen.\n\n### `registerTaskAsync(taskName: string): void`\n\nWhen a notification is received while the app is backgrounded, using this function you can set a callback that will be run in response to that notification. Under the hood, this function is run using `expo-task-manager`. You **must** define the task _first_, with [`TaskManager.defineTask`](https://docs.expo.dev/versions/latest/sdk/task-manager/#taskmanagerdefinetasktaskname-task). Make sure you define it in the global scope.\n\nThe `taskName` argument is the string you passed to `TaskManager.defineTask` as the \"taskName\". The callback function you define with `TaskManager.defineTask` will receive the following arguments:\n\n- **data**: The remote payload delivered by either FCM (Android) or APNs (iOS). [See here for details](#pushnotificationtrigger).\n- **error**: The error (if any) that occurred during execution of the task.\n- **executionInfo**: JSON object of additional info related to the task, including the `taskName`.\n\n#### Examples\n\n```ts\nimport * as TaskManager from 'expo-task-manager';\nimport * as Notifications from 'expo-notifications';\n\nconst BACKGROUND_NOTIFICATION_TASK = 'BACKGROUND-NOTIFICATION-TASK';\n\nTaskManager.defineTask(BACKGROUND_NOTIFICATION_TASK, ({ data, error, executionInfo }) => {\n  console.log('Received a notification in the background!');\n  // Do something with the notification data\n});\n\nNotifications.registerTaskAsync(BACKGROUND_NOTIFICATION_TASK);\n```\n\n### `unregisterTaskAsync(taskName: string): void`\n\nUsed to unregister tasks registered with `registerTaskAsync`.\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription. Call `.remove()` to remove the subscription. You can then discard the object.\n\n```ts\nexport type Subscription = {\n  remove: () => void;\n};\n```\n\n### `Notification`\n\nAn object representing a single notification that has been triggered by some request ([`NotificationRequest`](#notificationrequest)) at some point in time.\n\n```ts\nexport interface Notification {\n  date: number;\n  request: NotificationRequest;\n}\n```\n\n### `NotificationRequest`\n\nAn object representing a request to present a notification. It has content ‚Äî how it's being represented ‚Äî and a trigger ‚Äî what triggers the notification. Many notifications ([`Notification`](#notification)) may be triggered with the same request (eg. a repeating notification).\n\n```ts\nexport interface NotificationRequest {\n  identifier: string;\n  content: NotificationContent;\n  trigger: NotificationTrigger;\n}\n```\n\n### `NotificationContent`\n\nAn object representing notification's content.\n\n```ts\nexport type NotificationContent = {\n  // Notification title - the bold text displayed above the rest of the content\n  title: string | null;\n  // On iOS - subtitle - the bold text displayed between title and the rest of the content\n  // On Android - subText - the display depends on the platform\n  subtitle: string | null;\n  // Notification body - the main content of the notification\n  body: string | null;\n  // Data associated with the notification, not displayed\n  data: { [key: string]: unknown };\n  // Application badge number associated with the notification\n  badge: number | null;\n  sound: 'default' | 'defaultCritical' | 'custom' | null;\n} & (\n  | {\n      // iOS-specific additions\n      // See https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc\n      // for more information on specific fields.\n      launchImageName: string | null;\n      attachments: {\n        identifier: string | null;\n        url: string | null;\n        type: string | null;\n      }[];\n      summaryArgument?: string | null;\n      summaryArgumentCount?: number;\n      categoryIdentifier: string | null;\n      threadIdentifier: string | null;\n      targetContentIdentifier?: string;\n    }\n  | {\n      // Android-specific additions\n      // See https://developer.android.com/reference/android/app/Notification.html#fields\n      // for more information on specific fields.\n      priority?: AndroidNotificationPriority;\n      vibrationPattern?: number[];\n      // Format: '#AARRGGBB'\n      color?: string;\n    }\n);\n```\n\n### `NotificationContentInput`\n\nAn object representing notification content that you pass in to `presentNotificationAsync` or as a part of `NotificationRequestInput`.\n\n```ts\nexport interface NotificationContentInput {\n  // Fields corresponding to NotificationContent\n  title?: string;\n  subtitle?: string;\n  body?: string;\n  data?: { [key: string]: unknown };\n  badge?: number;\n  sound?: boolean | string;\n  // Android-specific fields\n  // See https://developer.android.com/reference/android/app/Notification.html#fields\n  // for more information on specific fields.\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  // Format: '#AARRGGBB', '#RRGGBB' or one of the named colors,\n  // see https://developer.android.com/reference/kotlin/android/graphics/Color?hl=en\n  color?: string;\n  // If set to false, the notification will not be automatically dismissed when clicked.\n  // The setting used when the value is not provided or is invalid is true (the notification\n  // will be dismissed automatically). Corresponds directly to Android's `setAutoCancel`\n  // behavior. In Firebase terms this property of a notification is called `sticky`.\n  // See:\n  // - https://developer.android.com/reference/android/app/Notification.Builder#setAutoCancel(boolean),\n  // - https://firebase.google.com/docs/reference/fcm/rest/v1/projects.messages#AndroidNotification.FIELDS.sticky\n  autoDismiss?: boolean;\n  // iOS-specific fields\n  // See https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent?language=objc\n  // for more information on specific fields.\n  launchImageName?: string;\n  attachments?: {\n    url: string;\n    identifier?: string;\n\n    typeHint?: string;\n    hideThumbnail?: boolean;\n    thumbnailClipArea?: { x: number; y: number; width: number; height: number };\n    thumbnailTime?: number;\n  }[];\n}\n```\n\n### `NotificationRequestInput`\n\nAn object representing a notification request you can pass into `scheduleNotificationAsync`.\n\n```ts\nexport interface NotificationRequestInput {\n  identifier?: string;\n  content: NotificationContentInput;\n  trigger: NotificationTriggerInput;\n}\n```\n\n### `AndroidNotificationPriority`\n\nAn enum corresponding to values appropriate for Android's [`Notification#priority`](https://developer.android.com/reference/android/app/Notification#priority) field.\n\n```ts\nexport enum AndroidNotificationPriority {\n  MIN = 'min',\n  LOW = 'low',\n  DEFAULT = 'default',\n  HIGH = 'high',\n  MAX = 'max',\n}\n```\n\n### `NotificationTrigger`\n\nA union type containing different triggers which may cause the notification to be delivered to the application.\n\n```ts\nexport type NotificationTrigger =\n  | PushNotificationTrigger\n  | CalendarNotificationTrigger\n  | LocationNotificationTrigger\n  | TimeIntervalNotificationTrigger\n  | DailyNotificationTrigger\n  | WeeklyNotificationTrigger\n  | YearlyNotificationTrigger\n  | UnknownNotificationTrigger;\n```\n\n### `PushNotificationTrigger`\n\nAn object representing a notification delivered by a push notification system.\n\nOn Android under `remoteMessage` field a JS version of the Firebase `RemoteMessage` may be accessed. On iOS under `payload` you may find full contents of [`UNNotificationContent`'s](https://developer.apple.com/documentation/usernotifications/unnotificationcontent?language=objc) [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649869-userinfo?language=objc), i.e. [remote notification payload](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/CreatingtheNotificationPayload.html)\n\n```ts\nexport type PushNotificationTrigger = { type: 'push' } & (\n  | { payload: Record<string, unknown> } // iOS\n  | { remoteMessage: FirebaseRemoteMessage } // Android\n  | {}\n);\n```\n\n### `FirebaseRemoteMessage`\n\nA Firebase `RemoteMessage` that caused the notification to be delivered to the app.\n\n```ts\nexport interface FirebaseRemoteMessage {\n  collapseKey: string | null;\n  data: { [key: string]: string };\n  from: string | null;\n  messageId: string | null;\n  messageType: string | null;\n  originalPriority: number;\n  priority: number;\n  sentTime: number;\n  to: string | null;\n  ttl: number;\n  notification: null | {\n    body: string | null;\n    bodyLocalizationArgs: string[] | null;\n    bodyLocalizationKey: string | null;\n    channelId: string | null;\n    clickAction: string | null;\n    color: string | null;\n    usesDefaultLightSettings: boolean;\n    usesDefaultSound: boolean;\n    usesDefaultVibrateSettings: boolean;\n    eventTime: number | null;\n    icon: string | null;\n    imageUrl: string | null;\n    lightSettings: number[] | null;\n    link: string | null;\n    localOnly: boolean;\n    notificationCount: number | null;\n    notificationPriority: number | null;\n    sound: string | null;\n    sticky: boolean;\n    tag: string | null;\n    ticker: string | null;\n    title: string | null;\n    titleLocalizationArgs: string[] | null;\n    titleLocalizationKey: string | null;\n    vibrateTimings: number[] | null;\n    visibility: number | null;\n  };\n}\n```\n\n### `TimeIntervalNotificationTrigger`\n\nA trigger related to an elapsed time interval. May be repeating (see `repeats` field).\n\n```ts\nexport interface TimeIntervalNotificationTrigger {\n  type: 'timeInterval';\n  repeats: boolean;\n  seconds: number;\n}\n```\n\n### `DailyNotificationTrigger`\n\nA trigger related to a daily notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface DailyNotificationTrigger {\n  type: 'daily';\n  hour: number;\n  minute: number;\n}\n```\n\n### `WeeklyNotificationTrigger`\n\nA trigger related to a weekly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface WeeklyNotificationTrigger {\n  type: 'weekly';\n  weekday: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `YearlyNotificationTrigger`\n\nA trigger related to a yearly notification. This is an Android-only type, the same functionality will be achieved on iOS with a `CalendarNotificationTrigger`.\n\n```ts\nexport interface YearlyNotificationTrigger {\n  type: 'yearly';\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n}\n```\n\n### `CalendarNotificationTrigger`\n\nA trigger related to a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface CalendarNotificationTrigger {\n  type: 'calendar';\n  repeats: boolean;\n  dateComponents: {\n    era?: number;\n    year?: number;\n    month?: number;\n    day?: number;\n    hour?: number;\n    minute?: number;\n    second?: number;\n    weekday?: number;\n    weekdayOrdinal?: number;\n    quarter?: number;\n    weekOfMonth?: number;\n    weekOfYear?: number;\n    yearForWeekOfYear?: number;\n    nanosecond?: number;\n    isLeapMonth: boolean;\n    timeZone?: string;\n    calendar?: string;\n  };\n}\n```\n\n### `LocationNotificationTrigger`\n\nA trigger related to a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger?language=objc), available only on iOS.\n\n```ts\nexport interface LocationNotificationTrigger {\n  type: 'location';\n  repeats: boolean;\n  region: CircularRegion | BeaconRegion;\n}\n\ninterface Region {\n  type: string;\n  identifier: string;\n  notifyOnEntry: boolean;\n  notifyOnExit: boolean;\n}\n\nexport interface CircularRegion extends Region {\n  type: 'circular';\n  radius: number;\n  center: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\nexport interface BeaconRegion extends Region {\n  type: 'beacon';\n  notifyEntryStateOnDisplay: boolean;\n  major: number | null;\n  minor: number | null;\n  uuid?: string;\n  beaconIdentityConstraint?: {\n    uuid: string;\n    major: number | null;\n    minor: number | null;\n  };\n}\n```\n\n### `UnknownNotificationTrigger`\n\nRepresents a notification trigger that is unknown to `expo-notifications` and that it didn't know how to serialize for JS.\n\n```ts\nexport interface UnknownNotificationTrigger {\n  type: 'unknown';\n}\n```\n\n### `NotificationTriggerInput`\n\nA type representing possible triggers with which you can schedule notifications. A `null` trigger means that the notification should be scheduled for delivery immediately.\n\n```ts\nexport type NotificationTriggerInput =\n  | null\n  | ChannelAwareTriggerInput\n  | SchedulableNotificationTriggerInput;\n```\n\n### `SchedulableNotificationTriggerInput`\n\nA type representing time-based, schedulable triggers. For these triggers you can check the next trigger date with [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null).\n\n```ts\nexport type SchedulableNotificationTriggerInput =\n  | DateTriggerInput\n  | TimeIntervalTriggerInput\n  | DailyTriggerInput\n  | WeeklyTriggerInput\n  | YearlyTriggerInput\n  | CalendarTriggerInput;\n```\n\n### `ChannelAwareTriggerInput`\n\nA trigger that will cause the notification to be delivered immediately.\n\n```ts\nexport type ChannelAwareTriggerInput = {\n  channelId: string;\n};\n```\n\n### `DateTriggerInput`\n\nA trigger that will cause the notification to be delivered once at the specified `Date`. If you pass in a `number` it will be interpreted as a UNIX timestamp.\n\n```ts\nexport type DateTriggerInput = Date | number | { channelId?: string; date: Date | number };\n```\n\n### `TimeIntervalTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times (depends on the `repeats` field) after `seconds` time elapse.\n\n```ts\nexport interface TimeIntervalTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  seconds: number;\n}\n```\n\n### `DailyTriggerInput`\n\nA trigger that will cause the notification to be delivered once per day.\n\n```ts\nexport interface DailyTriggerInput {\n  channelId?: string;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `WeeklyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every week.\n\n> **Note:** Weekdays are specified with a number from 1 through 7, with 1 indicating Sunday.\n\n```ts\nexport interface WeeklyTriggerInput {\n  channelId?: string;\n  weekday: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `YearlyTriggerInput`\n\nA trigger that will cause the notification to be delivered once every year.\n\n> **Note:** all properties are specified in JavaScript Date's ranges.\n\n```ts\nexport interface YearlyTriggerInput {\n  channelId?: string;\n  day: number;\n  month: number;\n  hour: number;\n  minute: number;\n  repeats: true;\n}\n```\n\n### `CalendarTriggerInput`\n\nA trigger that will cause the notification to be delivered once or many times when the date components match the specified values. Corresponds to native [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger?language=objc).\n\n> **Note:** This type of trigger is only available on iOS.\n\n```ts\nexport interface CalendarTriggerInput {\n  channelId?: string;\n  repeats?: boolean;\n  timezone?: string;\n\n  year?: number;\n  month?: number;\n  weekday?: number;\n  weekOfMonth?: number;\n  weekOfYear?: number;\n  weekdayOrdinal?: number;\n  day?: number;\n\n  hour?: number;\n  minute?: number;\n  second?: number;\n}\n```\n\n### `NotificationResponse`\n\nAn object representing user's interaction with the notification.\n\n> **Note:** If the user taps on a notification `actionIdentifier` will be equal to `Notifications.DEFAULT_ACTION_IDENTIFIER`.\n\n```ts\nexport interface NotificationResponse {\n  notification: Notification;\n  actionIdentifier: string;\n  userText?: string;\n}\n```\n\n### `NotificationBehavior`\n\nAn object representing behavior that should be applied to the incoming notification.\n\n```ts\nexport interface NotificationBehavior {\n  shouldShowAlert: boolean;\n  shouldPlaySound: boolean;\n  shouldSetBadge: boolean;\n  priority?: AndroidNotificationPriority;\n}\n```\n\n> On Android, setting `shouldPlaySound: false` will result in the drop-down notification alert **not** showing, no matter what the priority is. This setting will also override any channel-specific sounds you may have configured.\n\n### `NotificationChannel`\n\nAn object representing a notification channel (feature available only on Android).\n\n```ts\nexport enum AndroidNotificationVisibility {\n  UNKNOWN,\n  PUBLIC,\n  PRIVATE,\n  SECRET,\n}\n\nexport enum AndroidAudioContentType {\n  UNKNOWN,\n  SPEECH,\n  MUSIC,\n  MOVIE,\n  SONIFICATION,\n}\n\nexport enum AndroidImportance {\n  UNKNOWN,\n  UNSPECIFIED,\n  NONE,\n  MIN,\n  LOW,\n  DEFAULT,\n  HIGH,\n  MAX,\n}\n\nexport enum AndroidAudioUsage {\n  UNKNOWN,\n  MEDIA,\n  VOICE_COMMUNICATION,\n  VOICE_COMMUNICATION_SIGNALLING,\n  ALARM,\n  NOTIFICATION,\n  NOTIFICATION_RINGTONE,\n  NOTIFICATION_COMMUNICATION_REQUEST,\n  NOTIFICATION_COMMUNICATION_INSTANT,\n  NOTIFICATION_COMMUNICATION_DELAYED,\n  NOTIFICATION_EVENT,\n  ASSISTANCE_ACCESSIBILITY,\n  ASSISTANCE_NAVIGATION_GUIDANCE,\n  ASSISTANCE_SONIFICATION,\n  GAME,\n}\n\nexport interface AudioAttributes {\n  usage: AndroidAudioUsage;\n  contentType: AndroidAudioContentType;\n  flags: {\n    enforceAudibility: boolean;\n    requestHardwareAudioVideoSynchronization: boolean;\n  };\n}\n\nexport interface NotificationChannel {\n  id: string;\n  name: string | null;\n  importance: AndroidImportance;\n  bypassDnd: boolean;\n  description: string | null;\n  groupId?: string | null;\n  lightColor: string;\n  lockscreenVisibility: AndroidNotificationVisibility;\n  showBadge: boolean;\n  sound: 'default' | 'custom' | null;\n  audioAttributes: AudioAttributes;\n  vibrationPattern: number[] | null;\n  enableLights: boolean;\n  enableVibrate: boolean;\n}\n```\n\n### `NotificationChannelInput`\n\nAn object representing a notification channel to be set.\n\n```ts\nexport interface NotificationChannelInput {\n  name: string | null;\n  importance: AndroidImportance;\n  // Optional attributes\n  bypassDnd?: boolean;\n  description?: string | null;\n  groupId?: string | null;\n  lightColor?: string;\n  lockscreenVisibility?: AndroidNotificationVisibility;\n  showBadge?: boolean;\n  sound?: string | null;\n  audioAttributes?: Partial<AudioAttributes>;\n  vibrationPattern?: number[] | null;\n  enableLights?: boolean;\n  enableVibrate?: boolean;\n}\n```\n\n### `NotificationChannelGroup`\n\nAn object representing a notification channel group (feature available only on Android).\n\n```ts\nexport interface NotificationChannelGroup {\n  id: string;\n  name: string | null;\n  description?: string | null;\n  isBlocked?: boolean;\n  channels: NotificationChannel[];\n}\n```\n\n### `NotificationChannelGroupInput`\n\nAn object representing a notification channel group to be set.\n\n```ts\nexport interface NotificationChannelGroupInput {\n  name: string | null;\n  description?: string | null;\n}\n```\n\n### `NotificationCategory`\n\n```ts\nexport interface NotificationCategory {\n  identifier: string;\n  actions: NotificationAction[];\n  options: {\n    // These options are ALL iOS-only\n    previewPlaceholder?: string;\n    intentIdentifiers?: string[];\n    categorySummaryFormat?: string;\n    customDismissAction?: boolean;\n    allowInCarPlay?: boolean;\n    showTitle?: boolean;\n    showSubtitle?: boolean;\n    allowAnnouncement?: boolean;\n  };\n}\n```\n\n### `NotificationAction`\n\n```ts\nexport interface NotificationAction {\n  identifier: string;\n  buttonTitle: string;\n  textInput?: {\n    submitButtonTitle: string;\n    placeholder: string;\n  };\n  options: {\n    isDestructive?: boolean;\n    isAuthenticationRequired?: boolean;\n    opensAppToForeground?: boolean;\n  };\n}\n```\n","readmeFilename":"README.md","_id":"expo-notifications@0.17.0","_nodeVersion":"16.16.0","_npmVersion":"8.17.0","dist":{"integrity":"sha512-PPjV5WaL5iIKAqi/qsNUVf0g4htz+Mx+6tZ/Py7vIurAHbA2PymgV7UPSEB1gUbhzi5PZMGj/DNFJpSZwgqmNg==","shasum":"c99198cf67d9acae044e6e5acc5b481230751bd8","tarball":"https://registry.npmjs.org/expo-notifications/-/expo-notifications-0.17.0.tgz","fileCount":587,"unpackedSize":2201317,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQCAzJlzlOM9ujhKXA7sEHzH8mwjcsnLhFsmOVD6p5CmSQIhALCWafmREHF9DWoBGWYOCxEVYL6JwuMCHPDooej1ArMY"}],"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjWAHCACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqfgQ/+OR82OsISuQNdr2JFAoqDCuctChF4Xb/gVmSiOBBJvGUUnUfT\r\nHlEQHvAUh4zAc8vYt/NwVA4wJktrpCSv4NzjM+kZ7bB7AggZ/WoDznfp7JRo\r\nJM9qt/L8zv6I69eij49kmVzXG0cVLKfiXMZdUSlvIwQiA7/siDK1FxBydaLT\r\njDcHP2tEZOZAmrL9wbgFFX6CPUcPdYrVzFtC3mxyvKJIY+a3Nc3afbXGsWif\r\nyYy4zHWwlcm8fMfZCE1lcKlcpBli9dyso8yk5855i72wyc/RgPceZvfuE0Ws\r\njVqNhjNjpBYNVX6MItnyfFUEdf/gd8+WgeRqPePYm3XNsB0zu7X+jfNRRedY\r\neCJ/ZW881cnwSudpuZ/QY80tw1fiwIHMg/Y/BY300vOaHrWthGZqjeM62Mih\r\nHr8K9Mbuqj8VJpafxxI+sEkAxQzSCyk/KgcRsj1m+wANx7P/dtEtB0ffqsFm\r\nR7yr/A33WNs8KnPH8nosVujym1Tu4DUtAZv6ku2fOAD9Y+lVYnXa/VjwlHH9\r\nb12Qi5c1mmMBSMVeMTAxsIpSNud1PVFRCw9VIF61bZ9S/qXXE0ad4771DoV7\r\nnb/Kwr5vBl/ViWbMSCrTv5Hcv+y1HiAbbgf7hLaqme87rNmIFjxNnvXRIa5j\r\nZHi99TrxFerODbJvkBTXyc7okr1/W6To8kc=\r\n=qznb\r\n-----END PGP SIGNATURE-----\r\n"},"_npmUser":{"name":"tsapeta","email":"npm@tsapeta.com"},"directories":{},"maintainers":[{"name":"szdziedzic","email":"szymon.dziedzic@swmansion.com"},{"name":"tsapeta","email":"npm@tsapeta.com"},{"name":"dsokal","email":"dominiksokal@gmail.com"},{"name":"wkozyra","email":"wojciech.kozyra@swmansion.com"},{"name":"ide","email":"ide+npm@jameside.com"},{"name":"lukmccall","email":"kosmatylukasz@gmail.com"},{"name":"christopherwalter","email":"chris@christopherwalter.com"},{"name":"kbrandwijk","email":"kim.brandwijk@gmail.com"},{"name":"fiber-god","email":"datwheat@gmail.com"},{"name":"brentvatne","email":"brentvatne@gmail.com"},{"name":"evanbacon","email":"baconbrix@gmail.com"},{"name":"quinlanj","email":"quinlanjung@gmail.com"},{"name":"expoadmin","email":"support@expo.io"},{"name":"tcdavis","email":"tc@expo.io"},{"name":"exponent","email":"exponent.team@gmail.com"},{"name":"wschurman","email":"wschurman@gmail.com"},{"name":"bycedric","email":"me@bycedric.com"},{"name":"jonsamp","email":"sampjon@gmail.com"},{"name":"princefleaswallow","email":"mhampton@hey.com"},{"name":"andyboythekid","email":"andydevs123@gmail.com"},{"name":"kudochien","email":"ckchien@gmail.com"},{"name":"sjchmiela","email":"sjchmiela@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/expo-notifications_0.17.0_1666712002067_0.7947430746999125"},"_hasShrinkwrap":false}},"time":{"created":"2020-03-30T15:19:02.846Z","0.1.0-alpha.0":"2020-03-30T15:19:03.000Z","modified":"2022-11-16T21:57:08.894Z","0.1.0-alpha.1":"2020-03-30T15:49:03.769Z","0.1.0-alpha.2":"2020-03-30T15:59:18.093Z","0.1.0-alpha.3":"2020-03-30T16:25:17.607Z","0.1.0-alpha.4":"2020-03-30T17:11:59.513Z","0.1.0-alpha.5":"2020-03-30T17:25:31.097Z","0.1.0-alpha.6":"2020-03-30T17:39:11.264Z","0.1.0-alpha.7":"2020-03-30T17:44:26.829Z","0.1.0-alpha.8":"2020-03-30T18:03:42.371Z","0.1.0":"2020-03-31T19:45:17.551Z","0.1.1":"2020-03-31T19:48:27.059Z","0.1.2-alpha.0":"2020-04-06T15:47:46.832Z","0.1.2":"2020-04-21T11:59:31.101Z","0.1.3-rc.0":"2020-04-22T12:17:04.864Z","0.1.3":"2020-04-30T13:25:46.680Z","0.1.4":"2020-05-04T10:49:44.793Z","0.1.5":"2020-05-05T13:43:30.781Z","0.1.6":"2020-05-05T16:48:06.285Z","0.1.7":"2020-05-05T17:56:19.670Z","0.2.0":"2020-05-27T15:58:05.568Z","0.3.0":"2020-05-28T18:27:33.332Z","0.3.1":"2020-06-03T17:07:00.652Z","0.3.2":"2020-06-10T11:28:15.297Z","0.4.0":"2020-06-24T21:50:31.873Z","0.3.3":"2020-06-24T22:18:08.399Z","0.5.0":"2020-07-27T07:12:54.362Z","0.6.0":"2020-07-29T14:04:08.061Z","0.7.0":"2020-08-18T14:42:22.013Z","0.7.1":"2020-08-26T09:48:39.150Z","0.7.2":"2020-09-17T08:11:34.825Z","0.8.0":"2020-11-17T04:59:37.777Z","0.8.1":"2020-11-25T23:24:30.831Z","0.8.2":"2020-11-30T22:12:02.192Z","0.9.0":"2021-01-15T21:37:02.638Z","0.10.0":"2021-03-03T20:35:36.895Z","0.11.0":"2021-03-10T01:41:52.115Z","0.11.1":"2021-03-23T04:34:07.874Z","0.11.2":"2021-03-30T17:12:24.387Z","0.11.3":"2021-03-31T17:43:25.564Z","0.11.4":"2021-04-09T22:40:43.912Z","0.11.5":"2021-04-13T19:57:51.670Z","0.11.6":"2021-04-21T00:30:21.151Z","0.12.0":"2021-06-16T19:13:15.810Z","0.12.1":"2021-06-22T00:25:10.328Z","0.12.2":"2021-06-24T20:15:07.861Z","0.12.3":"2021-07-08T20:29:48.095Z","0.13.0":"2021-09-28T15:21:22.015Z","0.13.1":"2021-10-01T23:06:17.770Z","0.13.2":"2021-10-15T18:49:17.773Z","0.13.3":"2021-10-21T21:11:02.624Z","0.14.0":"2021-12-03T21:12:37.422Z","0.14.1":"2022-02-01T19:23:50.844Z","0.15.0":"2022-04-18T15:11:54.554Z","0.15.1":"2022-04-27T14:18:25.236Z","0.15.2":"2022-05-05T19:11:14.493Z","0.15.3":"2022-06-17T18:45:24.754Z","0.15.4":"2022-06-27T17:30:16.760Z","0.16.0":"2022-07-07T23:20:09.536Z","0.16.1":"2022-07-16T17:56:12.502Z","0.17.0":"2022-10-25T15:33:22.302Z"},"maintainers":[{"email":"szymon.dziedzic@swmansion.com","name":"szdziedzic"},{"email":"npm@tsapeta.com","name":"tsapeta"},{"email":"dominiksokal@gmail.com","name":"dsokal"},{"email":"wojciech.kozyra@swmansion.com","name":"wkozyra"},{"email":"ide+npm@jameside.com","name":"ide"},{"email":"kosmatylukasz@gmail.com","name":"lukmccall"},{"email":"keith@expo.io","name":"keith-kurak"},{"email":"chris@christopherwalter.com","name":"christopherwalter"},{"email":"kim.brandwijk@gmail.com","name":"kbrandwijk"},{"email":"datwheat@gmail.com","name":"fiber-god"},{"email":"brentvatne@gmail.com","name":"brentvatne"},{"email":"baconbrix@gmail.com","name":"evanbacon"},{"email":"quinlanjung@gmail.com","name":"quinlanj"},{"email":"support@expo.io","name":"expoadmin"},{"email":"tc@expo.io","name":"tcdavis"},{"email":"exponent.team@gmail.com","name":"exponent"},{"email":"wschurman@gmail.com","name":"wschurman"},{"email":"me@bycedric.com","name":"bycedric"},{"email":"sampjon@gmail.com","name":"jonsamp"},{"email":"mhampton@hey.com","name":"princefleaswallow"},{"email":"ckchien@gmail.com","name":"kudochien"},{"email":"sjchmiela@gmail.com","name":"sjchmiela"}],"description":"Notifications module","homepage":"https://docs.expo.dev/versions/latest/sdk/notifications/","keywords":["react-native","expo","notifications","expo-notifications"],"repository":{"type":"git","url":"git+https://github.com/expo/expo.git","directory":"packages/expo-notifications"},"author":{"name":"650 Industries, Inc."},"bugs":{"url":"https://github.com/expo/expo/issues"},"license":"MIT","readme":"# expo-notifications\n\nProvides an API to fetch push notification tokens and to present, schedule, receive and respond to notifications.\n\n## Features\n\n- üì£ schedule a one-off notification for a specific date, or some time from now,\n- üîÅ schedule a notification repeating in some time interval (or a calendar date match on iOS),\n- 1Ô∏è‚É£ get and set application badge icon number,\n- üì≤ fetch a native device push token so you can send push notifications with FCM and APNS,\n- üòé fetch an Expo push token so you can send push notifications with Expo,\n- üì¨ listen to incoming notifications in the foreground and background,\n- üëÜ listen to interactions with notifications (tapping or dismissing),\n- üéõ handle notifications when the app is in foreground,\n- üîï imperatively dismiss notifications from Notification Center/tray,\n- üóÇ create, update, delete Android notification channels,\n- üé® set custom icon and color for notifications on Android.\n\n# Installation in managed Expo projects\n\nPlease refer to the [installation instructions in the Expo documentation](https://docs.expo.dev/versions/latest/sdk/notifications/#installation).\n\n# Installation in bare React Native projects\n\nFor bare React Native projects, you must ensure that you have [installed and configured the `expo` package](https://docs.expo.dev/bare/installing-expo-modules/) before continuing.\n\n### Add the package to your npm dependencies\n\n```\nexpo install expo-notifications\n```\n\n### Configure for iOS\n\nRun `npx pod-install` after installing the npm package.\n\nIn order to be able to receive push notifications on the device:\n\n- open Xcode workspace from your `ios` folder\n- select your project from the _Navigator_ pane\n- switch to _Signing & Capabilities_ tab\n- ensure that the _Push notifications_ capability is present (if it's not, click the \"+ Capability\" button and add the capability to the project).\n\n### Configure for Android\n\nIn order to be able to receive push notifications on the device ensure that your project is set up for Firebase. For more information on how to do it, see [this guide](https://docs.expo.dev/guides/setup-native-firebase/#bare-workflow-setup).\n\nThis module requires permission to subscribe to device boot. It's used to setup the scheduled notifications right after the device (re)starts. The `RECEIVE_BOOT_COMPLETED` permission is added automatically.\n\n**Note:** Starting from Android 12 (API level 31), to schedule the notification that triggers at the exact time, you need to add `<uses-permission android:name=\"android.permission.SCHEDULE_EXACT_ALARM\"/>` to **AndroidManifest.xml**. You can read more about the exact alarm permission [here](https://developer.android.com/about/versions/12/behavior-changes-12#exact-alarm-permission).\n\n<details><summary><strong>Expand to view how the notification icon and the default color can be customized in a plain React Native app</strong></summary> <p>\n\n- **To customize the icon**:\n\n  You can customize two icons: the default and the large one. See [the Android documentation](https://developer.android.com/guide/topics/ui/notifiers/notifications#Templates) for more details. The steps for them are very similar. The only difference is the tag in the second step.\n\n  1. You will need to ensure that the icon is properly set up and added the project. To read more on how to create a notification icon and add it to the project check out the [‚ÄúCreate notification icon‚Äù section](https://developer.android.com/studio/write/image-asset-studio#create-notification) at the official Android guide. Remember the name you use for the icon asset, you will need it later!\n  2. Then head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_icon\"` (or `android:name=\"expo.modules.notifications.large_notification_icon\"` if you are changing the large icon) inside the `<application>` node referencing the custom icon with `@drawable/<notification_icon_name_you_used_in_step_1>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L44-L46).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" /> <!-- @drawable/<insert_notification_icon_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n\n- **To customize the default color of the notification**:\n  1. you will need a color resource added to the native project's resources. Some information on how to do this can be found in [the official Android guide](https://developer.android.com/guide/topics/resources/more-resources#Color). The most simple and fail-safe instructions would be to:\n     1. ensure that there is a file under `android/app/src/main/res/values/colors.xml` (if there is none, create it)\n     2. ensure that it's a valid resources XML file (it should start with a `<?xml version=\"1.0\" encoding=\"utf-8\"?>` declaration and have a root node of `<resources>`)\n     3. inside the `<resources>` node add a `<color>` node with an arbitrary name (like `notification_icon_color`) containing the color in HEX format inside, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/res/values/colors.xml#L3).\n     4. in the end your `colors.xml` should look more or less like this:\n        ```java\n        <?xml version=\"1.0\" encoding=\"utf-8\"?>\n        <resources>\n          <color name=\"notification_icon_color\">#4630EB</color>\n        </resources>\n        ```\n  2. now, when the color is added to the project, we need to configure `expo-notifications` to use it when it displays a notification ‚Äî head over to `android/app/src/main/AndroidManifest.xml` and add a `<meta-data>` tag of `android:name=\"expo.modules.notifications.default_notification_color\"` inside the `<application>` node referencing the custom icon with `@color/<notification_icon_color_name>`, like [here](https://github.com/expo/expo/blob/335e67a1a3a91598c02061f3318a881541d0d57a/apps/bare-expo/android/app/src/main/AndroidManifest.xml#L47-L49).\n  3. In the end your `AndroidManifest.xml` should look more or less like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    ...\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" /> <!-- @color/<insert_notification_icon_color_name> -->\n      ...\n    </application>\n  </manifest>\n  ```\n- An `AndroidManifest.xml` with both color (of name `notification_icon_color`) and an icon (of name `ic_stat_notifications`) name would look like this:\n  ```xml\n  <manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" ...>\n    <application ...>\n      ...\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_icon\"\n        android:resource=\"@drawable/ic_stat_notifications\" />\n      <meta-data\n        android:name=\"expo.modules.notifications.default_notification_color\"\n        android:resource=\"@color/notification_icon_color\" />\n      ...\n    </application>\n  </manifest>\n  ```\n\n</p>\n</details>\n\n### Config plugin setup (optional)\n\nIf you're using EAS Build, you can set your Android notification icon and color tint, add custom push notification sounds, and set your iOS notification environment using the expo-notifications config plugin ([what's a config plugin?](http://docs.expo.dev/guides/config-plugins/)). To setup, just add the config plugin to the plugins array of your `app.json` or `app.config.js` as shown below, then rebuild the app.\n\n```json\n{\n  \"expo\": {\n    ...\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"icon\": \"./local/path/to/myNotificationIcon.png\",\n          \"color\": \"#ffffff\",\n          \"sounds\": [\"./local/path/to/mySound.wav\", \"./local/path/to/myOtherSound.wav\"],\n          \"mode\": \"production\"\n        }\n      ]\n    ],\n  }\n}\n```\n\n<details><summary><strong>Expand to view property descriptions and default values</strong></summary> <p>\n\n- **icon**: Android only. Local path to an image to use as the icon for push notifications. 96x96 all-white png with transparency.\n- **color**: Android only. Tint color for the push notification image when it appears in the notification tray. Default: \"#ffffff\".\n- **sounds**: Array of local paths to sound files (.wav recommended) that can be used as custom notification sounds.\n- **mode**: iOS only. Environment of the app: either 'development' or 'production'. Default: 'development'.\n\n</p>\n</details>\n\n### Add your project's credentials to Expo server (optional)\n\nIf you would like to send notifications with Expo servers, the servers will need to have a way to authenticate with APNS/FCM that they are authorized to send notifications on your behalf. To do this:\n\n- for Firebase Cloud Messaging, check out this guide: _[Uploading Server Credentials](https://docs.expo.dev/push-notifications/using-fcm/#uploading-server-credentials)_,\n- for APNS:\n  - run `expo credentials:manager` in the root of your application,\n  - if you've already uploaded a Push Notifications Key in another project and would like to reuse it in the current project, select _Use existing Push Notifications Key in current project_ (you may need to set `slug` and `ios.bundleIdentifier` fields in `app.json` so that the server knows to which `experienceId` and `bundleIdentifier` the key should be attributed),\n  - if you've never uploaded a Push Notifications Key or would like to add a new one\n    - select _Add new Push Notifications Key_\n    - if you'd like to let Expo handle the process, select _Let Expo handle the process_\n    - if you can't let Expo handle the process or you want to upload your own key, select _I want to upload my own file_\n      - provide a path to the P8 file you have downloaded from [developer.apple.com](https://developer.apple.com/) website.\n\n# Common gotchas / known issues\n\n### Fetching a push token takes a long time on iOS\n\n`getDevicePushTokenAsync` and `getExpoPushTokenAsync` can sometimes take a long time to resolve on iOS. This is outside of `expo-notifications`'s control, as stated in Apple's [‚ÄúTroubleshooting Push Notifications‚Äù technical note](https://developer.apple.com/library/archive/technotes/tn2265/_index.html):\n\n> This is not necessarily an error condition. The system may not have Internet connectivity at all because it is out of range of any cell towers or Wi-Fi access points, or it may be in airplane mode. Instead of treating this as an error, your app should continue normally, disabling only that functionality that relies on push notifications.\n\nAs mentioned, the most common reasons for this this are either an invalid Internet connection (fetching a push token requires an Internet connection to register the device with the service provider) or an invalid configuration of your App ID or Provisioning Profile.\n\nHere are a few ways people claim to have solved this problem, maybe one of these will help you solve it, too!\n\n<details><summary><strong>Read the Apple's <a href=\"https://developer.apple.com/library/archive/technotes/tn2265/_index.html\">Technical Note on troubleshooting push notifications</a></strong></summary> <p>\n\nGo read the Apple's [Technical Note on troubleshooting push notifications](https://developer.apple.com/library/archive/technotes/tn2265/_index.html)! This the single most reliable source of information on this problem. To help you grasp what they're suggesting:\n\n- Make sure the device has a reliable connection to the Internet (try turning off Wi-Fi or switching to another network, and disabling firewall block on port 5223, as suggested in [this SO answer](https://stackoverflow.com/a/34332047/1123156)).\n- Make sure your app configuration is set properly for registering for push notifications (for bare workflow check out [this guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AddingCapabilities/AddingCapabilities.html#//apple_ref/doc/uid/TP40012582-CH26-SW6), for managed workflow this is done automatically for you by `expo-cli`) as also suggested by [this StackOverflow answer](https://stackoverflow.com/a/10791240/1123156).\n- If you're in bare workflow you may want to try to debug this even further by logging persistent connection debug information as outlined by [this StackOverflow answer](https://stackoverflow.com/a/8036052/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Try again in a little while</strong></summary> <p>\n\n- APNS servers near the device may be down as indicated by [this forum thread](https://developer.apple.com/forums/thread/52224). Take a walk and try again later!\n- Try again in a few days time as suggested by [this GitHub comment](https://github.com/expo/expo/issues/10369#issuecomment-717872956).\n\n</p>\n</details>\n\n<details><summary><strong>Disable network sharing on your device</strong></summary> <p>\n\nYou may need to disable network sharing as this may impact the registration as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59156989/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Restart your device</strong></summary> <p>\n\nIf you just changed the APNS servers where the app should be registering (by installing a TestFlight build over an Xcode build on the same device) you may need to restart your device as suggested by [this StackOverflow answer](https://stackoverflow.com/a/59864028/1123156).\n\n</p>\n</details>\n\n<details><summary><strong>Setup your device with a SIM card</strong></summary> <p>\n\nIf the device you're experiencing this on hasn't been setup with a SIM card it looks like configuring it may help mitigate this bug as suggested by [this StackOverflow answer](https://stackoverflow.com/a/19432504/1123156).\n\n</p>\n</details>\n\n### Setting custom notification sounds\n\nCustom notification sounds are only supported when using [EAS Build](https://docs.expo.dev/build/introduction/), or in the bare workflow.\n\nTo add custom push notification sounds to your app, add the `expo-notifications` plugin to your `app.json` file:\n\n```json\n{\n  \"expo\": {\n    \"plugins\": [\n      [\n        \"expo-notifications\",\n        {\n          \"sounds\": [\"local/path/to/mySoundFile.wav\"]\n        }\n      ]\n    ]\n  }\n}\n```\n\nAfter building your app, the array of files will be available for use in both [`NotificationContentInput`](#notificationcontentinput) and [`NotificationChannelInput`](#notificationchannelinput). You _only_ need to provide the base filename- here's an example using the config above:\n\n```ts\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  sound: 'mySoundFile.wav', // Provide ONLY the base filename\n});\n\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    sound: 'mySoundFile.wav', // Provide ONLY the base filename\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails',\n  },\n});\n```\n\nYou can also manually add notification files to your Android and iOS projects if you prefer:\n\n<details><summary><strong>Manually adding notification sounds on Android</strong></summary> <p>\n\nOn Androids 8.0+, playing a custom sound for a notification requires more than setting the `sound` property on the `NotificationContentInput`. You will _also_ need to configure the `NotificationChannel` with the appropriate `sound`, and use it when sending/scheduling the notification.\n\nFor the example below to work, you would place your `email-sound.wav` file in `android/app/src/main/res/raw/`.\n\n```ts\n// Prepare the notification channel\nawait Notifications.setNotificationChannelAsync('new-emails', {\n  name: 'E-mail notifications',\n  importance: Notifications.AndroidImportance.HIGH,\n  sound: 'email-sound.wav', // <- for Android 8.0+, see channelId property below\n});\n\n// Eg. schedule the notification\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'email-sound.wav', // <- for Android below 8.0\n  },\n  trigger: {\n    seconds: 2,\n    channelId: 'new-emails', // <- for Android 8.0+, see definition above\n  },\n});\n```\n\n</p>\n</details>\n\n<details><summary><strong>Manually adding notification sounds on iOS</strong></summary> <p>\n\nOn iOS, all that's needed is to place your sound file in your Xcode project, and then specify the sound file in your `NotificationContentInput`, like this:\n\n```ts\nawait Notifications.scheduleNotificationAsync({\n  content: {\n    title: \"You've got mail! üì¨\",\n    body: 'Open the notification to read them all',\n    sound: 'notification.wav',\n  },\n  trigger: {\n    // ...\n  },\n});\n```\n\n</p>\n</details>\n\n# Contributing\n\nContributions are very welcome! Please refer to guidelines described in the [contributing guide](https://github.com/expo/expo#contributing).\n\n---\n\n# API\n\nThe following methods are exported by the `expo-notifications` module:\n\n- **fetching token for sending push notifications**\n  - [`getExpoPushTokenAsync`](#getexpopushtokenasyncoptions-expotokenoptions-expopushtoken) -- resolves with an Expo push token\n  - [`getDevicePushTokenAsync`](#getdevicepushtokenasync-devicepushtoken) -- resolves with a device push token\n  - [`addPushTokenListener`](#addpushtokenlistenerlistener-pushtokenlistener-subscription) -- adds a listener called when a new push token is issued\n  - [`removePushTokenSubscription`](#removepushtokensubscriptionsubscription-subscription-void) -- removes the listener registered with `addPushTokenListener`\n- **listening to notification events**\n  - [`useLastNotificationResponse`](#uselastnotificationresponse-undefined--notificationresponse--null) -- a React hook returning the most recently received notification response\n  - [`addNotificationReceivedListener`](#addnotificationreceivedlistenerlistener-event-notification--void-void) -- adds a listener called whenever a new notification is received\n  - [`addNotificationsDroppedListener`](#addnotificationsdroppedlistenerlistener---void-void) -- adds a listener called whenever some notifications have been dropped\n  - [`addNotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) -- adds a listener called whenever user interacts with a notification\n  - [`removeNotificationSubscription`](#removenotificationsubscriptionsubscription-subscription-void) -- removes the listener registered with `addNotification*Listener()`\n- **handling incoming notifications when the app is in foreground**\n  - [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) -- sets the handler function responsible for deciding what to do with a notification that is received when the app is in foreground\n- **fetching permissions information**\n  - [`getPermissionsAsync`](#getpermissionsasync-promisenotificationpermissionsstatus) -- fetches current permission settings related to notifications\n  - [`requestPermissionsAsync`](#requestpermissionsasyncrequest-notificationpermissionsrequest-promisenotificationpermissionsstatus) -- requests permissions related to notifications\n- **managing application badge icon**\n  - [`getBadgeCountAsync`](#getbadgecountasync-promisenumber) -- fetches the application badge number value\n  - [`setBadgeCountAsync`](#setbadgecountasyncbadgecount-number-options-setbadgecountoptions-promiseboolean) -- sets the application badge number value\n- **scheduling notifications**\n  - [`getAllScheduledNotificationsAsync`](#getallschedulednotificationsasync-promisenotification) -- fetches information about all scheduled notifications\n  - [`presentNotificationAsync`](#presentnotificationasynccontent-notificationcontentinput-identifier-string-promisestring) -- schedules a notification for immediate trigger\n  - [`scheduleNotificationAsync`](#schedulenotificationasyncnotificationrequest-notificationrequestinput-promisestring) -- schedules a notification to be triggered in the future\n  - [`cancelScheduledNotificationAsync`](#cancelschedulednotificationasyncidentifier-string-promisevoid) -- removes a specific scheduled notification\n  - [`cancelAllScheduledNotificationsAsync`](#cancelallschedulednotificationsasync-promisevoid) -- removes all scheduled notifications\n  - [`getNextTriggerDateAsync`](#getnexttriggerdateasynctrigger-schedulablenotificationtriggerinput-promisenumber--null) -- calculates next trigger date for a notification trigger\n- **dismissing notifications**\n  - [`getPresentedNotificationsAsync`](#getpresentednotificationsasync-promisenotification) -- fetches information about all notifications present in the notification tray (Notification Center)\n  - [`dismissNotificationAsync`](#dismissnotificationasyncidentifier-string-promisevoid) -- removes a specific notification from the notification tray\n  - [`dismissAllNotificationsAsync`](#dismissallnotificationsasync-promisevoid) -- removes all notifications from the notification tray\n- **managing notification channels (Android-specific)**\n  - [`getNotificationChannelsAsync`](#getnotificationchannelsasync-promisenotificationchannel) -- fetches information about all known notification channels\n  - [`getNotificationChannelAsync`](#getnotificationchannelasyncidentifier-string-promisenotificationchannel--null) -- fetches information about a specific notification channel\n  - [`setNotificationChannelAsync`](#setnotificationchannelasyncidentifier-string-channel-notificationchannelinput-promisenotificationchannel--null) -- saves a notification channel configuration\n  - [`deleteNotificationChannelAsync`](#deletenotificationchannelasyncidentifier-string-promisevoid) -- deletes a notification channel\n  - [`getNotificationChannelGroupsAsync`](#getnotificationchannelgroupsasync-promisenotificationchannelgroup) -- fetches information about all known notification channel groups\n  - [`getNotificationChannelGroupAsync`](#getnotificationchannelgroupasyncidentifier-string-promisenotificationchannelgroup--null) -- fetches information about a specific notification channel group\n  - [`setNotificationChannelGroupAsync`](#setnotificationchannelgroupasyncidentifier-string-channel-notificationchannelgroupinput-promisenotificationchannelgroup--null) -- saves a notification channel group configuration\n  - [`deleteNotificationChannelGroupAsync`](#deletenotificationchannelgroupasyncidentifier-string-promisevoid) -- deletes a notification channel group\n  - **managing notification categories (interactive notifications)**\n  - [`setNotificationCategoryAsync`](#setnotificationcategoryasyncidentifier-string-actions-notificationaction-options-categoryoptions-promisenotificationcategory--null) -- creates a new notification category for interactive notifications\n  - [`getNotificationCategoriesAsync`](#getnotificationcategoriesasync-promisenotificationcategory) -- fetches information about all active notification categories\n  - [`deleteNotificationCategoryAsync`](#deletenotificationcategoryasyncidentifier-string-promiseboolean) -- deletes a notification category\n\n## Custom notification icon and colors (Android only)\n\nSetting a default icon and color for all of your app's notifications is almost too easy. In the managed workflow, just set your [`notification.icon`](https://docs.expo.dev/versions/latest/config/app/#notification) and [`notification.color`](https://docs.expo.dev/versions/latest/config/app/#notification) keys in `app.json`, and rebuild your app! In the bare workflow, you'll need to follow [these instructions](https://github.com/expo/expo/tree/main/packages/expo-notifications#configure-for-android).\n\nFor your notification icon, make sure you follow [Google's design guidelines](https://material.io/design/iconography/product-icons.html#design-principles) (the icon must be all white with a transparent background) or else it may not be displayed as intended.\n\nIn both the managed and bare workflow, you can also set a custom notification color _per-notification_ directly in your [`NotificationContentInput`](#notificationcontentinput) under the `color` attribute.\n\n## Android push notification payload specification\n\nWhen sending a push notification, put an object conforming to the following type as `data` of the notification:\n\n```ts\nexport interface FirebaseData {\n  title?: string;\n  message?: string;\n  subtitle?: string;\n  sound?: boolean | string;\n  vibrate?: boolean | number[];\n  priority?: AndroidNotificationPriority;\n  badge?: number;\n}\n```\n\n## Fetching tokens for push notifications\n\n### `getExpoPushTokenAsync(options: ExpoTokenOptions): ExpoPushToken`\n\nReturns an Expo token that can be used to send a push notification to this device using Expo push notifications service. [Read more in the Push Notifications guide](https://docs.expo.dev/guides/push-notifications/).\n\n> **Note:** For Expo's backend to be able to send notifications to your app, you will need to provide it with push notification keys. This can be done using `expo-cli` (`expo credentials:manager`). [Read more in the ‚ÄúUpload notifications credentials‚Äù guide](https://docs.expo.dev/push-notifications/push-notifications-setup/#credentials).\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios).\n\n#### Arguments\n\nThis function accepts an optional object allowing you to pass in configuration, consisting of fields (all are optional, but some may have to be defined if configuration cannot be inferred):\n\n- **experienceId (_string_)** -- The ID of the experience to which the token should be attributed. Defaults to [`Constants.manifest.id`](https://docs.expo.dev/versions/latest/sdk/constants/#constantsmanifest) exposed by `expo-constants`. In the bare workflow, you must provide a value which takes the shape `@username/projectSlug`, where `username` is the Expo account that the project is associated with, and `projectSlug` is your [`slug` from `app.json`](https://docs.expo.dev/versions/latest/config/app/#slug).\n- **devicePushToken ([_DevicePushToken_](#devicepushtoken))** -- The device push token with which to register at the backend. Defaults to a token fetched with [`getDevicePushTokenAsync()`](#getdevicepushtokenasync-devicepushtoken).\n- **applicationId (_string_)** -- The ID of the application to which the token should be attributed. Defaults to [`Application.applicationId`](https://docs.expo.dev/versions/latest/sdk/application/#applicationapplicationid) exposed by `expo-application`.\n- **development (_boolean_)** -- Makes sense only on iOS, where there are two push notification services: sandbox and production. This defines whether the push token is supposed to be used with the sandbox platform notification service. Defaults to [`Application.getIosPushNotificationServiceEnvironmentAsync()`](https://docs.expo.dev/versions/latest/sdk/application/#applicationgetiospushnotificationserviceenvironmentasync) exposed by `expo-application` or `false`. Most probably you won't need to customize that. You may want to customize that if you don't want to install `expo-application` and still use the sandbox APNS.\n\n#### Returns\n\nReturns a `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Always `expo`.\n- **data (_string_)** -- The push token as a string.\n\n#### Examples\n\n##### Fetching the Expo push token and uploading it to a server\n\n```ts\nimport Constants from 'expo-constants';\nimport * as Notifications from 'expo-notifications';\n\nexport async function registerForPushNotificationsAsync(userId: string) {\n  let experienceId = undefined;\n  if (!Constants.manifest) {\n    // Absence of the manifest means we're in bare workflow\n    experienceId = '@username/example';\n  }\n  const expoPushToken = await Notifications.getExpoPushTokenAsync({\n    experienceId,\n  });\n  await fetch('https://example.com/', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      userId,\n      expoPushToken,\n    }),\n  });\n}\n```\n\n### `getDevicePushTokenAsync(): DevicePushToken`\n\nReturns a native APNS, FCM token or a [`PushSubscription` data](https://developer.mozilla.org/en-US/docs/Web/API/PushSubscription) that can be used with another push notification service.\n\n> **Note:** Especially on iOS, `Promise`s returned by this method may take longer periods of time to fulfill. For more information see [Fetching a push token takes a long time on iOS](#fetching-a-push-token-takes-a-long-time-on-ios) section of the documentation.\n\n#### Returns\n\nA `Promise` that resolves to an object with the following fields:\n\n- **type (_string_)** -- Either `ios`, `android` or `web`.\n- **data (_string_ or _object_)** -- Either the push token as a string (for `type == \"ios\" | \"android\"`) or an object conforming to the type below (for `type == \"web\"`):\n  ```ts\n  {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    }\n  }\n  ```\n\n### `addPushTokenListener(listener: PushTokenListener): Subscription`\n\nIn rare situations a push token may be changed by the push notification service while the app is running. When a token is rolled, the old one becomes invalid and sending notifications to it will fail. A push token listener will let you handle this situation gracefully by registering the new token with your backend right away.\n\n#### Arguments\n\nA single and required argument is a function accepting a push token as an argument. It will be called whenever the push token changes.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a push token listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nimport { registerDevicePushTokenAsync } from '../api';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addPushTokenListener(registerDevicePushTokenAsync);\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `removePushTokenSubscription(subscription: Subscription): void`\n\nRemoves a push token subscription returned by a `addPushTokenListener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addPushTokenListener`.\n\n## Listening to notification events\n\nNotification events include incoming notifications, interactions your users perform with notifications (this can be tapping on a notification, or interacting with it via [notification categories](#managing-notification-categories-interactive-notifications)), and rare occasions when your notifications may be dropped.\n\nA few different listeners are exposed, so we've provided a chart below which will hopefully help you understand when you can expect each one to be triggered:\n\n| User interacted with notification? | App state  | Listener(s) triggered                                                   |\n| :--------------------------------- | :--------: | ----------------------------------------------------------------------- |\n| false                              | Foreground | `NotificationReceivedListener`                                          |\n| false                              | Background | `BackgroundNotificationTask`                                            |\n| false                              |   Killed   | none                                                                    |\n| true                               | Foreground | `NotificationReceivedListener` & `NotificationResponseReceivedListener` |\n| true                               | Background | `NotificationResponseReceivedListener`                                  |\n| true                               |   Killed   | `NotificationResponseReceivedListener`                                  |\n\n> In the chart above, whenever `NotificationResponseReceivedListener` is triggered, the same would apply to the `useLastNotificationResponse` hook.\n\n### `useLastNotificationResponse(): undefined | NotificationResponse | null`\n\nA React hook always returning the notification response that was received most recently (a notification response designates an interaction with a notification, such as tapping on it).\n\n> If you don't want to use a hook, you can use `Notifications.getLastNotificationResponseAsync()` instead.\n\n#### Returns\n\nThe hook may return one of these three types/values:\n\n- `undefined` -- until we're sure of what to return\n- `null` -- if no notification response has been received yet\n- a [`NotificationResponse`](#notificationresponse) object -- if a notification response was received\n\n#### Examples\n\nResponding to a notification tap by opening a URL that could be put into the notification's `data` (opening the URL is your responsibility and is not a part of the `expo-notifications` API):\n\n```ts\nimport * as Notifications from 'expo-notifications';\nimport { Linking } from 'react-native';\n\nexport default function App() {\n  const lastNotificationResponse = Notifications.useLastNotificationResponse();\n  React.useEffect(() => {\n    if (\n      lastNotificationResponse &&\n      lastNotificationResponse.notification.request.content.data.url &&\n      lastNotificationResponse.actionIdentifier === Notifications.DEFAULT_ACTION_IDENTIFIER\n    ) {\n      Linking.openURL(lastNotificationResponse.notification.request.content.data.url);\n    }\n  }, [lastNotificationResponse]);\n\n  return (\n    /*\n     * your app\n     */\n  );\n}\n```\n\n### `addNotificationReceivedListener(listener: (event: Notification) => void): void`\n\nListeners registered by this method will be called whenever a notification is received while the app is running.\n\n#### Arguments\n\nA single and required argument is a function accepting a notification ([`Notification`](#notification)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\nRegistering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport * as Notifications from 'expo-notifications';\n\nexport default function App() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationReceivedListener(notification => {\n      console.log(notification);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n### `addNotificationsDroppedListener(listener: () => void): void`\n\nListeners registered by this method will be called whenever some notifications have been dropped by the server. Applicable only to Firebase Cloud Messaging which we use as notifications service on Android. It corresponds to `onDeletedMessages()` callback. [More information can be found in Firebase docs](https://firebase.google.com/docs/cloud-messaging/android/receive#override-ondeletedmessages).\n\n#### Arguments\n\nA single and required argument is a function‚Äìcallback.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n### `addNotificationResponseReceivedListener(listener: (event: NotificationResponse) => void): void`\n\nListeners registered by this method will be called whenever a user interacts with a notification (eg. taps on it).\n\n#### Arguments\n\nA single and required argument is a function accepting notification response ([`NotificationResponse`](#notificationresponse)) as an argument.\n\n#### Returns\n\nA [`Subscription`](#subscription) object representing the subscription of the provided listener.\n\n#### Examples\n\n##### Registering a notification listener using a React hook\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\n\nexport default function Container() {\n  React.useEffect(() => {\n    const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n      const url = response.notification.request.content.data.url;\n      Linking.openUrl(url);\n    });\n    return () => subscription.remove();\n  }, []);\n\n  return (\n    // Your app content\n  );\n}\n```\n\n##### Handling push notifications with React Navigation\n\nIf you'd like to deep link to a specific screen in your app when you receive a push notification, you can configure React Navigation's [linking](https://reactnavigation.org/docs/navigation-container#linking) prop to do that:\n\n```tsx\nimport React from 'react';\nimport { Linking } from 'react-native';\nimport * as Notifications from 'expo-notifications';\nimport { NavigationContainer } from '@react-navigation/native';\n\nexport default function App() {\n  return (\n    <NavigationContainer\n      linking={{\n        config: {\n          // Configuration for linking\n        },\n        subscribe(listener) {\n          const onReceiveURL = ({ url }: { url: string }) => listener(url);\n\n          // Listen to incoming links from deep linking\n          Linking.addEventListener('url', onReceiveURL);\n\n          // Listen to expo push notifications\n          const subscription = Notifications.addNotificationResponseReceivedListener(response => {\n            const url = response.notification.request.content.data.url;\n\n            // Any custom logic to see whether the URL needs to be handled\n            //...\n\n            // Let React Navigation handle the URL\n            listener(url);\n          });\n\n          return () => {\n            // Clean up the event listeners\n            Linking.removeEventListener('url', onReceiveURL);\n            subscription.remove();\n          };\n        },\n      }}>\n      {/* Your app content */}\n    </NavigationContainer>\n  );\n}\n```\n\nSee more details on [React Navigation documentation](https://reactnavigation.org/docs/deep-linking/#third-party-integrations).\n\n### `removeNotificationSubscription(subscription: Subscription): void`\n\nRemoves a notification subscription returned by a `addNotification*Listener` call.\n\n#### Arguments\n\nA single and required argument is a subscription returned by `addNotification*Listener`.\n\n## Handling incoming notifications when the app is in foreground\n\n### `setNotificationHandler(handler: NotificationHandler | null): void`\n\nWhen a notification is received while the app is running, using this function you can set a callback that will decide whether the notification should be shown to the user or not.\n\nWhen a notification is received, `handleNotification` is called with the incoming notification as an argument. The function should respond with a behavior object within 3 seconds, otherwise the notification will be discarded. If the notification is handled successfully, `handleSuccess` is called with the identifier of the notification, otherwise (or on timeout) `handleError` will be called.\n\nThe default behavior when the handler is not set or does not respond in time is not to show the notification.\n\n#### Arguments\n\nThe function receives a single argument which should be either `null` (if you want to clear the handler) or an object of fields:\n\n- **handleNotification (_(Notification) => Promise<NotificationBehavior>_**) -- (required) a function accepting an incoming notification returning a `Promise` resolving to a behavior ([`NotificationBehavior`](#notificationbehavior)) applicable to the notification\n- **handleSuccess (_(notificationId: string) => void_)** -- (optional) a function called whenever an incoming notification is handled successfully\n- **handleError (_(error: Error) => void_)** -- (optional) a function called whenever handling of an incoming notification fails\n\n#### Examples\n\nImplementing a notification handler that always shows the notification when it is received\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n```\n\n## Handling incoming notifications when the app is not in the foreground (not supported in Expo Go)\n\n> **Please note:** In order to handle notifications while the app is backgrounded on iOS, you _must_ add `remote-notification` to the `ios.infoPlist.UIBackgroundModes` key in your app.json, **and** add `\"content-available\": 1` to your push notification payload. Under normal circumstances, the ‚Äúcontent-available‚Äù flag should launch your app if it isn‚Äôt running and wasn‚Äôt killed by the user, _however_, this is ultimately decided by the OS so it might not always happen.\n\n### `registerTaskAsync(taskName: string): void`\n\nWhen a notification is received while the app is backgrounded, using this function you can set a callback that will be run in response to that notification. Under the hood, this function is run using `expo-task-manager`. You **must** define the task _first_, with [`TaskManager.defineTask`](https://docs.expo.dev/versions/latest/sdk/task-manager/#taskmanagerdefinetasktaskname-task). Make sure you define it in the global scope.\n\nThe `taskName` argument is the string you passed to `TaskManager.defineTask` as the \"taskName\". The callback function you define with `TaskManager.defineTask` will receive the following arguments:\n\n- **data**: The remote payload delivered by either FCM (Android) or APNs (iOS). [See here for details](#pushnotificationtrigger).\n- **error**: The error (if any) that occurred during execution of the task.\n- **executionInfo**: JSON object of additional info related to the task, including the `taskName`.\n\n#### Examples\n\n```ts\nimport * as TaskManager from 'expo-task-manager';\nimport * as Notifications from 'expo-notifications';\n\nconst BACKGROUND_NOTIFICATION_TASK = 'BACKGROUND-NOTIFICATION-TASK';\n\nTaskManager.defineTask(BACKGROUND_NOTIFICATION_TASK, ({ data, error, executionInfo }) => {\n  console.log('Received a notification in the background!');\n  // Do something with the notification data\n});\n\nNotifications.registerTaskAsync(BACKGROUND_NOTIFICATION_TASK);\n```\n\n### `unregisterTaskAsync(taskName: string): void`\n\nUsed to unregister tasks registered with `registerTaskAsync`.\n\n## Fetching information about notifications-related permissions\n\n### `getPermissionsAsync(): Promise<NotificationPermissionsStatus>`\n\nCalling this function checks current permissions settings related to notifications. It lets you verify whether the app is currently allowed to display alerts, play sounds, etc. There is no user-facing effect of calling this.\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nCheck if the app is allowed to send any type of notifications (interrupting and non-interrupting‚Äìprovisional on iOS)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport async function allowsNotificationsAsync() {\n  const settings = await Notifications.getPermissionsAsync();\n  return (\n    settings.granted || settings.ios?.status === Notifications.IosAuthorizationStatus.PROVISIONAL\n  );\n}\n```\n\n### `requestPermissionsAsync(request?: NotificationPermissionsRequest): Promise<NotificationPermissionsStatus>`\n\nPrompts the user for notification permissions according to request. **Request defaults to asking the user to allow displaying alerts, setting badge count and playing sounds**.\n\n#### Arguments\n\nAn optional object of conforming to the following interface:\n\n```ts\n{\n  android?: {};\n  ios?: {\n    allowAlert?: boolean;\n    allowBadge?: boolean;\n    allowSound?: boolean;\n    allowDisplayInCarPlay?: boolean;\n    allowCriticalAlerts?: boolean;\n    provideAppNotificationSettings?: boolean;\n    allowProvisional?: boolean;\n    allowAnnouncements?: boolean;\n  }\n}\n```\n\nEach option corresponds to a different native platform authorization option (a list of iOS options is available [here](https://developer.apple.com/documentation/usernotifications/unauthorizationoptions), on Android all available permissions are granted by default and if a user declines any permission an app can't prompt the user to change).\n\n#### Returns\n\nIt returns a `Promise` resolving to an object representing permission settings (`NotificationPermissionsStatus`).\n\n#### Examples\n\nPrompts the user to allow the app to show alerts, play sounds, set badge count and let Siri read out messages through AirPods\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nexport function requestPermissionsAsync() {\n  return await Notifications.requestPermissionsAsync({\n    ios: {\n      allowAlert: true,\n      allowBadge: true,\n      allowSound: true,\n      allowAnnouncements: true,\n    },\n  });\n}\n```\n\n## Managing application badge icon\n\n### `getBadgeCountAsync(): Promise<number>`\n\nFetches the number currently set as the badge of the app icon on device's home screen. A `0` value means that the badge is not displayed.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will always resolve to `0`.\n\n#### Returns\n\nIt returns a `Promise` resolving to a number representing current badge of the app icon.\n\n### `setBadgeCountAsync(badgeCount: number, options?: SetBadgeCountOptions): Promise<boolean>`\n\nSets the badge of the app's icon to the specified number. Setting to `0` clears the badge.\n\n> **Note:** Not all Android launchers support application badges. If the launcher does not support icon badges, the method will resolve to `false`.\n\n#### Arguments\n\nThe function accepts a number as the first argument. A value of `0` will clear the badge.\n\nAs a second, optional argument you can pass in an object of options configuring behavior applied in Web environment. The object should be of format:\n\n```ts\n{\n  web?: badgin.Options\n}\n```\n\nwhere the type `badgin.Options` is an object described [in the `badgin`'s documentation](https://github.com/jaulz/badgin#options).\n\n#### Returns\n\nIt returns a `Promise` resolving to a boolean representing whether setting of the badge succeeded.\n\n## Scheduling notifications\n\n### `getAllScheduledNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all scheduled notifications.\n\n#### Returns\n\nIt returns a `Promise` resolving to an array of objects conforming to the [`Notification`](#notification) interface.\n\n### `presentNotificationAsync(content: NotificationContentInput, identifier?: string): Promise<string>`\n\nSchedules a notification for immediate trigger.\n\n> **Note:** This method has been deprecated in favor of using an explicit `NotificationHandler` and the `scheduleNotificationAsync` method. More info may be found at https://expo.fyi/presenting-notifications-deprecated.\n\n#### Arguments\n\nThe only argument to this function is a [`NotificationContentInput`](#notificationcontentinput).\n\n#### Returns\n\nIt returns a `Promise` resolving with the notification's identifier once the notification is successfully scheduled for immediate display.\n\n#### Examples\n\n##### Presenting the notification to the user (deprecated way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.presentNotificationAsync({\n  title: 'Look at that notification',\n  body: \"I'm so proud of myself!\",\n});\n```\n\n##### Presenting the notification to the user (recommended way)\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\n// First, set the handler that will cause the notification\n// to show the alert\n\nNotifications.setNotificationHandler({\n  handleNotification: async () => ({\n    shouldShowAlert: true,\n    shouldPlaySound: false,\n    shouldSetBadge: false,\n  }),\n});\n\n// Second, call the method\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Look at that notification',\n    body: \"I'm so proud of myself!\",\n  },\n  trigger: null,\n});\n```\n\n### `scheduleNotificationAsync(notificationRequest: NotificationRequestInput): Promise<string>`\n\nSchedules a notification to be triggered in the future.\n\n> **Note:** Please note that this does not mean that the notification will be presented when it is triggered. For the notification to be presented you have to set a notification handler with [`setNotificationHandler`](#setnotificationhandlerhandler-notificationhandler--null-void) that will return an appropriate notification behavior. For more information see the example below.\n\n#### Arguments\n\nThe one and only argument to this method is a [`NotificationRequestInput`](#notificationrequestinput) describing the notification to be triggered.\n\n#### Returns\n\nIt returns a `Promise` resolving to a string --- a notification identifier you can later use to cancel the notification or to identify an incoming notification.\n\n#### Examples\n\n##### Scheduling the notification that will trigger once, in one minute from now\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: \"Time's up!\",\n    body: 'Change sides!',\n  },\n  trigger: {\n    seconds: 60,\n  },\n});\n```\n\n##### Scheduling the notification that will trigger repeatedly, every 20 minutes\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Remember to drink water!,\n  },\n  trigger: {\n    seconds: 60 * 20,\n    repeats: true\n  },\n});\n```\n\n##### Scheduling the notification that will trigger once, at the beginning of next hour\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nconst trigger = new Date(Date.now() + 60 * 60 * 1000);\ntrigger.setMinutes(0);\ntrigger.setSeconds(0);\n\nNotifications.scheduleNotificationAsync({\n  content: {\n    title: 'Happy new hour!',\n  },\n  trigger,\n});\n```\n\n### `cancelScheduledNotificationAsync(identifier: string): Promise<void>`\n\nCancels a single scheduled notification. The scheduled notification of given ID will not trigger.\n\n#### Arguments\n\nThe notification identifier with which `scheduleNotificationAsync` resolved when the notification has been scheduled.\n\n#### Returns\n\nA `Promise` resolving once the scheduled notification is successfully cancelled or if there is no scheduled notification for given identifier.\n\n#### Examples\n\n##### Scheduling and then canceling the notification\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function scheduleAndCancel() {\n  const identifier = await Notifications.scheduleNotificationAsync({\n    content: {\n      title: 'Hey!',\n    },\n    trigger: { seconds: 5, repeats: true },\n  });\n  await Notifications.cancelScheduledNotificationAsync(identifier);\n}\n```\n\n### `cancelAllScheduledNotificationsAsync(): Promise<void>`\n\nCancels all scheduled notifications.\n\n#### Returns\n\nA `Promise` resolving once all the scheduled notifications are successfully cancelled or if there are no scheduled notifications.\n\n### `getNextTriggerDateAsync(trigger: SchedulableNotificationTriggerInput): Promise<number | null>`\n\nAllows you to check what will be the next trigger date for given notification trigger input.\n\n#### Arguments\n\nThe schedulable notification trigger you would like to check next trigger date for (of type [`SchedulableNotificationTriggerInput`](#schedulablenotificationtriggerinput)).\n\n#### Returns\n\nIf the return value is `null`, the notification won't be triggered. Otherwise, the return value is the Unix timestamp in milliseconds at which the notification will be triggered.\n\n#### Examples\n\n##### Calculating next trigger date for a notification trigger\n\n```ts\nimport * as Notifications from 'expo-notifications';\n\nasync function logNextTriggerDate() {\n  try {\n    const nextTriggerDate = await Notifications.getNextTriggerDateAsync({\n      hour: 9,\n      minute: 0,\n    });\n    console.log(nextTriggerDate === null ? 'No next trigger date' : new Date(nextTriggerDate));\n  } catch (e) {\n    console.warn(`Couldn't have calculated next trigger date: ${e}`);\n  }\n}\n```\n\n## Dismissing notifications\n\n### `getPresentedNotificationsAsync(): Promise<Notification[]>`\n\nFetches information about all notifications present in the notification tray (Notification Center).\n\n> **Note:** This method is not supported on Android below 6.0 (API level 23) ‚Äì on these devices it will resolve to an empty array.\n\n#### Returns\n\nA `Promise` resolving with a list of notifications ([`Notification`](#notification)) currently present in the notification tray (Notification Center).\n\n### `dismissNotificationAsync(identifier: string): Promise<void>`\n\nRemoves notification displayed in the notification tray (Notification Center).\n\n#### Arguments\n\nThe first and only argument to the function is the notification identifier, obtained either in `setNotificationHandler` or in the listener added with `addNotificationReceivedListener`.\n\n#### Returns\n\nResolves once the request to dismiss the notification is successfully dispatched to the notifications manager.\n\n### `dismissAllNotificationsAsync(): Promise<void>`\n\nRemoves all application's notifications displayed in the notification tray (Notification Center).\n\n#### Returns\n\nResolves once the request to dismiss the notifications is successfully dispatched to the notifications manager.\n\n## Managing notification channels (Android-specific)\n\n> Starting in Android 8.0 (API level 26), all notifications must be assigned to a channel. For each channel, you can set the visual and auditory behavior that is applied to all notifications in that channel. Then, users can change these settings and decide which notification channels from your app should be intrusive or visible at all. [(source: developer.android.com)](https://developer.android.com/training/notify-user/channels)\n\nIf you do not specify a notification channel, `expo-notifications` will create a fallback channel for you, named _Miscellaneous_. We encourage you to always ensure appropriate channels with informative names are set up for the application and to always send notifications to these channels.\n\nCalling these methods is a no-op for platforms that do not support this feature (iOS, Web and Android below version 8.0 (26)).\n\n### `getNotificationChannelsAsync(): Promise<NotificationChannel[]>`\n\nFetches information about all known notification channels.\n\n#### Returns\n\nA `Promise` resolving to an array of channels. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `getNotificationChannelAsync(identifier: string): Promise<NotificationChannel | null>`\n\nFetches information about a single notification channel.\n\n#### Arguments\n\nThe only argument to this method is the channel's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel object (of type [`NotificationChannel`](#notificationchannel)) or to `null` if there was no channel found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelAsync(identifier: string, channel: NotificationChannelInput): Promise<NotificationChannel | null>`\n\nAssigns the channel configuration to a channel of a specified name (creating it if need be). This method lets you assign given notification channel to a notification channel group.\n\n> **Note:** For some settings to be applied on all Android versions, it may be necessary to duplicate the configuration across both a single notification _and_ it's respective notification channel. For example, for a notification to play a custom sound on Android versions **below** 8.0, the custom notification sound has to be set on the notification (through the [`NotificationContentInput`](#notificationcontentinput)), and for the custom sound to play on Android versions **above** 8.0, the relevant notification channel must have the custom sound configured (through the [`NotificationChannelInput`](#notificationchannelinput)). For more information, see [\"Setting custom notification sounds on Android\"](#setting-custom-notification-sounds-on-android).\n\n#### Arguments\n\nFirst argument to the method is the channel identifier.\n\nSecond argument is the channel's configuration of type [`NotificationChannelInput`](#notificationchannelinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannel`](#notificationchannel)) describing the modified channel or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel.\n\n#### Arguments\n\nFirst and only argument to the method is the channel identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel is removed (or if there was no channel for given identifier).\n\n### `getNotificationChannelGroupsAsync(): Promise<NotificationChannelGroup[]>`\n\nFetches information about all known notification channel groups.\n\n#### Returns\n\nA `Promise` resolving to an array of channel groups. On platforms that do not support notification channel groups, it will always resolve to an empty array.\n\n### `getNotificationChannelGroupAsync(identifier: string): Promise<NotificationChannelGroup | null>`\n\nFetches information about a single notification channel group.\n\n#### Arguments\n\nThe only argument to this method is the channel group's identifier.\n\n#### Returns\n\nA `Promise` resolving to the channel group object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) or to `null` if there was no channel group found for this identifier. On platforms that do not support notification channels, it will always resolve to `null`.\n\n### `setNotificationChannelGroupAsync(identifier: string, channel: NotificationChannelGroupInput): Promise<NotificationChannelGroup | null>`\n\nAssigns the channel group configuration to a channel group of a specified name (creating it if need be).\n\n#### Arguments\n\nFirst argument to the method is the channel group identifier.\n\nSecond argument is the channel group's configuration of type [`NotificationChannelGroupInput`](#notificationchannelgroupinput)\n\n#### Returns\n\nA `Promise` resolving to the object (of type [`NotificationChannelGroup`](#notificationchannelgroup)) describing the modified channel group or to `null` if the platform does not support notification channels.\n\n### `deleteNotificationChannelGroupAsync(identifier: string): Promise<void>`\n\nRemoves the notification channel group and all notification channels that belong to it.\n\n#### Arguments\n\nFirst and only argument to the method is the channel group identifier.\n\n#### Returns\n\nA `Promise` resolving once the channel group is removed (or if there was no channel group for given identifier).\n\n## Managing notification categories (interactive notifications)\n\nNotification categories allow you to create interactive push notifications, so that a user can respond directly to the incoming notification either via buttons or a text response. A category defines the set of actions a user can take, and then those actions are applied to a notification by specifying the `categoryIdentifier` in the [`NotificationContent`](#notificationcontent).\n\nOn iOS, notification categories also allow you to customize your notifications further. With each category, not only can you set interactive actions a user can take, but you can also configure things like the placeholder text to display when the user disables notification previews for your app.\n\nCalling one of the following methods is a no-op on Web.\n\n### `setNotificationCategoryAsync(identifier: string, actions: NotificationAction[], options: CategoryOptions): Promise<NotificationCategory | null>`\n\n#### Arguments\n\n- `identifier`: A string to associate as the ID of this category. You will pass this string in as the `categoryIdentifier` in your [`NotificationContent`](#notificationcontent) to associate a notification with this category.\n- `actions`: An array of [`NotificationAction`s](#notificationaction), which describe the actions associated with this category. Each of these actions takes the shape:\n  - `identifier`: A unique string that identifies this action. If a user takes this action (i.e. selects this button in the system's Notification UI), your app will receive this `actionIdentifier` via the [`NotificationResponseReceivedListener`](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void).\n  - `buttonTitle`: The title of the button triggering this action.\n  - `textInput`: **Optional** object which, if provided, will result in a button that prompts the user for a text response.\n    - `submitButtonTitle`: (**iOS only**) A string which will be used as the title for the button used for submitting the text response.\n    - `placeholder`: A string that serves as a placeholder until the user begins typing. Defaults to no placeholder string.\n  - `options`: **Optional** object of additional configuration options.\n    - `opensAppToForeground`: Boolean indicating whether triggering this action foregrounds the app (defaults to `true`). If `false` and your app is killed (not just backgrounded), [`NotificationResponseReceived` listeners](#addnotificationresponsereceivedlistenerlistener-event-notificationresponse--void-void) will not be triggered when a user selects this action.\n    - `isAuthenticationRequired`: (**iOS only**) Boolean indicating whether triggering the action will require authentication from the user.\n    - `isDestructive`: (**iOS only**) Boolean indicating whether the button title will be highlighted a different color (usually red). This usually signifies a destructive action such as deleting data.\n- `options`: An optional object of additional configuration options for your category (**these are all iOS only**):\n  - `previewPlaceholder`: Customizable placeholder for the notification preview text. This is shown if the user has disabled notification previews for the app. Defaults to the localized iOS system default placeholder (`Notification`).\n  - `intentIdentifiers`: Array of [Intent Class Identifiers](https://developer.apple.com/documentation/sirikit/intent_class_identifiers). When a notification is delivered, the presence of an intent identifier lets the system know that the notification is potentially related to the handling of a request made through Siri. Defaults to an empty array.\n  - `categorySummaryFormat`: A format string for the summary description used when the system groups the category‚Äôs notifications.\n  - `customDismissAction`: A boolean indicating whether to send actions for handling when the notification is dismissed (the user must explicitly dismiss the notification interface- ignoring a notification or flicking away a notification banner does not trigger this action). Defaults to `false`.\n  - `allowInCarPlay`: A boolean indicating whether to allow CarPlay to display notifications of this type. **Apps must be approved for CarPlay to make use of this feature.** Defaults to `false`.\n  - `showTitle`: A boolean indicating whether to show the notification's title, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `showSubtitle`: A boolean indicating whether to show the notification's subtitle, even if the user has disabled notification previews for the app. Defaults to `false`.\n  - `allowAnnouncement`: A boolean indicating whether to allow notifications to be automatically read by Siri when the user is using AirPods. Defaults to `false`.\n\n#### Returns\n\nA `Promise` resolving to the category you just created.\n\n### `getNotificationCategoriesAsync(): Promise<NotificationCategory[]>`\n\nFetches information about all known notification categories.\n\n#### Returns\n\nA `Promise` resolving to an array of `NotificationCategory`s. On platforms that do not support notification channels, it will always resolve to an empty array.\n\n### `deleteNotificationCategoryAsync(identifier: string): Promise<boolean>`\n\nDeletes the category associated with the provided identifier.\n\n#### Arguments\n\nIdentifier initially provided to `setNotificationCategoryAsync` when creating the category.\n\n#### Returns\n\nA `Promise` resolving to `true` if the category was successfully deleted, or `false` if it was not. An example of when this method would return `false` is if you try to delete a category that doesn't exist.\n\n## Types\n\n### `DevicePushToken`\n\nIn simple terms, an object of `type: Platform.OS` and `data: any`. The `data` type depends on the environment -- on a native device it will be a string, which you can then use to send notifications via Firebase Cloud Messaging (Android) or APNS (iOS); on web it will be a registration object (VAPID).\n\n```ts\nexport interface NativeDevicePushToken {\n  type: 'ios' | 'android';\n  data: string;\n}\n\nexport interface WebDevicePushToken {\n  type: 'web';\n  data: {\n    endpoint: string;\n    keys: {\n      p256dh: string;\n      auth: string;\n    };\n  };\n}\n\nexport type DevicePushToken = NativeDevicePushToken | WebDevicePushToken;\n```\n\n### `PushTokenListener`\n\nA function accepting a device push token ([`DevicePushToken`](#devicepushtoken)) as an argument.\n\n> **Note:** You should not call `getDevicePushTokenAsync` inside this function, as it triggers the listener and may lead to an infinite loop.\n\n### `ExpoPushToken`\n\nBorrowing from `DevicePushToken` a little bit, it's an object of `type: 'expo'` and `data: string`. You can use the `data` value to send notifications via Expo Notifications service.\n\n```ts\nexport interface ExpoPushToken {\n  type: 'expo';\n  data: string;\n}\n```\n\n### `Subscription`\n\nA common-in-React-Native type to abstract an active subscription.","readmeFilename":"README.md"}